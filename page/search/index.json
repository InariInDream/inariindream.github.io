[{"content":"C++：从零开始手搓一个智能指针吧 前言 智能指针是C++11引入的一个新特性，它是一个模板类，用于管理动态分配的对象。智能指针的主要目的是自动释放内存，避免内存泄漏。智能指针的实现原理是利用了RAII（Resource Acquisition Is Initialization）技术，即资源获取即初始化。智能指针的实现有很多种，比如std::shared_ptr、std::unique_ptr、std::weak_ptr等。本文将从零开始手搓一个智能指针，以msvc的实现为例。\n参考这篇文章的实现\n类的前向声明 template \u0026lt;typename Ty\u0026gt; struct shared_ptr; template \u0026lt;typename Ty\u0026gt; struct weak_ptr; template \u0026lt;class Ty\u0026gt; struct enable_shared_from_this; template \u0026lt;typename Ty\u0026gt; constexpr auto can_enable_shared = std::is_base_of_v\u0026lt;enable_shared_from_this\u0026lt;Ty\u0026gt;, Ty\u0026gt;; 引用计数 pirvate部分的_uses和_weaks分别表示当前对象的引用计数和弱引用计数。\ntemplate \u0026lt;typename Ty\u0026gt; struct RefCount { private: std::atomic_int32_t _uses = 1; std::atomic_int32_t _weaks = 1; Ty *_ptr; }; 成员函数\ntemplate \u0026lt;typename Ty\u0026gt; struct RefCount { RefCount(Ty *raw_ptr) : _ptr(raw_ptr) { } void add_ref() { _uses++; } void sub_ref() { if ((--_uses) == 0) { destroy_resource(); sub_wref(); } } void add_wref() { _weaks++; } void sub_wref() { if ((--_weaks) == 0) { delete_this(); } } bool try_add_ref() { if (_uses == 0) return false; _uses++; return true; } void destroy_resource() noexcept { delete _ptr; } void delete_this() noexcept { delete this; } int32_t use_count() { return _uses; } private: std::atomic_int32_t _uses = 1; std::atomic_int32_t _weaks = 1; Ty *_ptr; }; 这里有几个需要注意的地方：\n在delete时候使用noexcept，这样可以避免在析构函数中抛出异常，允许编译器做出额外的优化。\n在_uses变为0，即资源被释放之后，也同时减少代表这个RefCount实例本身的计数_weaks，表示现在这个RefCount实例本身不需要再为这个资源服务了。如果_weaks也变为0，那么这个RefCount实例本身也可以被释放了。\nvoid sub_ref() { if ((--_uses) == 0) { destroy_resource(); sub_wref(); } } PtrBase 构造函数的声明\ntemplate \u0026lt;class Ty\u0026gt; struct Ptr_base { Ptr_base() = default; Ptr_base(const Ptr_base \u0026amp;) = delete; Ptr_base \u0026amp;operator=(const Ptr_base \u0026amp;) = delete; 这里的两个delete是为了防止拷贝构造和拷贝赋值，因为在智能指针的实现中，拷贝构造和拷贝赋值都将有可能导致我们实现的引用计数的错误。\nPtrBase 的完整定义\ntemplate\u0026lt;typename T\u0026gt; struct Ptr_base { Ptr_base() = default; Ptr_base(const Ptr_base \u0026amp;) = delete; Ptr_base \u0026amp;operator=(const Ptr_base \u0026amp;) = delete; T *get() const noexcept { return _ptr; } auto use_count() const noexcept { return _ref ? _ref-\u0026gt;use_count() : 0; } template\u0026lt;typename _T2\u0026gt; void swap(Ptr_base\u0026lt;_T2\u0026gt; \u0026amp;rhs) { std::swap(_ptr, rhs._ptr); std::swap(_ref, rhs._ref); } private: friend class shared_ptr\u0026lt;T\u0026gt;; friend class weak_ptr\u0026lt;T\u0026gt;; T *_ptr = nullptr; RefCount\u0026lt;T\u0026gt; *_ref = nullptr; void _init(T *rwa_ptr) { _ptr = rwa_ptr; _ref = new RefCount\u0026lt;T\u0026gt;(_ptr); } void add_ref() const { if (_ref) { _ref-\u0026gt;add_ref(); } } void sub_ref() const { if (_ref) { _ref-\u0026gt;sub_ref(); } } void add_wref() const { if (_ref) { _ref-\u0026gt;add_wref(); } } void sub_wref() const { if (_ref) { _ref-\u0026gt;sub_wref(); } } template\u0026lt;typename _T2\u0026gt; void _copy_ptr_from(const Ptr_base\u0026lt;_T2\u0026gt; \u0026amp;rhs) { _ptr = rhs._ptr; _ref = rhs._ref; // note: no need to add_ref here } template\u0026lt;typename _T2\u0026gt; void _move_construct_from(Ptr_base\u0026lt;_T2\u0026gt; \u0026amp;\u0026amp;rhs) noexcept { _copy_ptr_from(rhs); rhs._ptr = nullptr; rhs._ref = nullptr; } template\u0026lt;typename _T2\u0026gt; void _copy_construct_from_shared(const shared_ptr\u0026lt;_T2\u0026gt; \u0026amp;rhs) noexcept { rhs.add_ref(); // add_ref is here _copy_ptr_from(rhs); } template\u0026lt;typename _T2\u0026gt; void _weakly_construct_from(const Ptr_base\u0026lt;_T2\u0026gt; \u0026amp;rhs) noexcept { _copy_ptr_from(rhs); add_wref(); } template\u0026lt;typename _T2\u0026gt; bool _construct_from_weak(const weak_ptr\u0026lt;_T2\u0026gt; \u0026amp;rhs) noexcept { if (rhs._ref \u0026amp;\u0026amp; rhs._ref-\u0026gt;try_add_ref()) { _copy_ptr_from(rhs); return true; } return false; } }; 注意这个_copy_ptr_from()函数，在刚写这个函数的时候我发现它并没有进行引用计数的增加，但是注意看： template\u0026lt;typename _T2\u0026gt; void _copy_construct_from_shared(const shared_ptr\u0026lt;_T2\u0026gt; \u0026amp;rhs) noexcept { rhs.add_ref(); // add_ref is here _copy_ptr_from(rhs); } template\u0026lt;typename _T2\u0026gt; void _weakly_construct_from(const Ptr_base\u0026lt;_T2\u0026gt; \u0026amp;rhs) noexcept { _copy_ptr_from(rhs); add_wref(); } 可以看到两个函数调用_copy_ptr_from()的顺序略有不同。\n在_copy_construct_from_shared()中，首先调用rhs.add_ref()是至关重要的，以确保在任何可能的异常抛出之前增加引用计数，避免资源泄露。\n对于_weakly_construct_from()，先复制指针和引用计数器信息，然后通过add_wref()增加弱引用计数是符合逻辑的，因为这个操作不涉及改变资源的拥有权，只是注册了一个新的观察者。\n不在_copy_ptr_from()增加引用计数的原因，也就不言而明了。\n_copy_construct_from_shared()中使用rhs.add_ref()而非成员函数add_ref()\n在_copy_construct_from_shared()中，调用rhs.add_ref()是为了增加传入的shared_ptr (rhs) 对象所管理资源的引用计数。这是因为我们正在创建一个新的智能指针，它将共享rhs指向的资源，因此必须表明现在有另一个所有者（即当前对象）也在使用该资源。\n使用rhs.add_ref()而不是this-\u0026gt;add_ref()确保了正确地修改了rhs所关联的引用计数器，而不是错误地尝试修改还未完全构建或配置好的当前对象的引用计数器。\n_weakly_construct_from中使用自己的成员函数add_wref()而非rhs.add_wref()\n这里，使用add_wref()是为了增加当前对象对资源的弱引用计数，因为该函数设计用来在复制或移动构造过程中设置当前对象的状态。当从一个weak_ptr构造时，我们希望表明当前对象（作为一个新的弱引用所有者）也关联到了相同的资源，但不增加资源的强引用计数。\n右值引用和万能转发\n跟智能指针本身的实现没什么大关系，不过算是一个C++八股，就刚好顺着记一记。\ntemplate\u0026lt;typename _T2\u0026gt; void _move_construct_from(Ptr_base\u0026lt;_T2\u0026gt; \u0026amp;\u0026amp;rhs) noexcept { _copy_ptr_from(rhs); rhs._ptr = nullptr; rhs._ref = nullptr; } 这里的_move_construct_from()函数接受一个右值引用，这是C++11的特性，用来表示一个临时对象。用于支持移动语义和完美转发。当你看到一个函数参数类型为Type \u0026amp;\u0026amp;时，这意味着它可以绑定到一个即将被销毁或不再需要的临时对象上（一个右值），允许在不复制数据的情况下转移资源所有权。\n在这里，原来的对象rhs是一个即将被销毁的临时对象，我们可以直接从它那里“偷走”资源，而不需要复制数据来达到move的效果。这样可以避免不必要的内存分配和数据复制，提高程序的性能。\n","date":"2024-02-27T19:57:41Z","image":"https://inariindream.cn/blog/2024/02/27/c-%E4%BB%8E%E9%9B%B6%E5%BC%80%E5%A7%8B%E6%89%8B%E6%90%93%E4%B8%80%E4%B8%AA%E6%99%BA%E8%83%BD%E6%8C%87%E9%92%88%E5%90%A7/111_hud01f6311ae62f9cf7854d221fe6ce4a4_2641592_120x120_fill_box_smart1_3.png","permalink":"https://inariindream.cn/blog/2024/02/27/c-%E4%BB%8E%E9%9B%B6%E5%BC%80%E5%A7%8B%E6%89%8B%E6%90%93%E4%B8%80%E4%B8%AA%E6%99%BA%E8%83%BD%E6%8C%87%E9%92%88%E5%90%A7/","title":"C++：从零开始手搓一个智能指针吧"},{"content":"能连续四年都坚持把这个看起来十分矫情又没人看的年终总结坚持下来，说实话我自己也很惊讶。但转念想想，也许是因为我用文字将自己无处安放的表达欲抒发了出来，将内心的感受记录了下来，我才能切实地感受到：“These are the moments I felt most aware of being alive.”\n回顾阶段 在不同的阶段翻看以前的总结时，总是会有不一样的感受，而同时也能用现有的经历回答过去的自己提出的问题。\n刚入学时的我，对我的高考成绩有着不小的遗憾，或许是出于体面，或许是出于期盼，第一年的我，满怀希冀地写道“虽然学校没有那么好，但其仍是我努力的平台”。但站在今天的视角回看，似乎我没有一项成就是真的通过学校这个平台本身努力得到的。我如果真的在海大这个平台的评价体系下不懈努力地卷绩点，评优秀的话，现在应该早已放弃了遥不可及的计算机梦想了。\n考完插班生的那年，大概是出于面子，不想承认由于我对高考耿耿于怀做出的选择，导致了我浪费了接近三百天的光阴追逐了一个不可达的幻影。我只是隐晦地提及了我的后悔，并安慰自己“认识了许多优秀的人”但其后的无数个日夜我都会回想，如果我大一就认识了acm集训队开始训练的话，我的大学轨迹仍会是现在这样吗？是的，我十分后悔在大一选择了考取插班生。\n类似的感想还有数学建模和挑战杯等，不过就不多评价了。这样的体验总是很有趣，能对同一件事有不同的感受就说明自己确实地在向前迈步。\n贯穿我今年一年的一个重要的关键词应该是 “保研”，但其实，无论我想或不想，它应该是贯穿了我几乎整个的大学生活。\n大一 在大一的时候我应该是有强烈的保研梦的，因为我自认为考砸了30-40分才会来这个学校，而就那时的我接触到的信息，我所认知到的能改变现状的方法，一个是“插班生”，一个是保研 （在这么弱的学校不当第一拿保研资格还有天理吗？）\n而后来的结果也很众所周知了，转专业以0.002的绩点之差无缘计算机，插班生以数学的六分之差宣告我267天备考之旅的结束。\n唯一的收获，可能就只有因为备考带来的高数上下的满绩了吧。\n大二 大二其实没有特别关注过保研的事情，因为觉得自己分流后是专业第二， 稳一稳怎么都能有保研名额的，转而投身算法竞赛，沉浸于ACM的世界。\n不过在十月份的时候，在校ACM群见识到了保研中科院大佬的存在，还记得那时候他们的聊天我几乎一句也看不懂，我暗暗下定决心要好好学算法和工程技术。现在想来，也许这里就是把我从海大的评价体系中解放出来和让我抛弃学生思维的第一个契机吧。\n因为无论是当时ACM的学生教练还是那位靠工程技术保研中科院的大佬，他们的共性都是不在乎综测的多寡与绩点的好坏，唯看对自己的真实学术水平和能力积累有无帮助。 我一直以来视为唯一出路的保研在他们眼里似乎只是一个次优的可选项。而这样的人，却几乎都在海大的固有评价体系里无法得到认可，有的甚至寸步难行。我对此感到十分失望却又无可奈何。\n大三 在大三那年，学校的保研政策迎来了重大的变化，由以前的两条赛道（纯绩点，纯科创）合并为了一条路，绩点占比70%，科创成果20%，综测10%。这一变化对于我来说，是一个很大的利好。据我所知，同专业绩点在前列的其他人是几乎没有拿得出手的比赛的。\n每10分科创分可以约等于0.115的绩点，A类国一是100分，国二是80分，20分就是0.23了，因此，在去年的这个时候，我其实已经准备开香槟了（？\n因为我不认为我们专业绩点前列的人在零基础的情况下能在一年的时间内速成一个国一，并且他们打的团队赛还涉及到组内分数分配的问题 （后来才知道是可以不按照文件的分配方式分配的） ，我认为他们不可能比得过我的个人赛 + 国一的。\n专业往年一般是2个名额，也就是说，我保不上研=专业里同时有两个绩点比我高同时还都能拿国一的人，在那时我觉得这是不可能的事（后来被很很打脸了）\n但，也就是在这一年，我第一次对是否保研，产生了强烈的动摇。\n因为ACM的关系，我认识到了很多其他学校优秀的人，也有很多行业内的大佬级别的人物，通过他们的聊天我得知了22年秋招的现状 （寒冬），让我对以前计算机行业现状的幻想破灭的同时，也彻底击碎了我一直以来对高学历的滤镜。\n我开始犹豫，我是否真的需要这一个研究生学历。\n同时，自己对以绩点至上的评价体系的失望 + 对于是否读研的犹豫，迫使我尽快做好另一手准备：秋招\n很多人都来问过我为什么不去选择考研（甚至字节一面的面试官也问过），其实表层原因很简单：大一我已经备考过一年的插班生了，我不想大三再做一年题，这样我的大学时光将会有一半都是在做题中度过。\n深层原因，除了上面的那张图，还有就是客观来讲\n考研是存在风险的，一个是能不能考上的风险，另一个考什么水平的风险。同时外部环境：现在学历歧视越来越严重，我现在被歧视双非本科，三年后很有可能歧视本科是双非； 另一方面经济形势，三年后的就业市场状态是完全未知的，2020年读研究生的那一批人几乎不会有人能料想到2022年秋招的惨状。 也就是说考研要首先保证能考上（考不上只能零基础春招或二战），其次要保证考上的学校title有用（没用等于晚出生三年罢了），最后还需要保证三年的提升能跟得上互联网行业紧缩的速度。量化一点的语言来说就是需要保证考研上岸的收益能够抵消（考不上+行业紧缩）的debuff，而根据我对自己做题毅力的评价和我观察到的行业紧缩的速度来看，这个期望显然不是正值。\n大三下学期的因病住院和各种各样的意外情况使我当学期的绩点达到了六学期最低的水平，同时我们专业真的出现了两个国一的奖项，我无法保研的事情几乎已经是确定的事了。我于是开始安心准备秋招。\n九月份的时候，我的综合排名不出意外地排在了第三，按照往年的名额应该是无了，但今年似乎抢到了全学院竞争的名额。纠结了很久，询问了很多大佬的意见，我最终还是选择了读研。\n读研和秋招的选择 在拿到资格的第二天，我拿到了之前面试过的某家小厂的offer call，开出的薪资虽然在现在的我看来不算高，但却也是我在上大学之前不敢想过的水平。可以说，2023年的9月下旬，是我至今为止的21年时光里最为纠结和痛苦的时段。\n至于为什么最终在就业和读研里选择了后者，\n一是从上文的计量方式来说，保研显然没有（考不上+title弱）的debuff，这样一来期望就仍有变为正值的可能（取决于行业紧缩速度）。\n二是似乎是因为在别人开导下，我发现我喜欢的是“计算机”本身，而不是计算机所带来的附加利益（高薪，大厂等），计算机之所以被称为“宇宙机”，是因为前几年互联网红利期带来的高薪且低门槛的岗位。由此造成了 “天下熙熙，皆为利来；天下攘攘，皆为利往” 的转码热潮，我扪心自问，我是其中一员吗？得到的答案是否定的。\n我自认为是一个物欲水平不高的人，单纯的高薪比起要付出的努力不足以支撑我本科三年间双修的动力。回想起我喜欢计算机的原因，也许最初就来自于影视作品中键盘敲得飞快的“黑客们”，憧憬着成为这样的人，这样简单的原因，对于我来说就足以成为我努力的动力了。\n读研也刚好能给我三年的时间，使我第一次能够全身心投入我真正喜欢的领域里。\n当然这只是一个角度，如果我保研失败，我大概就会大谈互联网行业现状，谈进入工业界才能学到真东西，谈研究生三年读出来可能被本科就业的同学面试等等。这样看来，人是很难不被主观情绪影响的。对我而言，两种人生都很难具体地计量孰优孰劣，这种问题大多都有点类似零和博弈，选择了其中一种，意味着另一种未选择的人生从此只能出现在理想中了。我所能做的，就是尽量不让自己去美化那条未选择的道路。\n生活 其实就今年一年来说，我还是算过得蛮不错的。除开4-5月份找暑期实习焦虑了2个月，8-9月秋招焦虑和忙碌了2个月（几乎每周都是十多场的笔试/面试），剩下8个月的时间都过得很充实 （摆烂）。\n寒假的时候天天跟群友欢乐鹅鸭杀和玩acm主题你画我猜，某次有个树状数组的很形象的图我猜成分治了（学的时候真没看过示意图\n3月份的ec-final的时候算是上半年最开心的一个点，是竞赛生涯第一次也是最后一次打线下赛，跟群友面基合照，平时群里聊天吹水最多的到了线下反而十分腼腆（乐）。见到了数量众多的大佬，跟江莉合了影，要到了杜老师的签名，还听到了杜老师大展歌喉hhh，唯一有点可惜的是大家玩的太开心了到最后困得各回各家了，na姐之后想起没有大合照一下，毕竟或许很多人以后不再有机会参加这样的盛筵了。\n5月份去了cp29，可惜只抢到了第二天的票，很多摊位的物料和比较想买的东西都没有了。。一天走了3w步，纯纯的二次元军训\n下半年生活方面整体比较平淡，12月跟川哥在三亚爽玩了4天，还第一次体验了下潜水。感想是大海真蓝，海鲜真好吃，以及在海南的东北人真的好多（\n七月底去ChinaJoy玩了，感受是一届比一届拉了，今年大厂商就来了个索尼，PS5展台排队人还是挺多的，可惜抽奖就抽到了个PS5口罩，排我前面那个人抽了个键盘给我馋疯了。动物派对的展台排了里三层外三层，一问才知道原来游戏胜利了送个封面图里的那个柯基大公仔，我本来是有点想要的，看了下人比索尼展台的都多就润了。。。\n没课了之后去看了RADWIMPS的演唱会，蹭实验室的千兆网抢到的票。在场外拿无料的时候有一家面馆在外放各种RADWIMPS的歌，大家也就跟着一直从Tummy唱到前前前世，氛围十分棒。演唱会的体验也很好，最后的encore环节，全场的人都在一起唱歌（虽然每个区参差不齐），也算是今年非常难忘的体验了。\n看了下steam的年度回顾才发现今年游戏玩的挺多的（摆烂铁证），艾尔登法环神中神，第一周目就已经玩了150小时了，把不怎么玩游戏的室友带入法环坑之后现在天天在那真香。\n10月份的时候由于不甘心唱日文歌的时候只能当罗马音战士，给自己定了个目标今年通过N2，嗯\u0026hellip;结果背了两天就忘了，每周只有在看月曜的时候安慰自己是在学日语（\n年底抽空把高中那会没看完的《堂吉诃德》给看完了，主人公很“中二”，高中时期的我对其很是感同身受。但以现在的视角重新认真地把这本书看完之后，感悟还是挺多的。\n到北方之后发现气候是真的挺干燥的，刚到的那一周鼻血几乎没停过，地上的积雪两周都没化，给了南方孩子极大的震撼。\n暑期实习的时候算是在家里remote，没什么特别的感觉，实习了一个月发现学不到什么东西钱也不多就跑路了。到百京实习之后，虽然好像学的也不多，但好歹每天算是正经到工位写代码了，给的也比暑实的多很多，能自己租房的同时还能不用家里给生活费了，算是有一点小小的成就感吧。\n今年份的有感而发 成败的因素 我的整个大学求学之路曲折而漫长，其中的酸甜苦辣无法以我浅显的文字全部抒发出来，而双修计算机和本专业的个中滋味则更是只有我自己能体会。\n记得高中的时候看过一句鸡汤\n命是弱者借口，运乃强者谦词\n当时的我，并没有觉得这句话有什么不对，相反将其视作勉励自己的支柱之一，努力使自己不成为用“命”当借口的弱者。\n但实际上不是的，这句话忽略了客观上不平等对人们命运的影响。社会背景、经济条件、种族、性别等因素都会对个人的机会和结果产生重大影响。因此，将一切归结为个人努力忽略了这些结构性的不平等。成功和失败往往是由多种因素共同作用的结果，而就我自身的体会来看，选择和运气显然是远大于个人努力，而并非句子里这样轻飘飘的就能带过的。\n什么是有用的 在高一的时候，语文课讲到荆轲刺秦王的部分，在讨论课后题的环节，我曾经提出的观点是“荆轲不考虑失败的后果，因此我认为他是莽夫”，但其实这样的观点以片面成败的角度夸大了功利的意义。这个话题可以延展到究竟什么算是成功，什么算是有用？我个人认为，这才是在所谓的“追求成功”之前，真正需要想清楚的问题。\n在过去的一年，经常有学弟跑来问我到底怎么学比较好，学什么才比较“有用”，在C++群里也经常有大一的同学问学什么比较好。\n在我大学的前两年，我很多时候都在想学什么有用，参加什么比赛有用，跟什么样的人打交道有用。这样的思想成了我自己的禁锢，也带来了大量的焦虑。但后来发现，我一开始凭兴趣做的那些以为无用小项目和小玩具反而在秋招和去学校面试时成为了简历上的亮点，成为了有用的东西。“灵魂的渴望是命运的先知”，这是我写在tss上的标语，也是我真正想要给大家的建议。与其为思考“有用”而焦虑，不如去做自己真正喜欢的事情。我觉得，当真正思考清楚了自己对哪个领域有着热爱，有着渴望，有着能为之不懈追求的自驱力，答案也就自然地浮出水面了。\n堂吉诃德拥有不可动摇的信仰，他坚决相信，超越了他自身的存在，还有永恒的，普遍的，不变的东西；这些东西须一片至诚地努力争取，方才能够获得。在他，人生只是手段，不是目的。\n尾声 我有一部从高中开始就印象很深的电影《无问西东》，有些人认为它是有些用力过猛的浓鸡汤。但对我来说，其中充斥的理想主义却实实在在打动着我。在不同的年代，这些年轻人都不约而同地找到了真实的自我。所以他们看上去能够那么平和，从容且坚定。\n初中周末补课的时候，回家总是一个人坐公交车，刚上车的时候人挤人，到了最后天色渐渐变暗，车厢里也只有我和斑驳的影子了。想着怎么也提升不上去的数学，心中总是有股烦躁。\n现在从软件所的门口出来等公交的时候，望着仍没化完的积雪和来去的车辆，却没有了对未来的焦虑，我知道，我今天的事情已经做完了，当下我唯一需要关心的只有今天的晚饭。\n希望我永远不要停止对生命意义和对真实自我的探索。\n好像不知不觉流水账记得太多了，最后就祝大家新的一年开开心心，万事顺利吧。\n","date":"2023-12-30T10:39:43Z","image":"https://inariindream.cn/blog/2023/12/30/2023%E5%B9%B4%E7%BB%88%E6%80%BB%E7%BB%93/222_hu62a5db6222d819209500cfcbb426ec66_2041385_120x120_fill_box_smart1_3.png","permalink":"https://inariindream.cn/blog/2023/12/30/2023%E5%B9%B4%E7%BB%88%E6%80%BB%E7%BB%93/","title":"2023年终总结"},{"content":"安装时大体是参考这个网站和这个网站的教程进行安装的。但部分问题不管是在中文互联网还是英文互联网上都没有找到解决方案，所以记录一下。\n1、DVTK_WRAP_PYTHON=ON 部分教程在给安装代码时，在cmake的环节会将DVTK_WRAP_PYTHON设置为ON，但是我个人的WSL是没有Python需求也就没有进行过Python环境的配置，所以在cmake的时候，将DVTK_WRAP_PYTHON设置为OFF。\n2、无法找到Visualization 在安装完成后，我用demo在编译的时候，提示无法找到Visualization，如下图所示：\nvisualization库是需要安装vtk的，很多教程基本忽略了这一点，只会告诉你需要安装vtk以及怎么装。\n在正确编译并安装正确版本的vtk之后，重新编译demo文件，发现还是无法找到Visualization，于是回去看cmake的输出，发现如下图所示：\n发现了大大的visualization: Disabled manually\n网上找了下解决方案，然后在某喜爱四迪恩论坛发现了如下的言论：\n(`ゥ´ )哥你要不再想想为什么要用Cmake GUI来执行Cmake呢\n总之，解决方案就是在Cmake的选项中将BUILD_visualization设置为ON，然后重新编译即可。\n这一点不知道为什么在pcl的Github Issue栏也没看到有人提，难道大家的default都是ON吗？\n3. 编译时报错undefined reference to vtkDebugLeaksManager::vtkDebugLeaksManager() 鉴定为没好好看教程导致的，cmakelist.txt中没有添加find_package(VTK REQUIRED)，添加后重新编译即可。\n附上我的cmakelist.txt文件：\ncmake_minimum_required(VERSION 3.23) project(Graduate) set(CMAKE_CXX_STANDARD 17) add_executable(Graduate main.cpp) find_package(PCL 1.9 REQUIRED) include_directories(\u0026#34;/usr/include/eigen3\u0026#34;) include_directories(\u0026#34;/usr/local/include/vtk-8.2\u0026#34;) include_directories(${PCL_INCLUDE_DIRS}) link_directories(${PCL_LIBRARY_DIRS}) add_definitions(${PCL_DEFINITIONS}) target_link_libraries(Graduate ${PCL_LIBRARIES}) 4. error while loading shared libraries: libvtkRenderingCore-8.2.so.1 参考这篇\n不知道这个vtk的库为什么没直接装到/usr/local/lib/里面，而是装到了/usr/local/lib/x86_64-linux-gnu 里面。\n解决方法\ncat /etc/ld.so.conf sudo sh -c \u0026#34;echo \u0026#39;/usr/local/lib/x86_64-linux-gnu\u0026#39; \u0026gt;\u0026gt; /etc/ld.so.conf\u0026#34; sudo sh -c \u0026#34;ldconfig\u0026#34; 5. [xcb] Unknown sequence number while processing queue 编译通过了，但是运行demo的时候，出现了如下的错误：\n[xcb] Unknown sequence number while processing queue\r[xcb] Most likely this is a multi-threaded client and XInitThreads has not been called\r[xcb] Aborting, sorry about that. Graduate: ../../src/xcb_io.c:260: poll_for_event: Assertion `!xcb_xlib_threads_sequence_lost\u0026#39; failed.**** 解决方法\n在开头加上这句\n#include \u0026lt;X11/Xlib.h\u0026gt; //避免和Eigen冲突 #ifdef Success #undef Success #endif 在main函数中加上这句\nXInitThreads(); ","date":"2023-11-10T10:58:20Z","image":"https://inariindream.cn/blog/2023/11/10/%E5%AE%89%E8%A3%85pcl%E6%97%B6%E5%80%99%E8%B8%A9%E8%BF%87%E7%9A%84%E4%B8%80%E4%BA%9B%E5%B0%8F%E5%9D%91/111_hu08c805cb1c333c67ef57d575cee23150_76183_120x120_fill_box_smart1_3.png","permalink":"https://inariindream.cn/blog/2023/11/10/%E5%AE%89%E8%A3%85pcl%E6%97%B6%E5%80%99%E8%B8%A9%E8%BF%87%E7%9A%84%E4%B8%80%E4%BA%9B%E5%B0%8F%E5%9D%91/","title":"安装PCL时候踩过的一些小坑"},{"content":"前言 对我而言，文字是一种将自己内心情绪和感受以具象化的方式表达出来的工具，因此每当遇到生活中一个个的“节点”的时候，我都会想要用文字来记录下来。断断续续坚持了3年的保研之路应该是一件值得记录的事情。\n这一次我没有选择像2年前考完插班生那会发朋友圈，而是选择在个人的博客记录下来，除了不想有炫耀之嫌，更是因为不想对考研的朋友造成影响，十月是一个放弃的高峰期。如果这篇博客能有幸被某个熟人看见，应该也是跨年时我发完年终总结，贴上我博客链接之后的事了\n流水账历程 大一 在大一的时候我应该是有强烈的保研梦的，因为我自认为考砸了30-40分才会来这个学校，而就那时的我接触到的信息，我所认知到的能改变现状的方法，一个是“插班生”，一个是保研 （在这么弱的学校不当第一拿保研资格还有天理吗？）\n而后来的结果也很众所周知了，转专业以0.002的绩点之差无缘计算机，插班生以数学的六分之差宣告我267天备考之旅的结束。\n唯一的收获，可能就只有因为备考带来的高数上下的满绩了吧。\n大二 大二其实没有特别关注过保研的事情，因为觉得自己分流后是专业第二， 稳一稳怎么都能有保研名额的，转而投身算法竞赛，沉浸于ACM的世界。\n不过在十月份的时候，在校XCPC群见识到了大佬的存在，应该是把我从“做题家”拉出来的第一个契机。\n大三 在大三那年，学校的保研政策迎来了重大的变化，由以前的两条赛道（纯绩点，纯科创）合并为了一条路，绩点占比70%，科创成果20%，综测10%。这一变化对于我来说，是一个很大的利好。我并不喜欢自己所在的专业，因此一直在为计算机的比赛做训练，而同专业绩点在前列的其他人是几乎没有拿得出手的比赛的。\n每10分科创分可以约等于0.115的绩点，A类国一是100分，国二是80分，20分就是0.23了，因此，在去年的这个时候，我其实已经准备开香槟了（？ 因为我不认为我们专业绩点前列的人在零基础的情况下能在一年的时间内速成一个国一，并且团队赛还涉及到组内分数分配的问题（后来才知道是可以不按照文件的分配方式分配的），我认为他们不可能比得过我的既是个人赛又是稳拿国一的蓝桥杯的。\n也就是说，我保不上研=专业里同时有两个绩点比我高同时还都能拿国一的人，在那时我觉得这是不可能的事（后来被很很打脸了）\n但，也就是在这一年，我第一次对是否保研，产生了强烈的动摇。\n因为ACM的关系，我认识到了很多其他学校优秀的人，也有很多行业内的大佬级别的人物，通过他们的聊天我得知了22年秋招的现状 （寒冬），击碎了我对计算机行业现状的幻想和对高学历的滤镜。\n我开始犹豫，我是否真的需要这一个研究生学历。\n同时，计算机与自动化双修的学法也渐渐地力不从心起来，我的绩点被后面的人赶上而我却无能为力，因为我实在无法将分配在计算机上面精力割舍到我本来的专业上面。我只能做好另一手准备：秋招。\n很多人都来问过我为什么不去选择考研，其实表层原因很简单：大一我已经备考过一年的插班生了，我不想大三再做一年题，这样我的大学时光将会有一半都是在做题中度过。\n深层原因，除了上面的那张图，还有就是客观来讲\n考研是存在风险的，一个是能不能考上的风险，另一个考什么水平的风险。同时外部环境：现在学历歧视越来越严重，我现在被歧视双非本科，三年后很有可能歧视本科是双非； 另一方面经济形势，三年后的就业市场状态是完全未知的，2020年读研究生的那一批人几乎不会有人能料想到2022年秋招的惨状。 也就是说考研要首先保证能考上（考不上只能零基础春招或二战），其次要保证考上的学校title有用（没用等于晚出生三年罢了），最后还需要保证三年的提升能跟得上互联网行业紧缩的速度。量化一点来说就是需要保证考研上岸的收益能够抵消（考不上+行业紧缩）的debuff，而根据我们学校每年的上岸率和我观察到的行业紧缩的速度来看，这个期望显然不是正值。\n大三下学期的因病住院和各种各样的意外情况使我当学期的绩点达到了六学期最低的水平，同时我们专业出现了两个国一的奖项，我无法保研的事情几乎已经是确定的事了。我于是开始安心准备秋招。\n然而保研名额突增，把我和我们专业后面两个都给囊括进去了。一番纠结和询问了很多大佬的意见之后，我最终还是选择了保研。\n保研和秋招的选择 回顾一下整个经历，在保研这条路上，我的心路历程大概如下：必须得保 → 好像稳了 → 开香槟了 → 唉 秋招吧 → 居然能保。\n至于为什么最终在就业和保研里选择了后者，一是从上文的计量方式来说，保研显然没有（考不上+title弱）的debuff，这样一来期望就仍有变为正值的可能（取决于行业紧缩速度）。二是似乎是因为在别人开导下，我发现我喜欢的是“计算机”本身，而不是计算机所带来的附加利益（高薪，大厂等），计算机之所以被称为“宇宙机”，是因为前几年互联网红利期带来的高薪且低门槛的岗位。由此造成了 “天下熙熙，皆为利来；天下攘攘，皆为利往” 的转码热潮，我扪心自问，我是其中一员吗？得到的答案是否定的。那么读研就刚好能给我三年的时间，使我能够全身心投入我真正喜欢的领域里。\n当然这只是一个角度，如果我保研失败，我大概就会大谈互联网行业现状，谈行业紧缩，谈研究生三年读出来可能被本科就业的同学面试等等。这样看来，人是很难不被主观情绪影响的。对我而言，两种人生都很难具体地计量孰优孰劣，这种问题大多都是零和博弈，选择了其中一种，意味着另一种未选择的人生从此只能出现在理想中了。我所能做的，就是尽量不让自己去美化那条未选择的道路。\n写在最后 我的整个大学求学之路曲折而漫长，其中的酸甜苦辣无法以我浅显的文字全部抒发出来，而双修计算机和本专业的个中滋味则更是只有我自己能体会。在年初住院和因为一些偶然造成的绩点下滑时，我似乎的确感受到了命运的存在，在比赛中失误和知道本专业有两个人国一的时候更是如此。那时我就在想，既然运气都这样了，那似乎我也只能坦然接受我无法回避的命运了。\n我卷吗？我三年中应该从来没有十分认真的学过课内课程（实在提不起兴趣），现有的绩点全是靠期末前一周的冲刺得来的。我在KTV通宵过数次，上课几乎一直在玩手机，三年内打了2000h的游戏，有时甚至在考前三天仍在不慌不忙地玩塞尔达。\n我躺吗？三年里我也没有休息过一个完整的周末，没有体验过任何一个完整的假期，因为在没有课内压力的时候对我而言是仅有的机会来充实自己的计算机知识和刷算法题，好使自己能赶上计算机科班的人的理论知识，好使自己的竞赛水平再提升一点点。\n而让我这样不上不下的人最终能跨保计算机成功，也许也是一种命运的捉弄吧。\n记得高中的时候看过一句鸡汤\n命是弱者借口，运乃强者谦词\n当时的我，并没有觉得这句话有什么不对，相反将其视作勉励自己的支柱之一，努力使自己不成为用“命”当借口的弱者。\n但实际上不是的，这句话忽略了客观上不平等对人们命运的影响。社会背景、经济条件、种族、性别等因素都会对个人的机会和结果产生重大影响。因此，将一切归结为个人努力忽略了这些结构性的不平等。成功和失败往往是由多种因素共同作用的结果，而就我自身的体会来看，选择和运气显然是远大于个人努力，而并非句子里这样轻飘飘的就能带过的。因此，我不敢有半分自傲，因为我知道我能保上的因素中，选择和运气占据了绝大部分。\n我似乎终于获得了功利意义，或者说成功学意义上的成功，然而从我自己或真正了解我情况的人来看，我其实是在秋招碰壁的情况下“被迫”保研的，这样匆忙的选择最终会在三年后，当我结束求学生涯真正走向社会的时候，导向什么样结局呢。\n我是那中了举人的范进，你看我应有几分的欢欣\n我是那疯了几分的范进，我的人生有几分的转机\n","date":"2023-10-04T11:32:49Z","image":"https://inariindream.cn/blog/2023/10/04/%E4%BD%A0%E7%9C%8B%E6%88%91%E5%BA%94%E6%9C%89%E5%87%A0%E5%88%86%E7%9A%84%E6%AC%A2%E6%AC%A3/111_hu900a5243bec3f4c04000db7d273233d2_557386_120x120_fill_box_smart1_3.png","permalink":"https://inariindream.cn/blog/2023/10/04/%E4%BD%A0%E7%9C%8B%E6%88%91%E5%BA%94%E6%9C%89%E5%87%A0%E5%88%86%E7%9A%84%E6%AC%A2%E6%AC%A3/","title":"你看我应有几分的欢欣"},{"content":"前言 这是一门由MIT的Robert Morris主讲的分布式系统课程，课程主页链接，课程视频链接\n翻译版\n课程内容包括Golang的学习、分布式系统研究动机、一致性协议算法、著名分布式系统软件论文讲解和一致性算法 （Raft算法）的实现机制及实验。\n是一门不可多得的实践性质比较强的课程。\n本文主要记录自己做lab时候的一些心得体会，以及对课程的一些理解。\nLab1：MapReduce 论文：MapReduce: Simplified Data Processing on Large Clusters\nLab链接：Lab1\n设计思路 MapReduce是一个分布式计算框架，它的设计思路是将计算任务分为两个阶段：Map阶段和Reduce阶段。\n这是MapReduce的一个简单的示意图：\n这是论文中讲解MapReduce的流程图，基本上解释清楚了。\n输入数据以文件形式进入系统。一些进程运行map任务，拆分了原任务，产生了一些中间体，这些中间体可能以键值对形式存在。一些进程运行了reduce任务，利用中间体产生最终输出。master进程用于分配任务，调整各个worker进程。\n输入数据能够产生中间体，这说明原任务是可拆的，也就才有了写成分布式的可能性。若原问题不是可拆的，MapReduce也就无从谈起。\n中间体应均匀地分配给各个reduce任务，每个reduce任务整合这些中间体，令中间体个数减少，直至无法再减少，从中整合出最终结果。\n输入数据以什么形式进入系统，原任务应如何拆分，中间体如何保存和传输，master和worker之间如何通信和调度，中间体如何转化为最终输出。这些都是设计的考量，没有一定之规。\nLab要求我们做一个对txt文件里的wordcount，那么输入数据就是txt文件，原任务就是对txt文件里的单词进行统计，中间体就是单词和对应的出现次数，最终输出就是单词和对应的出现次数。\n示意图如下：\n实现细节 queue.go 首先定义一堆结构体（其实也不是首先，在编写过程中会不断地修改和更新结构体，不过在实现一个功能之前必须理清对应的数据结构）：\n// queue.go type listNode struct { data interface{} // data can be any type next *listNode prev *listNode } type LinkedList struct { head listNode count int } type BlockQueue struct { list *LinkedList cond *sync.Cond } 由于篇幅限制这里暂时省略了对应的方法，不过重点也不是方法就是了\n第一个结构体是链表的节点，第二个结构体是链表，第三个结构体是阻塞队列，阻塞队列是用链表实现的，链表的每个节点都是一个interface{}类型的数据，这样就可以存储任意类型的数据了。\n同时阻塞队列还有一个条件变量，用于实现阻塞队列的阻塞功能。\nmapset.go type MapSet struct { mapbool map[interface{}]bool count int } 这个结构体的作用是用于存储键值对，键值对的键是任意类型的，值是bool类型的，这样就可以实现set的功能了。\nworker.go 这部分就是重点了，我们这里先不直接抛出代码，先思考一下worker的工作流程。\nworker的工作流程如下：\n从master获取任务\n执行任务\n将任务执行结果发送给master\n重复1-3\n如果有空闲的worker，master会将任务分配给空闲的worker（才能体现多线程和分布式的优点）这一步暂时取名为Join吧\n在获取任务之前，首先应该进行一些初始化，通过下面两个函数，worker能够确定自己在map阶段和reduce阶段的任务是什么，以及自己的id是多少。\nfunc ihash(key string) int { h := fnv.New32a() h.Write([]byte(key)) return int(h.Sum32() \u0026amp; 0x7fffffff) } func keyReduceIndex(key string, nReduce int) int { // use ihash(key) % NReduce to choose the reduce return ihash(key) % nReduce } 然后我们创造一个worker对象，我们接下来的操作都是对这个对象进行操作。\ntype Aworker struct { // a struct for worker mapf func(string, string) []KeyValue reducef func(string, []string) string // true: Map // false: Reduce MapOrReduce bool //exit if true DoneFlag bool WorkerId int } 初始化完成后，worker开始向coordinator发送请求，获取任务。\nfunc (worker *Aworker) askMapTask() *MapTaskReply { /* ask for a map task then return the reply */ args := MapTaskArgs{ WorkerId: worker.WorkerId, } reply := MapTaskReply{} worker.logPrintf(\u0026#34;Asking for a map task...\\n\u0026#34;) call(\u0026#34;Coordinator.GiveMapTask\u0026#34;, \u0026amp;args, \u0026amp;reply) // obtain a worker id worker.WorkerId = reply.WorkerId worker.logPrintf(\u0026#34;Got a map task, filename: %s, fileId: %v\u0026#34;, reply.FileName, reply.FileId) if reply.FileId == -1 { // refused to give a task if reply.DoneFlag { worker.logPrintf(\u0026#34;No more map tasks, switching to reduce tasks...\\n\u0026#34;) return nil } else { worker.logPrintf(\u0026#34;No map tasks available, waiting...\\n\u0026#34;) return \u0026amp;reply } } worker.logPrintf(\u0026#34;got a map task, filename: %s, fileId: %v\\n\u0026#34;, reply.FileName, reply.FileId) return \u0026amp;reply } 这个函数比较简单，就是向coordinator发送请求，获取任务，如果没有任务就等待，如果有任务就返回任务。没有什么特别需要注意的。\n如果coordinator发现所有任务都在进行但是还有空闲的worker，那么就会将任务分配给空闲的worker，这个过程就是Join过程。\nfunc (worker *Aworker) joinMapTask(fileId int) { // notify coordinator that map task is done, the worker can join another map task args := MapTaskJoinArgs{ FileId: fileId, WorkerId: worker.WorkerId, } reply := MapTaskJoinReply{} worker.logPrintf(\u0026#34;Joining map task...\\n\u0026#34;) call(\u0026#34;Coordinator.JoinMapTask\u0026#34;, \u0026amp;args, \u0026amp;reply) if reply.Accepted { worker.logPrintf(\u0026#34;\\033[33mAccepted\\033[0m to join map task!\\n\u0026#34;) } else { worker.logPrintf(\u0026#34;Failed to join map task!\\n\u0026#34;) } } 可以看到，上面几个函数都是通过rpc调用coordinator的函数来实现的。\n","date":"2023-08-09T11:06:32Z","image":"https://inariindream.cn/blog/2023/08/09/mit-6.5840-%E5%88%86%E5%B8%83%E5%BC%8F%E7%B3%BB%E7%BB%9F/111_hude0c8f8df6eb103188ea1c1b8dd98525_334130_120x120_fill_box_smart1_3.png","permalink":"https://inariindream.cn/blog/2023/08/09/mit-6.5840-%E5%88%86%E5%B8%83%E5%BC%8F%E7%B3%BB%E7%BB%9F/","title":"MIT 6.5840 分布式系统"},{"content":"转移部署教程 1.安装Anaconda 安装包 由于是aarch64架构，所以官方没有提供编译好的conda，要从其他渠道安装。\n移动U盘中的Archiconda3-0.2.3-Linux-aarch64.sh安装包到当前目录（如果不清楚当前目录在哪，可输入pwd查看）\n安装 输入\n./Archiconda3-0.2.3-Linux-aarch64.sh 即可执行安装命令\n路径配置 conda应该会被安装至/opt/conda下面，将其全部文件迁移到/home/nvidia/.conda下\n若当前目录在home，使用下列命令来新建文件夹并修改权限：\nsudo mkdir nvidia cd nvidia sudo mkdir .conda cd .. chmod -R 777 nvidia 然后分别打开/home/jetson(这里是用户名，自行修改)/.bashrc和/etc/profile，如果没有权限就使用vim进行编辑\nsudo vim xxx(文件路径) 打开编辑，按a进入输入状态，按:wq保存并退出\n在文件里加入如下几行\n或选择gedit也可\nsudo gedit xxx(文件路径) 注意检查路径是否和当前的conda位置符合\n注意不要加在文件末尾，可以找文件中有相似格式的位置添加。\n然后执行\nsource /etc/profile 来应用更改\n测试 输入conda -V查看是否配置成功\n2.配置环境 移动文件 将U盘里的文件先转移到任意位置\n将U盘里的envs文件夹下的py38文件夹移动到/home/nvidia/.conda/envs下\n显式声明环境变量 打开前文提到的.bashrc\n在刚刚添加的语句后，新添一行\nexport LD_PRELOAD=$LD_PRELOAD:/home/nvidia/conda/envs/py38/lib/python3.8/site-packages/scikit_learn.libs/libgomp-d22c30c5.so.1.0.0 3.运行程序 在控制台里面使用cd命令转移到U盘里deploy所转移到的的文件夹并cd deploy（即当前控制台的最右边显示是\u0026rsquo;deploy\u0026rsquo;）\n或直接打开deploy文件夹再右键空白处点击open terminal\n在执行过\nconda activate py38 的情况下，直接输入\npython new0612.py 即可运行程序\n4. 设置开机自启动 在终端输入\ngnome-session-properties 或直接在搜索栏输入start即可打开Startup Applications\n然后点击Add即可添加开机时自动运行的指令了\nName随便填，Comment可不填，在Command栏填写gnome-terminal\n然后打开前文提到的.bashrc文件，在文件的末尾输入以下语句：\nconda activate py38 sleep 2 cd deploy python new0612.py 5.备份与还原 tar命令 备份系统 我该如何备份我的Ubuntu系统呢？很简单，就像你备份或压缩其它东西一样，使用TAR。和Windows不同，Linux不会限制root访问任何东西，你可以把分区上的所有东西都扔到一个TAR文件里去！\n首先成为root用户：\nsudo su 然后，进入根目录后，使用下面的命令备份你的系统：\ntar cvpzf backup.tgz --exclude=/proc --exclude=/lost+found --exclude=/backup.tgz --exclude=/mnt --exclude=/sys / 让我们来简单看一下这个命令：\ntar当然就是我们备份系统所使用的程序了。\ncvpfz是tar的选项，意思是“创建档案文件”、“保持权限”(保留所有东西原来的权限)、“使用gzip来减小文件尺寸”。\nbackup.gz是我们将要得到的档案文件的文件名。\n/是我们要备份的目录，在这里是整个文件系统。\n在 档案文件名“backup.gz”和要备份的目录名“/”之间给出了备份时必须排除在外的目录。有些目录是无用的，例如“/proc”、“/lost+ found”、“/sys”。当然，“backup.gz”这个档案文件本身必须排除在外，否则你可能会得到一些超出常理的结果。如果不把“/mnt”排 除在外，那么挂载在“/mnt”上的其它分区也会被备份。另外需要确认一下“/media”上没有挂载任何东西(例如光盘、移动硬盘)，如果有挂载东西， 必须把“/media”也排除在外。\n你还可以用Bzip2来压缩文件，Bzip2比gzip的压缩率高，但是速度慢一些。如果压缩率对你来说很重要，那么你应该使用Bzip2，用“j”代替命令中的“z”，并且给档案文件一个正确的扩展名“bz2”。完整的命令如下：\ntar cvpjf backup.tar.bz2 --exclude=/proc --exclude=/lost+found --exclude=/backup.tar.bz2 --exclude=/mnt --exclude=/sys / 恢复系统 在进行恢复系统的操作时一定要小心！如果你不清楚自己在做什么，那么你有可能把重要的数据弄丢，请务必小心！\n接着上面的例子。切换到root用户，并把文件“backup.tgz”拷贝到分区的根目录下。\n在 Linux中有一件很美妙的事情，就是你可以在一个运行的系统中恢复系统，而不需要用boot-cd来专门引导。当然，如果你的系统已经挂掉不能启动了， 你可以用Live CD来启动，效果是一样的。\n使用下面的命令来恢复系统：\ntar xvpfz backup.tgz -C / 如果你的档案文件是使用Bzip2压缩的，应该用：\ntar xvpfj backup.tar.bz2 -C / 注意：上面的命令会用档案文件中的文件覆盖分区上的所有文件。\n执行恢复命令之前请再确认一下你所键入的命令是不是你想要的，执行恢复命令可能需要一段不短的时间。\n恢复命令结束时，你的工作还没完成，别忘了重新创建那些在备份时被排除在外的目录：\nmkdir proc\rmkdir lost+found\rmkdir mnt\rmkdir sys 等等\n当你重启电脑，你会发现一切东西恢复到你创建备份时的样子了\ndd命令 磁盘克隆 也就是把整个硬盘复制一份。当然你首先需要在计算机上在接上一块新硬盘，并让系统识别。例如这块硬盘可能被识别为/dev/sdb,原有硬盘叫/dev/sda. 然后你可以在linux命令行上简单地执行： dd if=/dev/sda of=/dev/sdb 对就这么简单，此命令完成后，你的第二块硬盘上将有一个和第一块硬盘一模一样的副本，也是可以启动的。因为dd操作就是简单的按字节复制，什么分区表啊，MBR啊统统照搬。 当然你也可以做一些微调，来定制一下克隆操作。例如你可能希望把硬盘上的内容全部备份到一个磁盘文件中，而不是另一块新硬盘，你可以 dd if=/dev/sda of=~/disk1.img 之后，disk1.img就是备份好的磁盘映像文件，你可以复制或转移到其他介质也可以压缩一下： gzip disk1.img #generates disk1.img.gz 或者在创建磁盘映像文件的同时就执行压缩： dd if=/dev/sda | gzip \u0026gt; disk.img.gz 当然，你也可以使用bzip2来压缩，它的压缩率更高，但是速度慢一些： dd if=/dev/sda | bzip2 \u0026gt; disk.img.bz2\n分区克隆 如果我们不想克隆整块磁盘，只想把某些存放数据的分区备份一下，你会需要克隆一个分区。正如预备知识所述，分区在linux下也是一个文件。例如 dd if=/dev/sda1 of=~/part1.img 将把第一块磁盘的第一个分区备份到名为part1.img的文件中。 也可以进行分区复制： dd if=/dev/hda1 of=/dev/hda3 将把分区一原样复制到分区3.\n从镜像文件恢复磁盘或分区 很简单，把上面命令中，of和if指向的文件名互换一下即可实现恢复。例如 dd if=disk1.img of=/dev/sda 把保存在disk1.img中的映像恢复到第一块磁盘 dd if=part1.img of=/dev/hda2 把保存在part1.img中的映像恢复到第一块硬盘的第二个分区\n最后，需要注意一点是，无论备份还是恢复，都需要保证 of 指向的文件或磁盘空间要大于 if 指向的内容，因为是按字节复制 如果没有足够的空间去存储内容，备份自然会失败。\n6.配置文件参数说明 配置文件说明：\n本程序部分参数使用配置文件进行配置，配置文件para.json位于deploy文件夹内，具体的参数定义如下：\n序号 参数名 含义说明 1 OPCAdd PLC的opc地址 2 CamAdd 摄像头连接地址 3 lifebeat_to_etrs PLC端心跳包node地址 4 lifebeat_from_etrs ETRS端心跳包node地址 5 tray_in_pos 空框到位node地址 6 tray_empty 框体是否空node地址 7 high_top 检测画幅高度上 8 high_bottom 检测画幅高度下 9 width_left 检测画幅宽度左 10 width_right 检测画幅宽度右 可能遇到的问题 Q：使用pip或者conda命令时出现bad interpreter: No such file or directory:的错误\nA: 打开python36和.conda目录下的bin文件夹，查看pip文件和conda文件的第一行#！后面的解释器路径配置是否正确\n（此处以python3.6示例，根据实际需求自行修改）\n若与当前目录不符，修改即可。若没权限(文件只读)则可使用sudo vim命令编辑文件\n","date":"2023-05-28T18:32:14Z","image":"https://inariindream.cn/blog/2023/05/28/nvidia-jetson-%E9%83%A8%E7%BD%B2%E6%95%99%E7%A8%8B/111_hu29002862d9d3540a5064363d00356b79_1405129_120x120_fill_box_smart1_3.png","permalink":"https://inariindream.cn/blog/2023/05/28/nvidia-jetson-%E9%83%A8%E7%BD%B2%E6%95%99%E7%A8%8B/","title":"Nvidia Jetson 部署教程"},{"content":"","date":"2023-05-11T23:13:56Z","image":"https://inariindream.cn/blog/2023/05/11/%E6%98%9F%E9%99%85%E7%89%9B%E4%BB%94%E7%A9%BF%E8%A1%8C%E5%9C%A8%E7%BE%A4%E6%98%9F%E9%97%B4%E7%9A%84%E6%B5%AA%E6%BC%AB%E8%AF%97%E7%AF%87/111_hu3c549426e06a2c58b1280b965fa3f792_798351_120x120_fill_box_smart1_3.png","permalink":"https://inariindream.cn/blog/2023/05/11/%E6%98%9F%E9%99%85%E7%89%9B%E4%BB%94%E7%A9%BF%E8%A1%8C%E5%9C%A8%E7%BE%A4%E6%98%9F%E9%97%B4%E7%9A%84%E6%B5%AA%E6%BC%AB%E8%AF%97%E7%AF%87/","title":"星际牛仔：穿行在群星间的浪漫诗篇"},{"content":"开新坑，先贴一下打的情况 第一场的时候还没报名，之后要找机会vp一场\n从后往前补\n2023牛客寒假算法基础集训营6 E 阿宁的生成树 题意 分析 实际上算是个脑筋急转弯，只要了解生成树的概念再想到一个小trick即可\n由于素数间的间距最大也就100左右，所以暴力枚举找素数是完全可行的来使$gcd(i, j) == 1$是完全可行的\n连线策略：\n代码 def solvee(): n, k = map(int, input().split()) ans = max(0, n - k - 1) for i in range(2, min(n, k + 1) + 1): temp = 1 \u0026lt;\u0026lt; 31 for j in range(k + 1 + i, n + 1): if math.gcd(i, j) == 1: temp = 1 break temp = min(math.gcd(i, j), temp) mi = min(temp, i) # print(mi) ans += mi print(ans) L 阿宁睡大觉 题意 思路 容斥原理 + 逆元求组合数取模 + dp\n半理解半抄代码补完的\u0026hellip;还是有点难理解，有时间一定要自己完整地写一遍\n代码 这份代码的组合数取模板子似乎有点慢，跑了1600ms\ndef solvel(): N = 2 * 10 ** 5 + 5 MOD = 10 ** 9 + 7 pow2 = [0] * (N + 1) b = [(0, 0) for _ in range(N)] fact = [0] * N infact = [0] * N fact[0] = 1 infact[0] = 1 for i in range(1, N): fact[i] = fact[i - 1] * i % MOD infact[i] = infact[i - 1] * pow(i, MOD - 2, MOD) % MOD def C(a, b, MOD): return fact[a] * infact[b] * infact[a - b] % MOD n, m = map(int, input().split()) a = [] for _ in range(m): x, y = map(int, input().split()) a.append((x, y)) pow2[0] = 1 for i in range(1, n + 1): pow2[i] = pow2[i - 1] * 2 % MOD # 没有噩梦格子的总方案数 ans = pow2[n - 1] for i in range(1, 1 \u0026lt;\u0026lt; m): # 状压枚举 t = 0 t += 1 # 先放入起点 b[t] = (1, 1) # 格子为奇数时ok=1，偶数为-1（容斥原理） ok = 1 for j in range(m): if i \u0026gt;\u0026gt; j \u0026amp; 1: t += 1 b[t] = a[j] ok *= -1 # 对x进行排序来一次判断是否会出现左下右上的情况 b[1:t + 1] = sorted(b[1:t + 1]) # 最后一个格子到终点的路径数 temp = pow2[n - 1 - (b[t][0] + b[t][1] - 2)] for j in range(2, t + 1): if b[j - 1][0] \u0026lt;= b[j][0] and b[j - 1][1] \u0026lt;= b[j][1]: x = b[j][0] - b[j - 1][0] + 1 y = b[j][1] - b[j - 1][1] + 1 # 乘法原理，将路径数乘起来 temp = temp * C(x + y - 2, x - 1, MOD) % MOD else: temp = 0 break ans = (ans + ok * temp) % MOD ans = (ans + MOD) % MOD print(ans) 这份比较快，只跑了400ms\ndef solvel(): N = 2 * 10 ** 5 + 5 MOD = 10 ** 9 + 7 inv = [0] * N; fac = inv.copy(); facinv = inv.copy(); pow2 = inv.copy() b = [(0, 0) for _ in range(N)] def C(n, m): return fac[n] * facinv[m] % MOD * facinv[n - m] % MOD n, m = map(int, input().split()) a = [] for _ in range(m): x, y = map(int, input().split()) a.append((x, y)) # 线性预处理组合数 inv[1] = fac[0] = fac[1] = facinv[0] = facinv[1] = 1 for i in range(2, N): inv[i] = (MOD - MOD // i) * inv[MOD % i] % MOD fac[i] = fac[i - 1] * i % MOD facinv[i] = facinv[i - 1] * inv[i] % MOD pow2[0] = 1 for i in range(1, n + 1): pow2[i] = pow2[i - 1] * 2 % MOD # 没有噩梦格子的总方案数 ans = pow2[n - 1] for i in range(1, 1 \u0026lt;\u0026lt; m): # 状压枚举 t = 0 t += 1 # 先放入起点 b[t] = (1, 1) # 格子为奇数时ok=1，偶数为-1（容斥原理） ok = 1 for j in range(m): if i \u0026gt;\u0026gt; j \u0026amp; 1: t += 1 b[t] = a[j] ok *= -1 # 对x进行排序来一次判断是否会出现左下右上的情况 b[1:t + 1] = sorted(b[1:t + 1]) # 最后一个格子到终点的路径数 temp = pow2[n - 1 - (b[t][0] + b[t][1] - 2)] for j in range(2, t + 1): if b[j - 1][0] \u0026lt;= b[j][0] and b[j - 1][1] \u0026lt;= b[j][1]: x = b[j][0] - b[j - 1][0] + 1 y = b[j][1] - b[j - 1][1] + 1 # 乘法原理，将路径数乘起来 temp = temp * C(x + y - 2, x - 1) % MOD else: temp = 0 break ans = (ans + ok * temp) % MOD ans = (ans + MOD) % MOD print(ans) 2023牛客寒假算法基础集训营5 C 小沙の不懂 题目描述 沙姐姐的题面太难顶了，用炸鸡块哥哥的话翻译下题意：\n$p$相当于是一个映射，将原来$a, b$中的数字映射成现在的输入，题目问你是否不管这个映射$p$怎么变，是否能确定原来$a, b$之间的关系，如果能就输出大小等于，不能则输出！\n思路 在打这场的时候就看群友说这题十分的阅读理解，~~gkjj差这题就ak。~~于是果断选择跳过去做其他题\n直接贴结论吧\n长度不一样的时候，如果要让长的不一定大于短的，只有一种可能。贪心地想，肯定是要将长的那个多长的一截给去掉，即变0，如果不能去掉则长的一定大于小的。\n一长一短的情况只有两种情况：长的大于小的或不能确定，不能确定的情况比较好找，有两种：\n剩下的$a, b$完全相同。此时由于前面截掉部分的不确定性，有大于和等于两种可能。\n从前往后找，若找到一个不同，如果不同且$b[i]$不等于之前截掉部分的数（即不能变0），说明长的失去了最后的一定大于短的机会，也是不确定。\n剩下的情况，长的一定总是大于短的\n代码 def solvec(): a, b = input().split() if a == b: print(\u0026#34;=\u0026#34;) return if len(a) == len(b): print(\u0026#34;!\u0026#34;) return res = \u0026#34;\u0026gt;\u0026#34; if len(a) \u0026lt; len(b): a, b = b, a res = \u0026#34;\u0026lt;\u0026#34; n = len(a) m = len(b) ok = a[0] for i in range(n - m): if a[i] != ok: print(res) return a = a[n - m:] if a == b: print(\u0026#34;!\u0026#34;) return for i in range(m): if a[i] != b[i]: if b[i] != ok: print(\u0026#34;!\u0026#34;) return break # 这个位置一定记得break，只比较一次 print(res) F 小沙的串串 题意 思路 这题赛时过的人很少，最后1h才逼近100，但群友说是典中典。看来确实做少了\n大体的思路就是用单调栈模拟，由于每次操作可以使得更大的数字往前移动，所以可以采用单调栈来维护一个单调递减的数字串。单调栈里面的一定是一个单调递减的字符串，并且栈底是操作后字符串的首位（能达到的最大值）\n关键点来了，如果对整个串维护完之后，如果存在多余的操作没有使用，则可以选择最后几个最小的数字将其放在后面，使得前面曾被移动的到后面的数字更加靠前。\n随后将所有被移动后的字符排序之后，接在最后面即可，因为我们的操作其实是不分先后顺序的，没有规定一定要挨着删。因此我们可以先将需要删除的最大的字符进行删除，使得最后他尽可能的靠前。来达到排序后的效果。\n代码 def solvef(): n, k = map(int, input().split()) s = input() ans = deque() res = \u0026#34;\u0026#34; for c in s: while k and len(ans) \u0026gt; 0 and ans[-1] \u0026lt; c: k -= 1 res += ans.pop() ans.append(c) while k and len(ans) \u0026gt; 0: k -= 1 res += ans.pop() res = sorted(res, reverse=True) temp = [c for c in ans] temp.extend(res) print(*temp, sep=\u0026#34;\u0026#34;) ","date":"2023-02-08T12:35:46Z","image":"https://inariindream.cn/blog/2023/02/08/2023%E7%89%9B%E5%AE%A2%E5%AF%92%E5%81%87%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95%E8%AE%AD%E7%BB%83%E8%90%A5/111_hu95afadd0eae8c023b895a8b793e5531d_225342_120x120_fill_q75_box_smart1.jpg","permalink":"https://inariindream.cn/blog/2023/02/08/2023%E7%89%9B%E5%AE%A2%E5%AF%92%E5%81%87%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95%E8%AE%AD%E7%BB%83%E8%90%A5/","title":"2023牛客寒假基础算法训练营"},{"content":"题单链接：https://atcoder.jp/contests/dp A 入门题，直接放代码了\ndef solve(): n = int(input()) a = [0] + list(map(int, input().split())) f = [0] * (n + 1) f[1] = 0 f[2] = abs(a[2] - a[1]) for i in range(3, n + 1): f[i] = min(f[i - 1] + abs(a[i] - a[i - 1]), f[i - 2] + abs(a[i] - a[i - 2])) print(f[n]) B A的加强版，多一个for\ndef solve(): n, k = map(int, input().split()) a = [0] + list(map(int, input().split())) f = [1 \u0026lt;\u0026lt; 60] * (n + 1) f[1] = 0 f[2] = abs(a[2] - a[1]) for i in range(3, n + 1): for l in range(1, k + 1): index = max(i - l, 1) f[i] = min(f[i], f[index] + abs(a[i] - a[index])) # for i in range(3, n + 1): # f[i] = min(f[i - 1] + abs(a[i] - a[i - 1]), f[i - 2] + abs(a[i] - a[i - 2])) print(f[n]) 初始化不能乱设114514 😥，原来的f = [114514111145141] * (n + 1)会T\nC 朴素转移\ndef solvec(): n = int(input()) f = [] for _ in range(n): a, b, c = map(int, input().split()) f.append([a, b, c]) for i in range(1, n): for j in range(3): f[i][j] += max(f[i - 1][(j + 2) % 3], f[i - 1][(j + 1) % 3]) print(max(f[n - 1])) D 01背包模板题 （妈的想起来去年这个时候自己也在听wls讲01背包\ndef solved(): n, m = map(int, input().split()) w = [] v = [] f = [0] * (m + 1) for i in range(n): x, y = map(int, input().split()) w.append(x) v.append(y) for i in range(n): for j in range(m, w[i] - 1, -1): f[j] = max(f[j], f[j - w[i]] + v[i]) print(f[m]) E 与上题相同，只不过$m$和$w_i$范围变到了$10^9$，就不能用相同的转移方程了 用$dp_i$表示价值到$i$所需的最小重量\ndef solvee(): n, m = map(int, input().split()) w = [] v = [] for _ in range(n): x, y = map(int, input().split()) w.append(x) v.append(y) tot = sum(v) # 这里的dp[i]表示到达价值为i所需的最小质量 dp = [1 \u0026lt;\u0026lt; 31] * (10 ** 5 + 5) dp[0] = 0 for i in range(n): for j in range(tot, v[i] - 1, -1): dp[j] = min(dp[j], dp[j - v[i]] + w[i]) for i in range(tot, 0, -1): if dp[i] \u0026lt;= m: print(i) return ","date":"2023-01-11T16:45:31Z","image":"https://inariindream.cn/blog/2023/01/11/atcoder-educational-dp-contest/111_hu603c74a482c754c2ce415412259cb3b0_670710_120x120_fill_q75_box_smart1.jpg","permalink":"https://inariindream.cn/blog/2023/01/11/atcoder-educational-dp-contest/","title":"Atcoder Educational DP Contest"},{"content":"记录我的DP训练\nD. Different Arrays 题意 给定一个长度为n的数组，必须进行$n ― 2$次操作，对$[2, n 一1]$范围内的数按顺序进行一次操作，一次操作为让左边和右边的两个数一个加上$a_i$一个减去$a_i$; ($a_i$指的是当前值)，求操作后可能获得的数组的数量。\n$$0≤a_i≤300, 1≤n ≤300$$\n思路 看典哥题解写的\u0026hellip;一开始还以为py用二维会炸（事实上也在炸的边缘），后来发现是自己太相信py的高精度了，被狠狠教育了\n如果把结果放在最后才%MOD，可能会TLE或MLE\ndp，看值域考虑dp，所有数最终能够变成的值域是$[-300 * 300, 300 * 300]$\n二维版本\n$f[i][j]$ 表示前$i$个数中，最终凑成的值$j$的方案数\n每次先循环位置，再枚举当前位置最终变成的数\n转移方程：\n$$f[i + 1][a[i + 1] + j] += f[i][j]$$\n$$f[i + 1][a[i + 1] - j] += f[i][j]$$\n坑点：如果j = 0的话就只需要转移一次，要特判一下\n一维版本\n其实思路一样，不过是类似滚动数组，每遍历到一个$a_i$的新位置，用一个新数组存，然后覆盖老数组，就可以去掉$i$的维度。这样写居然不会MLE我也觉得很神奇\n代码 def solve(): N = 310 n = int(input()) a = list(map(int, input().split())) # f[i][j] = 前i个数中，最终变成的数为j 的方案数 f = [[0] * 90250 * 2 for _ in range(N)] p = 90000 # 初始化，最开始只有位置2，值域也只能到a[2] f[1][a[1] + p] = 1 for i in range(1, n - 1): # 对于每个a_i，试探所有可能值（若在a_i前面的值使f[i][j]不为空，说明前i个数能够到达j这个值） for j in range(-p + 300, p - 300 + 1): if f[i][j + p] != 0 and j != 0: f[i + 1][a[i + 1] - j + p] += f[i][j + p] f[i + 1][a[i + 1] - j + p] %= 998244353 f[i + 1][a[i + 1] + j + p] += f[i][j + p] f[i + 1][a[i + 1] + j + p] %= 998244353 elif f[i][j + p] != 0: f[i + 1][a[i + 1] + p] += f[i][j + p] f[i + 1][a[i + 1] + p] %= 998244353 ans = 0 for i in range(-p, p): ans += f[n - 1][i + p] ans %= 998244353 print(ans) # 一维版本 def solve2(): n = int(input()) a = list(map(int, input().split())) MOD = 998244353 p = 90005 ans = [0] * (2 * p + 500) ans[a[1] + p] = 1 for i in range(n - 2): dp = [0] * (2 * p + 500) for j in range(-p, p + 1): if ans[j + p] and j != 0: dp[a[i + 2] + j + p] += ans[j + p] dp[a[i + 2] + j + p] %= MOD dp[a[i + 2] - j + p] += ans[j + p] dp[a[i + 2] - j + p] %= MOD elif ans[j + p]: dp[a[i + 2] + p] += ans[j + p] dp[a[i + 2] + p] %= MOD ans = dp print(sum(ans) % MOD) 这题的教训就是一定记得计算需要的数组长度（济南的签到好像也是这样栽了半天），和ans不要留到最后才模\nC. Count Binary Strings 题意 给定一个01串，给定每一个区间范围内的限制。其中 g[i][j]表示对于区间[i, j]的限制。若g[i][j] = 1，说明这个区间内只能出现一种数;若g[i][j] = 2，说明这个区间内必须同时出现两种数;若g[i][j] =0，说明这个区间没有限制。求合法01串的数量。\n思路 DP，观察发现若为合法01串，对于指定的右端点r，一定有:$a[1][r], a[2][r]\u0026hellip;a[r][r]$呈现$2222\u0026hellip;111..1$的特征。因为从后往前考虑，如果r - 1的位置与r的位置相同，则$a[r - 1][r] = 1$，否则为2。而一旦有某个位置为2了，这个位置往前的所有位置都会是2。\n令$dp[i][j]$表示在前i个位置中，分界点为$j$的方案数（即，$j$以前为$2$，$j$及以后为$1$），答案为在位置$n$时的所有分界线位置方案之和，即 $$\\sum_{i = 1}^{n}dp[n][i]$$\n转移：从$dp[i][j]$开始，如果向后摆放的是和上一位相同的数，则j不变，转移到$dp[i + 1][j]$。若向后摆放的是和上一位不同的数，则$j$直接跳到$i + 1$，转移到了$dp[i + 1][i + 1]$。转移方程：\n$dp[i + 1][j] += dp[i][j]$\n$dp[i + 1][i + 1] += dp[i][j]$\n注意这题还需要一个判断合法条件的操作，因为如果在$[1，j - 1]$区间有不该出现的$1$或在$[j, n]$区间有不该出现的$2$，则说明$j$在这个位置分割的方案是不可达到的，需要将该位置的$dp[i][j]$置$0$。\n代码 def solve(): n = int(input()) a = [[0]] dp = [[0] * (n + 2) for _ in range(n + 2)] MOD = 998244353 for i in range(1, n + 1): a.append([0] * i + list(map(int, input().split()))) dp[1][1] = 2 # 表示第一个位置可以为1可以为0 # l是分界点的坐标，在遍历前r个时，枚举分界点坐标 for r in range(1, n + 1): for l in range(1, r + 1): flag = 0 for k in range(1, l): if a[k][r] == 1: flag = 1 for k in range(l, r + 1): # print(k, r) if a[k][r] == 2: flag = 1 if flag: dp[r][l] = 0 # 说明此处不合法,不满足22221111... # print(r + 1, l) dp[r + 1][l] = (dp[r + 1][l] + dp[r][l]) % MOD dp[r + 1][r + 1] = (dp[r + 1][r + 1] + dp[r][l]) % MOD ans = 0 for i in range(1, n + 1): ans = (ans + dp[n][i]) % MOD print(ans) 石子合并 题意 设有 $N(N \\le 300)$ 堆石子排成一排，其编号为 $1,2,3,\\cdots,N$。每堆石子有一定的质量 $m_i(m_i \\le 1000)$。现在要将这 $N$ 堆石子合并成为一堆。每次只能合并相邻的两堆，合并的代价为这两堆石子的质量之和，合并后与这两堆石子相邻的石子将和新堆相邻。合并时由于选择的顺序不同，合并的总代价也不相同。试找出一种合理的方法，使总的代价最小，并输出最小代价。\n思路 区间DP，学了一手区间DP的常见套路。详见代码\n代码 def solve(): n = int(input()) a = [0] + list(map(int, input().split())) s = [0] * (n + 1) dp = [[0] * 305 for _ in range(305)] for i in range(n): s[i + 1] = s[i] + a[i + 1] # 区间DP模板 for l in range(2, n + 1): # 先枚举区间长度[2, n] for i in range(1, n): # 再枚举左端点 if i + l - 1 \u0026gt; n: break j = i + l - 1 dp[i][j] = 11451411 for k in range(i, j): # 最后在所枚举的区间中枚举分割点并更新答案 dp[i][j] = min(dp[i][j], dp[i][k] + dp[k + 1][j] + s[j] - s[i - 1]) print(dp[1][n]) C. Unstable String 题意 给一个字符串，其含有$0,1,?$. 其中，$?$可以看成$1$，也可以看成$0$。如果一个字符串可以是0和1交替出现的，就称这个字符串是$beautiful$。问现在这个字符串有多少$beautiful$的子串？\n例如，\n字符串$1,10$是beautiful的；\n字符串$1???1$也是beautiful的，因为通过问号可以转化为10101；\n但字符串$1???1$不是beautiful的，因为通过问号不管怎么变，都不可能使得01交替出现。\n思路 最开始拿到手感觉很容易想到用奇偶去做，但是想不出来，找题解用dp做了\n由于需要统计子串的数量，考虑统计每一位的贡献去做。\n今天稍微又理解了一下贡献的概念，比如长度为$1$有$1$个子串，增加到$2$时新增了$dp[i] + 1 = 2$条子串，那长度为$2$的字符串一共就有$dp[1] + dp[2] = 3$ 条子串（$dp[i]$代表新增到第$i$个时对答案的贡献）\n用$dp[i][0]$和$dp[i][1]$分别表示以第$i$个数结尾，$s[i]$选$0$和选$1$的集合。属性是：新增摆放$s[i]$后，新增的合法子串数目（也即对答案的贡献）\n转移分两种情况：\n1、如果$a[i] = ?$，则$dp[i - 1]$的两种情况都能转移\n$$dp[i][1] = dp[i - 1][0] + 1$$\n$$dp[i][0] = dp[i - 1][1] + 1$$\n2、如果为0或者1，则只转移一种，以 $1$ 为例，上一项为 $1$ 这一项为 $0$ 的构造是不可能的，因此，令当前项为0的构造方案也就不存在了，要重新置零开始。\n$$dp[i][1] = dp[i - 1][0] + 1$$\n$$dp[i][0] = 0$$\n注意每次转移时需要取一个$max(dp[i][1], dp[i][0])$加在$ans$上。\n代码 def solve(): s = \u0026#39;.\u0026#39; + input() n = len(s) dp = [[0] * 2 for _ in range(n + 1)] dp[1][0] = 1 if s[1] != \u0026#39;1\u0026#39; else 0 dp[1][1] = 1 if s[1] != \u0026#39;0\u0026#39; else 0 # print(s[1], dp[1][0]) ans = max(dp[1][0], dp[1][1]) for i in range(2, n): if s[i] == \u0026#39;?\u0026#39;: dp[i][0] = dp[i - 1][1] + 1 dp[i][1] = dp[i - 1][0] + 1 elif s[i] == \u0026#39;0\u0026#39;: dp[i][0] = dp[i - 1][1] + 1 elif s[i] == \u0026#39;1\u0026#39;: dp[i][1] = dp[i - 1][0] + 1 ans += max(dp[i][1], dp[i][0]) # print(dp) print(ans) C. Palindrome Basis 题意 给定一个数 $n(n \\leq 4 * 10 ^ 4)$，问 $n$ 可以由多少种回文数的相加表示。\n思路 预处理出所有回文数（大约不到500个）然后跑一个完全背包。\n那么问题来了，怎么看出的是跑一个完全背包的呢。\n令$dp[k][m]$表示仅使用前$m$个回文数来划分数字$k$的方法数。\n观察得：$dp[k][m] = dp[k][m - 1] + dp[k - p_m][m]$, 其中$p_m$为第$m$个回文数。状态转移方程的意思是在$m - 1$时选了第$m$个回文数，那么就加上方案数。\n可用滚动数组的思想将方程压缩到一维。\n代码 def check(n): temp = n res = 0 while n: res = res * 10 + n % 10 n //= 10 return res == temp def init(): MOD = 10**9 + 7 for i in range(1, int(4e4) + 1): if check(i): v.append(i) # print(v) f[0] = 1 for x in v: for i in range(0, int(4e4) + 1): f[i + x] += f[i] f[i + x] %= MOD def solve(): x = int(input()) print(f[x]) if __name__ == \u0026#34;__main__\u0026#34;: v = [] f = [0] * 10 ** 6 init() for test_case in range(1, int(input()) + 1): solve() ","date":"2023-01-09T16:45:31Z","image":"https://inariindream.cn/blog/2023/01/09/dynamic-programming/111_hua1785bdb773933cf142888a263bc42fe_1962947_120x120_fill_q75_box_smart1.jpg","permalink":"https://inariindream.cn/blog/2023/01/09/dynamic-programming/","title":"Dynamic Programming"},{"content":"历法是人们为了在辽阔的时空中不迷茫走散，所开创制定的参考系；而在本质上，每一天都是平等的。地球公转的寒暑枯荣，确定了今天是公历年的最后一天，同时也更是平凡的一天。\n但我在每个岁聿其莫之际，仍都会回望这一段。\n今年是我写年终总结的第三年。\n写下这句话的时候，我也意识到我的大学生活好像也步入了后半程。那现在似乎是一个好的时机，对我前一半时间的感想做一个回应。\n在20年的年终总结中，我曾记录道我进校第一天晚上躺在床上 “畅想着即将可能到来的丰富的社团，紧张的竞赛，珍贵的感情。”在21年的年终总结中，我写道 “虽然我起步晚了点，再努力最终可能也就是个铜牌或者什么也没有”。如今在参加竞赛一年后半退役的此时此刻来看，真是充满戏剧性。\n我与ACM的结缘应该始于21年4月，学校组织接种疫苗的时候，我在后排和同学聊天，对方也是一个对编程有兴趣的同学，我说道 “我觉得python比C++好写，因为Python不会忘记在句尾加分号。” 其实那个时候我根本没写过python，说这句话也只是因为当时刚重新捡起以前学的半吊子C++语法，经常忘加分号而已。说出来也只是为了装个逼。 然后就被旁边的杜老师听见了，现在想来，他可能也挺惊奇物工有人会聊编程，然后把我们拉进了校XCPC群。\n从这一刻起，我的大学的流向改变了。\n关于XCPC 我在那之后的一年半里时常会回想起这一刻，如果没有这剂疫苗，如果我排队稍微晚了一点，如果我当时忍住没有硬要显摆一下，那么，我可能就不会遇见杜老师，也就不会走上这条路了。我也许会醉心于数学建模和挑战杯等等，会成为一个自认为不是做题家的做题家（没有说做题家不好的意思），也许会因比较不同比赛的含金量而焦头烂额。如果没有这个契机，我也许将永远与XCPC无缘，因为非科班的我在物工，信工学院对XCPC的宣传再大也不会宣传到我这里来。\n那么，XCPC带给了我什么呢？一年前的今天，我也许会期望它带给我一个奖牌，能成为我求职/升学的敲门砖，因为那时，我并不知道里面有什么，在我有限的理解里，我将其看作和数学建模一样，是“含金量很高的比赛”。一年后的今天，我才发现这个比赛带给我的远高于此。\n其实我的比赛成绩并不好，作为铁牌退役仔甚至没好意思像其他人那样写退役小作文。但我仍十分幸运能够进入这个圈子。我认识了很多的人，有本校的信工同学，更有其他学校的大佬。他们中有很多是高中甚至初中时期就有竞赛经历的人，是我中学时代最为仰慕的一批人，通过与他们的对话，我得以窥知他们眼中的世界一二。这也使我的眼界没有被局限住。我也记得我有过晚上没写出来的题在梦中写出来，第二天一早开电脑一试真的是正解的经历。这些过程对我而言都是十分宝贵且值得回忆的。\n在年底的南京站，跟我差不多时间进入这个圈子的同级同学带领的队伍，获得了校史第一块奖牌。我衷心祝贺他们，我自问我是没有他那样的决心与毅力，无法做到破釜沉舟。在过去的一年中，我很多次都有“只要这段时间努力过了，自己就会量变达到质变，蜕变成全新的人”的想法，看着很多进步很快的人，以为自己也能成为这样的人。但是，我的努力常常也是三分钟热度，结果也十分显而易见。\n梦想是廉价的，失败者的言论总是微不足道。平时做简单题摸鱼嘻嘻哈哈，到真正比赛才知道刻苦训练的重要性。也许无牌退役这件事，真的会成为我很长一段时间内的遗憾吧。\n借用一句之前看到的一个回答：\n“acm也许是我介于中二期与成熟期之间过渡时期的梦想，闪闪发光的梦想，恐怕以后不会再有这样追逐梦想的机会了。我成熟了，长大了，要学会权衡利弊了，要学会选择性价比高的事物了。”\n关于其他 其实今年我的收获还是很多，大量的网课时间让我得以有空闲探索自己喜欢的领域，我做了个好玩的qq机器人，学会了服务器的基本功能和使用，找导师参与到了几个AI项目，写了个小插件并获得了很多star等等。年初的我，一定想不到在这一年里我能学到这么多东西，遇到这么多厉害的人。\n认识的人越来越多，接收的信息也越来越广泛，在双创和acmer实习群里我也见到了很多在自己领域处于尖端水平的前辈的发言，这些充满专业眼光和独到见解的信息让我对自己要掌握的技能，要投身的行业，要选择怎么样的人生，变得愈发清晰明了。\n但是，从无到有，要迈出的仅仅只有一小步，而从浅入深，需要付出的努力应该远比我所能估量的要大，了解的越多，越是能深知我仍有一条很长的路要走。\n当然遗憾也还是有的，没能拿牌、没参加过现场赛、一整年没有静下来看完一本书、眼高手低的毛病仍没改掉、没狠下心买写字机导致这学期抄7门实验报告手快抄断了\n我仍怀着一点小小的期望，希望在明年的此时我在回顾刚刚过去的一年时，能够回应现在的自己：告诉此时的我又学到了以现在眼光难以想象的东西，遗憾也比上一年少了很多。\n“朝变幻无穷的目标前进吧，我内心中的跃动永不休止。”\n后记 太阳系的一颗蓝色岩质行星又公转了一周，寒暑枯荣确立了年复一年的旋回。我们能轻易挖掘到千百年前的历史，却难以想象五年后的未来，即使它近在咫尺。\n在这一年，“改变”的争先恐后和纷至沓来让我们不安，也许变化已经成为一种常态，我们如何接纳变化，将决定我们的道路通向何方。\n但或许这正是文明，能以每个人的微小力量，努力摆脱由自然界周期完全决定的命运；也能在无数的未知和随机涨落的沉浮间，依旧矢志前行。\n愿大家身体健康。\n新年快乐！\n","date":"2022-12-29T10:39:43Z","image":"https://inariindream.cn/blog/2022/12/29/2022%E5%B9%B4%E7%BB%88%E6%80%BB%E7%BB%93/333_huee0377b4297da8b2a157c49f7c6703d5_80449_120x120_fill_q75_box_smart1.jpg","permalink":"https://inariindream.cn/blog/2022/12/29/2022%E5%B9%B4%E7%BB%88%E6%80%BB%E7%BB%93/","title":"2022年终总结"},{"content":"ABC287 D - Match or Not 题意 给定两个由小写字母和？字符串$S，T$, 问$S\u0026rsquo;$和$T$是否匹配，其中，$S′$由 $S$串的前 $x$个字符和后 $|T|−x$个字符组成。\n两个字符串匹配，当且仅当将其中的 ?替换成英文字母后，两个字符串相同或他们本身就相同。\n思路 两个字符串匹配，当且仅当每一位要么是相同字母，要么至少有一个?。于是我们可以储存所有不满足这些条件的位置。当且仅当该位置的数量为0时，两个字符串匹配。\n注意到当$x$递增的时候，前后两个 $S′$ 仅有一个位置不同，因此我们可以继承上一个状态，仅判断变化的位置能否匹配即可。\n答案一定呈现NO YES \u0026hellip; YES YES YES \u0026hellip;NO NO NO 或 YES YES YES \u0026hellip; NO NO NO 这样的分布，即第一次由YES变成NO之后不可能回到YES\n代码 def solved(): s = input() t = input() n = len(s) m = len(t) se = set() now = 0 for i in range(n - m, n): if s[i] != \u0026#34;?\u0026#34; and t[now] != \u0026#34;?\u0026#34; and s[i] != t[now]: se.add(now) now += 1 print(\u0026#34;Yes\u0026#34; if len(se) == 0 else \u0026#34;No\u0026#34;) for i in range(m): try: se.remove(i) except: pass if s[i] != \u0026#34;?\u0026#34; and t[i] != \u0026#34;?\u0026#34; and s[i] != t[i]: se.add(i) print(\u0026#34;Yes\u0026#34; if len(se) == 0 else \u0026#34;No\u0026#34;) E - Karuta 题意 给定$n$个字符串，对于每个字符串 $s_i$，问 $maxLCP(si,sj)_{i≠j}$，其中$LCP$是最长公共前缀。\n思路 其实只需要排序一次，最长公共前缀一定能出现在字典序上的邻居两个字符串之间。\n代码 def solvee(): n = int(input()) s = [] for i in range(n): s.append([input(), i]) s.sort() ans = [0] * n def check(a, b): now = 0 l = min(len(a), len(b)) while now \u0026lt; l and a[now] == b[now]: now += 1 return now for i in range(n): if i == 0: ans[s[i][1]] = check(s[i][0], s[i + 1][0]) continue if i == n - 1: ans[s[i][1]] = check(s[i][0], s[i - 1][0]) continue ans[s[i][1]] = max(check(s[i][0], s[i - 1][0]), check(s[i][0], s[i + 1][0])) print(*ans, sep=\u0026#34;\\n\u0026#34;) ABC295 D - Three Days Ago 题意 给定一个字符串$S$，找出区间$[L, R]$的个数，使$S_LS_{L + 1}\u0026hellip;S_R$中每个数字出现的次数为偶数\n思路 开始的思路想的是用前缀和记录下次数，然后乱搞搞，但是想想觉得会写的很答辩。就直接逃跑看题解了\u0026hellip;\n有篇题解写的特别简洁，偷了贴出来\n我们只关注出现的奇偶性所以显然可以只维护这个前缀里每个字母出现奇数还是偶数次，也就是直接状压，设状态为 S，则只有前面的状态 S才可以与当前的状态 S相匹配形成一个符合条件的区间，所以直接扫一遍维护一下就好了。\n说人话就是，可以用十位二进制数存到目前位置的数字出现情况，每次回到这样的出现次数状态就说明异或为0(或者1, 与初值有关)了，记录回到这样状态的次数（即某些数字出现了偶数次了且其他数字出现情况（前缀）都相同），累加一下，就能做到只扫一遍就把所有情况都统计完了。\n例(v的变化情况)：\n代码 def solved(): s = input() v = 0 cnt = [0] * (1 \u0026lt;\u0026lt; 11) n = len(s) ans = 0 cnt[0] = 1 for i in range(n): v ^= (1 \u0026lt;\u0026lt; int(s[i])) print(v) ans += cnt[v] cnt[v] += 1 print(ans) ","date":"2022-12-23T11:06:32Z","image":"https://inariindream.cn/blog/2022/12/23/atc%E8%A1%A5%E9%A2%98%E5%90%88%E9%9B%86/222_hu8a0ae0b5ba06d0fc393571ca4609b8d9_189713_120x120_fill_q75_box_smart1.jpg","permalink":"https://inariindream.cn/blog/2022/12/23/atc%E8%A1%A5%E9%A2%98%E5%90%88%E9%9B%86/","title":"ATC补题合集"},{"content":"本文用于记录在炼丹时踩过的坑，以及解决方案。\n之前在AutoDL训的时候很多都忘记录了\u0026hellip;只记得基本每训一次之前得改5 6个bug\n所以现在从padddleX开始记录。\nTypeError: Argument \u0026lsquo;bb\u0026rsquo; has incorrect type (expected numpy.ndarray, got list) 问题描述 在使用自己打标好的COCO数据集训练时，出现了如下错误：\n---------------------------------------------------------------------------TypeError Traceback (most recent call last)/tmp/ipykernel_128/738473502.py in \u0026lt;module\u0026gt; 15 warmup_start_lr=0.0, 16 save_dir=\u0026#39;output/mask_rcnn_r50_fpn\u0026#39;, ---\u0026gt; 17 use_vdl=True) /opt/conda/envs/python35-paddle120-env/lib/python3.7/site-packages/paddlex/cv/models/detector.py in train(self, num_epochs, train_dataset, train_batch_size, eval_dataset, optimizer, save_interval_epochs, log_interval_steps, save_dir, pretrain_weights, learning_rate, warmup_steps, warmup_start_lr, lr_decay_epochs, lr_decay_gamma, metric, use_ema, early_stop, early_stop_patience, use_vdl, resume_checkpoint) 289 early_stop=early_stop, 290 early_stop_patience=early_stop_patience, --\u0026gt; 291 use_vdl=use_vdl) 292 293 def quant_aware_train(self, /opt/conda/envs/python35-paddle120-env/lib/python3.7/site-packages/paddlex/cv/models/base.py in train_loop(self, num_epochs, train_dataset, train_batch_size, eval_dataset, save_interval_epochs, log_interval_steps, save_dir, ema, early_stop, early_stop_patience, use_vdl) 331 outputs = self.run(ddp_net, data, mode=\u0026#39;train\u0026#39;) 332 else: --\u0026gt; 333 outputs = self.run(self.net, data, mode=\u0026#39;train\u0026#39;) 334 loss = outputs[\u0026#39;loss\u0026#39;] 335 loss.backward() /opt/conda/envs/python35-paddle120-env/lib/python3.7/site-packages/paddlex/cv/models/detector.py in run(self, net, inputs, mode) 102 103 def run(self, net, inputs, mode): --\u0026gt; 104 net_out = net(inputs) 105 if mode in [\u0026#39;train\u0026#39;, \u0026#39;eval\u0026#39;]: 106 outputs = net_out /opt/conda/envs/python35-paddle120-env/lib/python3.7/site-packages/paddle/fluid/dygraph/layers.py in __call__(self, *inputs, **kwargs) 900 self._built = True 901 --\u0026gt; 902 outputs = self.forward(*inputs, **kwargs) 903 904 for forward_post_hook in self._forward_post_hooks.values(): /opt/conda/envs/python35-paddle120-env/lib/python3.7/site-packages/paddlex/ppdet/modeling/architectures/meta_arch.py in forward(self, inputs) 24 25 if self.training: ---\u0026gt; 26 out = self.get_loss() 27 else: 28 out = self.get_pred() /opt/conda/envs/python35-paddle120-env/lib/python3.7/site-packages/paddlex/ppdet/modeling/architectures/mask_rcnn.py in get_loss(self) 121 122 def get_loss(self, ): --\u0026gt; 123 bbox_loss, mask_loss, rpn_loss = self._forward() 124 loss = {} 125 loss.update(rpn_loss) /opt/conda/envs/python35-paddle120-env/lib/python3.7/site-packages/paddlex/ppdet/modeling/architectures/mask_rcnn.py in _forward(self) 98 # Mask Head needs bbox_feat in Mask RCNN 99 mask_loss = self.mask_head(body_feats, rois, rois_num, self.inputs, --\u0026gt; 100 bbox_targets, bbox_feat) 101 return rpn_loss, bbox_loss, mask_loss 102 else: /opt/conda/envs/python35-paddle120-env/lib/python3.7/site-packages/paddle/fluid/dygraph/layers.py in __call__(self, *inputs, **kwargs) 900 self._built = True 901 --\u0026gt; 902 outputs = self.forward(*inputs, **kwargs) 903 904 for forward_post_hook in self._forward_post_hooks.values(): /opt/conda/envs/python35-paddle120-env/lib/python3.7/site-packages/paddlex/ppdet/modeling/heads/mask_head.py in forward(self, body_feats, rois, rois_num, inputs, targets, bbox_feat, feat_func) 244 if self.training: 245 return self.forward_train(body_feats, rois, rois_num, inputs, --\u0026gt; 246 targets, bbox_feat) 247 else: 248 im_scale = inputs[\u0026#39;scale_factor\u0026#39;] /opt/conda/envs/python35-paddle120-env/lib/python3.7/site-packages/paddlex/ppdet/modeling/heads/mask_head.py in forward_train(self, body_feats, rois, rois_num, inputs, targets, bbox_feat) 182 tgt_labels, _, tgt_gt_inds = targets 183 rois, rois_num, tgt_classes, tgt_masks, mask_index, tgt_weights = self.mask_assigner( --\u0026gt; 184 rois, tgt_labels, tgt_gt_inds, inputs) 185 186 if self.share_bbox_feat: /opt/conda/envs/python35-paddle120-env/lib/python3.7/site-packages/paddlex/ppdet/modeling/proposal_generator/target_layer.py in __call__(self, rois, tgt_labels, tgt_gt_inds, inputs) 256 257 outs = generate_mask_target(gt_segms, rois, tgt_labels, tgt_gt_inds, --\u0026gt; 258 self.num_classes, self.mask_resolution) 259 260 # mask_rois, mask_rois_num, tgt_classes, tgt_masks, mask_index, tgt_weights /opt/conda/envs/python35-paddle120-env/lib/python3.7/site-packages/paddlex/ppdet/modeling/proposal_generator/target.py in generate_mask_target(gt_segms, rois, labels_int32, sampled_gt_inds, num_classes, resolution) 351 results.append( 352 rasterize_polygons_within_box(new_segm[j], boxes[j], --\u0026gt; 353 resolution)) 354 else: 355 results.append( /opt/conda/envs/python35-paddle120-env/lib/python3.7/site-packages/paddlex/ppdet/modeling/proposal_generator/target.py in rasterize_polygons_within_box(poly, box, resolution) 306 307 # 3. Rasterize the polygons with coco api --\u0026gt; 308 mask = polygons_to_mask(polygons, resolution, resolution) 309 mask = paddle.to_tensor(mask, dtype=\u0026#39;int32\u0026#39;) 310 return mask /opt/conda/envs/python35-paddle120-env/lib/python3.7/site-packages/paddlex/ppdet/modeling/proposal_generator/target.py in polygons_to_mask(polygons, height, width) 282 import pycocotools.mask as mask_util 283 assert len(polygons) \u0026gt; 0, \u0026#34;COCOAPI does not support empty polygons\u0026#34; --\u0026gt; 284 rles = mask_util.frPyObjects(polygons, height, width) 285 rle = mask_util.merge(rles) 286 return mask_util.decode(rle).astype(np.bool) pycocotools/_mask.pyx in pycocotools._mask.frPyObjects() TypeError: Argument \u0026#39;bb\u0026#39; has incorrect type (expected numpy.ndarray, got list) 解决方案 这是因为json文件里面的segmentation中的数据不符合要求，正常来说这里面是类似于[x,y,x,y,x,y\u0026hellip;..x,y]按顺序排列的点序列，并且这里面的点序列个数是偶数，同时点的个数至少要超过2个（4个最稳），也就是要构面。\n而我在打标时用的是矩形打标，只记录了对角两个点。因此这里面的数据是[x1,y1,x2,y2]，这里面的点序列个数是4个，而且是不符合要求的，因此需要将这里面的数据转换成符合要求的数据。\n写一个小脚本将[x1,y1,x2,y2]转换成[x1,y1,x1,y2,x2,y2,x2,y1]，这样就符合要求了。\nimport json with open(\u0026#39;instances_val2017.json\u0026#39;) as f: data = json.load(f) ann = data[\u0026#39;annotations\u0026#39;] for i in ann: if len(i[\u0026#39;segmentation\u0026#39;][0]) == 4: x1, y1, x2, y2 = i[\u0026#39;segmentation\u0026#39;][0] i[\u0026#39;segmentation\u0026#39;][0] = [x1, y1, x2, y1, x2, y2, x1, y2] with open(\u0026#39;instances_val2017.json\u0026#39;, \u0026#39;w\u0026#39;) as f: json.dump(data, f, indent=4) SystemError: (Fatal) Blocking queue is killed because the data reader raises an exception. 解决方案 参考这个ISSUE\nAssertionError: Results do not correspond to current coco set assert set(annsImgIds)== (set(annsImgIds)\u0026amp; set(self.getImgIds())),\\ \u0026#39;Results do not correspond to current coco set\u0026#39; 解决方案 COCO数据集不规范，检查下合成时有没有空的json，只有id没有坐标。\n真·解决方案\n最后发现是把eval_dataset.add_negative_samples(image_dir='o_Natural_empty_light')注释掉就行。。。我还重新生成了几次coco数据集。我真服了，paddle魔改完的库能不能多测试下啊\n","date":"2022-12-17T10:24:08Z","image":"https://inariindream.cn/blog/2022/12/17/%E7%82%BC%E4%B8%B9%E9%97%AE%E9%A2%98%E5%AE%9E%E5%BD%95/111_hu67345f7c87db9a9ca58e7dbc37776702_80206_120x120_fill_box_smart1_3.png","permalink":"https://inariindream.cn/blog/2022/12/17/%E7%82%BC%E4%B8%B9%E9%97%AE%E9%A2%98%E5%AE%9E%E5%BD%95/","title":"炼丹问题实录"},{"content":"此纪录从2022-10-21 09:56:46始\nEducational Codeforces Round 142 C. Min Max Sort 题意 给定一个排列，选择两个值，将其中较小的值移到排列首部，较大的值移到排列尾部。求将排列排序为严格递增序的最小操作次数。\n思路 这题本来是在vp的时候用双指针分情况讨论做的，然后发现戴老师的dp做法很炫酷，所以还是补一下\n双指针做法\n首先最终的有序序列中，$(1, n), (2, n - 1)$这种成对的数字一定是关于数组的中心点对称的，因此在操作的时候也要选这对数字来分别插入到两边才能实现目标。\n对于任意一个排列，最多操作$\\lfloor \\frac{n}{2} \\rfloor$次。做法就是先记录排列中每个数字在原数组中的位置，然后从中间数据的位置开始往两边扫，如果符合要求，则说明这对数字不用动，$ans -= 1$\nDP做法（待补） 最长上升子序列\n代码 \u0026#34;\u0026#34;\u0026#34; 双指针做法 \u0026#34;\u0026#34;\u0026#34; def solve(): n = int(input()) a = list(map(int, input().split())) p = [0] * (n + 1) for i in range(n): p[a[i]] = i + 1 if a == sorted(a): print(0) return ans = 0 if n \u0026amp; 1 == 0: # print(p) ans = n // 2 l = n + 1 r = 0 for i in range(n // 2): ll = n // 2 - i rr = n // 2 + i + 1 if p[ll] \u0026lt; p[rr] and p[ll] \u0026lt; l and p[rr] \u0026gt; r: l = p[ll] r = p[rr] ans -= 1 else: break else: ans = n // 2 l = r = p[n // 2 + 1] for i in range(1, n // 2 + 1): ll = n // 2 + 1 - i rr = n // 2 + 1 + i if p[ll] \u0026lt; p[rr] and p[ll] \u0026lt; l and p[rr] \u0026gt; r: l = p[ll] r = p[rr] ans -= 1 else: break print(ans) D. Fixed Prefix Permutations 题意 思路 字典树，看的ygg题解qwq\n在字典树的insert()操作时，将当前列表的pos数组给插入进去，这样，在查询操作时，就能查询整个字典树中能和自己匹配的最大前缀数量。\n代码 idx = 0 def solve(): n, m = map(int, input().split()) trie = [[0] * 11 for _ in range(10 * n)] global idx idx = 0 def insert(s): global idx p = 0 for c in range(1, m + 1): if trie[p][pos[c]] == 0: idx += 1 trie[p][pos[c]] = idx p = trie[p][pos[c]] def query(s): p = 0 cnt = 0 for c in s: if trie[p][c] != 0: p = trie[p][c] cnt += 1 else: break return cnt a = [] for i in range(n): pos = [0] * 11 a.append(list(map(int, input().split()))) for j, x in enumerate(a[i]): pos[x] = j + 1 insert(a[i]) for x in a: print(query(x), end=\u0026#34; \u0026#34;) print() 另外需要注意的一点就是Trie的数组大小，当前来看第一位开$10 * n$不会越界，但最开始在每个solve里面开$1e5$又会T（acwing的板题都没有多组数据= =\n1.28注：Trie的数组第一维一般是开$n * d$（d是最大可能深度）\nEducational Codeforces Round 141 这场是真的狠狠被教育了\u0026hellip;B的构造手玩半天没玩出来，有思路之后写蛇形矩阵的实现写了一万年\u0026hellip;真的叫基础不牢地动山摇\nC. Yet Another Tournament 题意 有$n$名玩家，战力分别为$[1, n]$。我们也是一名玩家，一共有 $n+1$ 名玩家。对于 $n$ 名玩家来说， $i$ 能击杀 $j$ 当且仅当 $i \u0026gt; j$ 。对于每一位玩家我们都有一个准备值 $a_i$ ，我们想要击败该名玩家需要花费 $a_i$ 的时间去准备。刚开始我们拥有的时间为 $m$ ，每名玩家都和其余所有玩家进行一轮对局，最终按照胜场数量对所有玩家进行排名，求我们合理分配时间会获得的最高排名。\n思路 经典读错题，看到题里面的 Calculate the minimum possible place (lower is better) ，以为名次要越低越好\u0026hellip;\n可以二分/贪心，感觉贪心好想一点，其实二者本质上是一样的。\n策略是选择尽量多的选手，因此先将选手排序。\n然后关键在于自己最后赢的一个人，要找和自己名次相同的那个人（别人的名次是可以计算的），因为如果能放弃自己为前一个人（自己准备时间的最尾端）准备的时间来准备跟与自己相同名次的人比赛，如果时间充足，即可胜利，排名上升一名。反之排名不变，也没损失。\n因为在最后一次的决定中，放弃与前一个人的准备时间并不会让自己的排名下降。如果前一个人的排名比自己低，那结果是两人都上升一名，若等于或高于自己的排名，则不会发生变化。\n如果时间不够就不用放弃\n代码 def solve(): n, m = map(int, input().split()) a = list(map(int, input().split())) b = a.copy() b.sort() win = 0 while win \u0026lt; n and b[win] \u0026lt;= m: m -= b[win] win += 1 if win == n: print(1) return if win == 0: print(n + 1) return if m + b[win - 1] - a[win] \u0026gt;= 0: print(n - win) else: print(n - win + 1) D. Different Arrays 题意 给定一个长度为n的数组，必须进行$n ― 2$次操作，对$[2, n 一1]$范围内的数按顺序进行一次操作，一次操作为让左边和右边的两个数一个加上$a_i$一个减去$a_i$; ($a_i$指的是当前值)，求操作后可能获得的数组的数量。\n$$0≤a_i≤300, 1≤n ≤300$$\n思路 看典哥题解写的\u0026hellip;一开始还以为py用二维会炸（事实上也在炸的边缘），后来发现是自己太相信py的高精度了，被狠狠教育了\n如果把结果放在最后才%MOD，可能会TLE或MLE\ndp，看值域考虑dp，所有数最终能够变成的值域是$[-300 * 300, 300 * 300]$\n二维版本\n$f[i][j]$ 表示前$i$个数中，最终凑成的值$j$的方案数\n每次先循环位置，再枚举当前位置最终变成的数\n转移方程：\n$$f[i + 1][a[i + 1] + j] += f[i][j]$$\n$$f[i + 1][a[i + 1] - j] += f[i][j]$$\n坑点：如果j = 0的话就只需要转移一次，要特判一下\n一维版本\n其实思路一样，不过是类似滚动数组，每遍历到一个$a_i$的新位置，用一个新数组存，然后覆盖老数组，就可以去掉$i$的维度。这样写居然不会MLE我也觉得很神奇\n代码 def solve(): N = 310 n = int(input()) a = list(map(int, input().split())) # f[i][j] = 前i个数中，最终变成的数为j 的方案数 f = [[0] * 90250 * 2 for _ in range(N)] p = 90000 # 初始化，最开始只有位置2，值域也只能到a[2] f[1][a[1] + p] = 1 for i in range(1, n - 1): # 对于每个a_i，试探所有可能值（若在a_i前面的值使f[i][j]不为空，说明前i个数能够到达j这个值） for j in range(-p + 300, p - 300 + 1): if f[i][j + p] != 0 and j != 0: f[i + 1][a[i + 1] - j + p] += f[i][j + p] f[i + 1][a[i + 1] - j + p] %= 998244353 f[i + 1][a[i + 1] + j + p] += f[i][j + p] f[i + 1][a[i + 1] + j + p] %= 998244353 elif f[i][j + p] != 0: f[i + 1][a[i + 1] + p] += f[i][j + p] f[i + 1][a[i + 1] + p] %= 998244353 ans = 0 for i in range(-p, p): ans += f[n - 1][i + p] ans %= 998244353 print(ans) # 一维版本 def solve2(): n = int(input()) a = list(map(int, input().split())) MOD = 998244353 p = 90005 ans = [0] * (2 * p + 500) ans[a[1] + p] = 1 for i in range(n - 2): dp = [0] * (2 * p + 500) for j in range(-p, p + 1): if ans[j + p] and j != 0: dp[a[i + 2] + j + p] += ans[j + p] dp[a[i + 2] + j + p] %= MOD dp[a[i + 2] - j + p] += ans[j + p] dp[a[i + 2] - j + p] %= MOD elif ans[j + p]: dp[a[i + 2] + p] += ans[j + p] dp[a[i + 2] + p] %= MOD ans = dp print(sum(ans) % MOD) 这题的教训就是一定记得计算需要的数组长度（济南的签到好像也是这样栽了半天），和ans不要留到最后才模\nEducational Codeforces Round 140 C. Count Binary Strings 题意 给定一个01串，给定每一个区间范围内的限制。其中 g[i][j]表示对于区间[i, j]的限制。若g[i][j] = 1，说明这个区间内只能出现一种数;若g[i][j] = 2，说明这个区间内必须同时出现两种数;若g[i][j] =0，说明这个区间没有限制。求合法01串的数量。\n思路 DP，观察发现若为合法01串，对于指定的右端点r，一定有:$a[1][r], a[2][r]\u0026hellip;a[r][r]$呈现$2222\u0026hellip;111..1$的特征。因为从后往前考虑，如果r - 1的位置与r的位置相同，则$a[r - 1][r] = 1$，否则为2。而一旦有某个位置为2了，这个位置往前的所有位置都会是2。\n令$dp[i][j]$表示在前i个位置中，分界点为$j$的方案数（即，$j$以前为$2$，$j$及以后为$1$），答案为在位置$n$时的所有分界线位置方案之和，即 $$\\sum_{i = 1}^{n}dp[n][i]$$\n转移：从$dp[i][j]$开始，如果向后摆放的是和上一位相同的数，则j不变，转移到$dp[i + 1][j]$。若向后摆放的是和上一位不同的数，则$j$直接跳到$i + 1$，转移到了$dp[i + 1][i + 1]$。转移方程：\n$dp[i + 1][j] += dp[i][j]$\n$dp[i + 1][i + 1] += dp[i][j]$\n注意这题还需要一个判断合法条件的操作，因为如果在$[1，j - 1]$区间有不该出现的$1$或在$[j, n]$区间有不该出现的$2$，则说明$j$在这个位置分割的方案是不可达到的，需要将该位置的$dp[i][j]$置$0$。\n代码 def solve(): n = int(input()) a = [[0]] dp = [[0] * (n + 2) for _ in range(n + 2)] MOD = 998244353 for i in range(1, n + 1): a.append([0] * i + list(map(int, input().split()))) dp[1][1] = 2 # 表示第一个位置可以为1可以为0 # l是分界点的坐标，在遍历前r个时，枚举分界点坐标 for r in range(1, n + 1): for l in range(1, r + 1): flag = 0 for k in range(1, l): if a[k][r] == 1: flag = 1 for k in range(l, r + 1): # print(k, r) if a[k][r] == 2: flag = 1 if flag: dp[r][l] = 0 # 说明此处不合法,不满足22221111... # print(r + 1, l) dp[r + 1][l] = (dp[r + 1][l] + dp[r][l]) % MOD dp[r + 1][r + 1] = (dp[r + 1][r + 1] + dp[r][l]) % MOD ans = 0 for i in range(1, n + 1): ans = (ans + dp[n][i]) % MOD print(ans) Educational Codeforces Round 139 D. Lucky Chains 题意 给定两个数$a, b(1 \\leq a, b \\leq 1e7)$，执行如下语句：\nwhile(gcd(a, b) == 1) a++, b++, cnt++ ;\n求cnt的值\n思路 数学苦手，看典哥题解都理解了好一会\n一个gcd的性质\n$gcd(a, b) == gcd(a, b - a)$\n假设 $a$ 是更小的那个数，我们根据gcd的性质推导一下： $gcd(a, b) == gcd(a, b - a)$ 因此 $gcd(a + k, b + k) == gcd(a + k, b - a)$ 。\n$b - a$是一个定值，因此问题转化成对于每一个$ b - a $的质因数$p$（刚开始还想了半天为什么找质因数，菜死了），$(a + k) % p == 0$ 时$k$的最小值，式子可转化为求$a - a%p$ 的最值。\n一种更快的办法是直接找每个数的最小质因子，然后对$p$进行除的操作来找到其下一个质因数，这样就不用处理所有的质数\n前者复杂度为$O(nsqrt(n))$，因为需筛出所有的质数\n后者为$O(nlog(n))$\n代码 primes = [-1] * 10 ** 7 def init(): # 所有数的最小质因子 for i in range(2, 10 ** 7): if primes[i] == -1: for j in range(i, 10 ** 7, i): primes[j] = i def solve(): a, b = map(int, input().split()) dif = b - a if dif == 1: print(-1) return if math.gcd(a, b) != 1: print(0) return if dif \u0026amp; 1 == 0: print(1) return ans = dif - a % dif while dif != 1: ans = min(ans, primes[dif] - a % primes[dif]) # 找到下一个质因数 dif //= primes[dif] # print(primes[1:25]) print(ans) if __name__ == \u0026#34;__main__\u0026#34;: init() for test_case in range(1, int(input()) + 1): solve() 贴一个前一天的C，是相似的题，一起补了\n题意 给定一个数列$a$，问是否存在$i, j$使得$gcd(a_i, a_j) \\neq 1$\n思路 思路差不多，主要也是考察的筛\n不过数据范围是$1e9$，直接根号筛的话用py过不去，因为C++都跑了1100ms\n看了下别人的py代码没太看懂，也许需要更高级的筛法，比如用随机化筛，能变成$O(M^{\\dfrac{1}{4}})$, 但没存py的板子也没必要存，就直接换C++用$O(\\sqrt{M})$的筛法莽过去了\nconst int N =33333; vector\u0026lt;int\u0026gt;primes(N, 0); vector\u0026lt;int\u0026gt;vis(N, 0); void init() { int now = 0; for (int i = 2; i \u0026lt; N; i++) { if (!vis[i]) primes[now++] = i; for (int j = 0; primes[j] * i \u0026lt; N; j++) { vis[primes[j] * i] = true; if (i % primes[j] == 0) break; } } } void solve(){ int n; cin \u0026gt;\u0026gt; n; vector\u0026lt;int\u0026gt;a(n); for (int i = 0; i \u0026lt; n; i++) { cin \u0026gt;\u0026gt; a[i]; } for(auto i : primes){ if (i == 0){ break; } int cnt = 0; for (int j = 0; j \u0026lt; n; j++) { if (a[j] % i == 0){ cnt++; while (a[j] % i == 0){ a[j] /= i; } } } if (cnt \u0026gt;= 2){ cout \u0026lt;\u0026lt; \u0026#34;YES\u0026#34; \u0026lt;\u0026lt; endl; return; } } map\u0026lt;int, int\u0026gt;mp; for (int i = 0; i \u0026lt; n; i++) { if (a[i] != 1){ mp[a[i]]++; } if (mp[a[i]] \u0026gt;= 2){ cout \u0026lt;\u0026lt; \u0026#34;YES\u0026#34; \u0026lt;\u0026lt; endl; return; } } cout \u0026lt;\u0026lt; \u0026#34;NO\u0026#34; \u0026lt;\u0026lt; endl; } Educational Codeforces Round 138 C Number Game 题意: 给定一个长度为$n$的整数数组$a$, Alice和Bob玩游戏.对于一个$k$, 游戏进行$k$轮, 第$i$轮,Alice选择从a中删除一个小于等于$k - i + 1$的数, Bob选择一个数加上$k - i + 1$.如果某一轮Alice没有数字可以选择,则Bob赢,否则Alice赢.问使得Alice赢的最大的k是多少?\n$(n \u0026lt;= 100)$\n思路 最开始以为是二分答案，但注意到n比较小，所以可以直接写模拟，Bob的策略应该是每回合将Alice当前的$k - i + 1$加到当前数列的最小项上面，这样能最大化减少Alice能删掉的数量。Alice的策略则是趁$k - i + 1$减小之前每次尽可能删掉能删掉的最大数。\n其实这个思路很好想，昨晚在看题十分钟后就想到了，但写模拟代码写了一万年还调错了，典中典之脑子会了手没会。\n今早想清楚模拟过程之后10分钟1A了\n代码 $O(n^3)$\ndef solve(): n = int(input()) b = list(map(int, input().split())) b.sort() k = n while k \u0026gt; 0: a = b.copy() # 最开始写的 a = b，没发现，调其他地方调了一万年 index = 1 while index \u0026lt;= k: pos = -1 temp = k - index + 1 for i in range(len(a)): if temp \u0026gt;= a[i]: pos = i if pos == -1: k -= 1 break if index == k: print(k) return a.remove(a[pos]) if len(a) \u0026gt; 0: a[0] += temp a.sort() index += 1 print(k) $O(nlogn)$ 待补\nvoid solve() { int n; cin \u0026gt;\u0026gt; n; vector\u0026lt;int\u0026gt; a(n); cin \u0026gt;\u0026gt; a; sort(a.begin(), a.end()); int left = 0, right = (n + 1) / 2; auto check = [\u0026amp;](int k) { if (k == 0) return true; if (a[k - 1] != 1) return false; for (int i = k; i \u0026lt; 2 * k - 1; i++) { if (a[i] \u0026gt; i - k + 2) { return false; } } return true; }; while (left \u0026lt;= right) { int k = (left + right) / 2; if (check(k)) left = k + 1; else right = k - 1; } cout \u0026lt;\u0026lt; left - 1 \u0026lt;\u0026lt; \u0026#34;\\n\u0026#34;; } D. Counting Arrays 在problemset里面看到一道1k9的dp，想做做\u0026hellip;结果发现是数学\u0026hellip;线筛的一个地方抄错了找了2h\u0026hellip;相似\n题意 给定一个 n 和 m ，构造出一个长度为n，每一个元素的范围是[1, m]的数组，求有多少个数组是模棱两可的。一个模棱两可的数组的定义是其删除数组b不唯一，（$b_i$是第i次操作时的删除数）一个元素a[i]可以被删除当且仅当$gcd(a[i], i) == 1$。\n思路 正难则反，一共只有模棱两可和删除数组唯一两种情况。而删除数组唯一时，b数列一定全为1。说明在删除数组唯一的情况下，$a_i$去模范围$[2, n]$内的所有质数一定不为1。（都不互质）\n进而推得$a_i$ 的值域一定是$[2, n]$内的所有质数的质数积及其倍数\n设枚举到$i$时的质数积为$temp$，则个数为$\\left \\lfloor \\frac{m}{temp} \\right \\rfloor$\n然后利用乘法原理统计即可。最后的答案是总方案数减去删除数组唯一的数量。\n注意题目求的是长度为$[1, n]$区间所有长度的a的模棱两可数量，因此在每算一次就要加到ans上，而不是最后用n长度时的sum-cnt（sb题面）\n代码 maxn = 3 * 10 ** 5 + 5 isPrime = [0] * maxn primes = [0] * maxn def init(): cnt = 0 isPrime[1] = 1 for i in range(2, maxn): if isPrime[i] == 0: primes[cnt] = i cnt += 1 j = 0 while i * primes[j] \u0026lt; maxn: isPrime[i * primes[j]] = 1 if i % primes[j] == 0: break j += 1 def solve(): n, m = map(int, input().split()) MOD = 998244353 ans = 0 temp = 1 mul = 1 for i in range(1, n + 1): if isPrime[i] == 0: temp *= i if temp \u0026gt; m: break mul *= (m // temp) % MOD ans += mul % MOD __sum = 0 for i in range(1, n + 1): __sum += pow(m, i, MOD) __sum %= MOD print((__sum - ans) % MOD) Educational Codeforces Round 134 D. Maximum AND 题意 给定两个数列$a$, $b$, 令$c_i = a_i \\bigoplus b_i$， 定义价值为 $c_1$ \u0026amp; $c_2$ \u0026amp; $c_3$\u0026amp; \u0026hellip; $c_n$ 求价值的最大值\n$(1≤n≤10^5)$ $(0≤a_i, b_i\u0026lt;2^{30})$\n思路 注意到c在某一位为1时只能是当所有的$c_i$在这一位都为1才能取到，进而需要所有匹配的$a_i$ 和 $b_i$在这一位的异或都为1。\n那么如何找这样满足条件的匹配呢，看题解发现有一种很妙的方法可以实现。$c$贪心地从最高位为$1$开始往下取，然后先假设$c$这一位为1，通过map计数check是否所有的$a_i, b_i$都能满足条件，而并不需要排列来对每个$i$进行匹配。\n如上图所示，如果存在一组满足这样关系的a和b，则用map计数添加进去，而如果c在这一位能够取到1的话，那么map的value一定是一个确定值。\n最后再让$c |= (1 \u0026laquo; i)$（更新值），继续往后推：在这样的高位取值下，c的低位取值情况即可\ndef solve(): n = int(input()) a = list(map(int, input().split())) b = list(map(int, input().split())) d = defaultdict(int) ans = 0 for i in range(30, -1, -1): temp = ans | (1 \u0026lt;\u0026lt; i) d.clear() ok = 1 for j in range(n): d[a[j] \u0026amp; temp] += 1 d[~b[j] \u0026amp; temp] -= 1 # 判断是否异或为1 for j in d.values(): if j != 0: ok = 0 break if ok != 0: # 如果能取到才用或运算加上值 ans = temp print(ans) Educational Codeforces Round 131 D. Permutation Restoration 题意 Educational Codeforces Round 124 D. Nearest Excluded Points 题意 给定$n$个两两不同的整点坐标，对于每个整点$p$，求：不包含在这 $n$ 个点内的其他整点中，与点 $p$ 距离最近的那个。\n思路 答案肯定不能搜寻整个平面，通过观察得，答案只可能在$n$个点组成的图形的“边缘”处\n使用多源bfs来进行搜索，先将图形边缘的所有点加入队列中然后再依次进行广搜。注意，因为有较内层的点，因此就算搜到了在给定的$n$个点内的坐标也要加入队列，然后依次传递答案（更近的点一定更快传递到中心）\n不是很懂为什么是1900的题，可能赛时大家都没想到从边缘开始搜（？\n更多细节见代码\nfrom collections import defaultdict, deque def solve(): n = int(input()) dir = [(1, 0), (-1, 0), (0, 1), (0, -1)] points = [] res = dict() for i in range(n): x, y = map(int, input().split()) points.append((x, y)) res[points[-1]] = None q = deque() for x, y in points: for dx, dy in dir: nx, ny = x + dx, y + dy if (nx, ny) not in res: q.append((nx, ny)) res[(nx, ny)] = (nx, ny) while q: x, y = u = q.popleft() for dx, dy in dir: v = x + dx, y + dy if v in res and res[v] is None: # print(v, u, res[v], res[u]) q.append(v) res[v] = res[u] for x in points: print(*res[x]) Educational Codeforces Round 112 D. Say No to Palindromes（DP） 题意 给定一个由a,b,c组成字符串，定义一个字符串是美丽的当且仅当它的字串中没有回文。\n$m$次询问，每次给定左右端点$l, r$，如果此字符串不美丽，则每修改一个字符cost+=1，问使将这一段字符串修改成美丽字符串的最小花费是多少。\n$(1≤n,m≤2⋅10^5)$\n思路 注意到对于每个$s_i$, $s_i \\neq s_{i - 1}$并且$s_i \\neq s_{i - 2}$才能不形成回文，由于一共只有三种字母，所以$s_i$一定等于$s_{i - 3}$，因此，修改后的整个字符串一定是\u0026quot;abcabcabc\u0026hellip;\u0026quot; 或\u0026quot;bacbacba\u0026hellip;\u0026quot; 等共六种排列情况的串。\n然后在询问前把6种字符串修改情况的操作次数前缀和一下，s[i]代表字符串修改到$i$时的修改次数，在每次询问时用s[r] - s[l - 1]就是这种排列情况时的需要修改的次数（不用关心具体修改了哪些），然后取6个情况中的最小值即可，查询复杂度为$O(1)$\n因为一共就三种字符，所以6种情况一定可以覆盖完全\n代码 def solve(): n, m = map(int, input().split()) s = input() lis = [\u0026#39;abc\u0026#39;, \u0026#39;acb\u0026#39;, \u0026#39;bca\u0026#39;, \u0026#39;bac\u0026#39;, \u0026#39;cab\u0026#39;, \u0026#39;cba\u0026#39;] dp = [[0] * (n + 1) for i in range(6)] for i in range(6): for j in range(n): dp[i][j + 1] = dp[i][j] if s[j] != lis[i][j % 3]: dp[i][j + 1] += 1 for _ in range(m): x, y = map(int, input().split()) ans = 114514114514 for i in range(6): ans = min(ans, dp[i][y] - dp[i][x - 1]) print(ans) Educational Codeforces Round 110 C. Unstable String 题意 给一个字符串，其含有$0,1,?$. 其中，$?$可以看成$1$，也可以看成$0$。如果一个字符串可以是0和1交替出现的，就称这个字符串是$beautiful$。问现在这个字符串有多少$beautiful$的子串？\n例如，\n字符串$1,10$是beautiful的；\n字符串$1???1$也是beautiful的，因为通过问号可以转化为10101；\n但字符串$1???1$不是beautiful的，因为通过问号不管怎么变，都不可能使得01交替出现。\n思路 最开始拿到手感觉很容易想到用奇偶去做，但是想不出来，找题解用dp做了\n由于需要统计子串的数量，考虑统计每一位的贡献去做。\n今天稍微又理解了一下贡献的概念，比如长度为$1$有$1$个子串，增加到$2$时新增了$dp[i] + 1 = 2$条子串，那长度为$2$的字符串一共就有$dp[1] + dp[2] = 3$ 条子串（$dp[i]$代表新增到第$i$个时对答案的贡献）\n用$dp[i][0]$和$dp[i][1]$分别表示以第$i$个数结尾，$s[i]$选$0$和选$1$的集合。属性是：新增摆放$s[i]$后，新增的合法子串数目（也即对答案的贡献）\n转移分两种情况：\n1、如果$a[i] = ?$，则$dp[i - 1]$的两种情况都能转移\n$$dp[i][1] = dp[i - 1][0] + 1$$\n$$dp[i][0] = dp[i - 1][1] + 1$$\n2、如果为0或者1，则只转移一种，以 $1$ 为例，上一项为 $1$ 这一项为 $0$ 的构造是不可能的，因此，令当前项为0的构造方案也就不存在了，要重新置零开始。\n$$dp[i][1] = dp[i - 1][0] + 1$$\n$$dp[i][0] = 0$$\n注意每次转移时需要取一个$max(dp[i][1], dp[i][0])$加在$ans$上。\n代码 def solve(): s = \u0026#39;.\u0026#39; + input() n = len(s) dp = [[0] * 2 for _ in range(n + 1)] dp[1][0] = 1 if s[1] != \u0026#39;1\u0026#39; else 0 dp[1][1] = 1 if s[1] != \u0026#39;0\u0026#39; else 0 # print(s[1], dp[1][0]) ans = max(dp[1][0], dp[1][1]) for i in range(2, n): if s[i] == \u0026#39;?\u0026#39;: dp[i][0] = dp[i - 1][1] + 1 dp[i][1] = dp[i - 1][0] + 1 elif s[i] == \u0026#39;0\u0026#39;: dp[i][0] = dp[i - 1][1] + 1 elif s[i] == \u0026#39;1\u0026#39;: dp[i][1] = dp[i - 1][0] + 1 ans += max(dp[i][1], dp[i][0]) # print(dp) print(ans) Educational Codeforces Round 106 C. Minimum Grid Path 待补\n","date":"2022-10-21T09:56:46Z","image":"https://inariindream.cn/blog/2022/10/21/codeforcesedu%E8%A1%A5%E9%A2%98%E5%90%88%E9%9B%86/222_hu15b1962fdc5d535b167ff7ac7d802c19_3173586_120x120_fill_box_smart1_3.png","permalink":"https://inariindream.cn/blog/2022/10/21/codeforcesedu%E8%A1%A5%E9%A2%98%E5%90%88%E9%9B%86/","title":"CodeforcesEdu补题合集"},{"content":"前言 最早知道这部动画是在7月份，大概知道近期会有一个基于2077世界观的动画会出，但知道有CDPR的参与后，有着2077的前车之鉴，最开始我是不太看好这部动画的。跟很多人一样，我一边追着蒜吻一边看着蒜吻大战，不亦乐乎。直到9月 《边缘行者》的出现，以一己之力停止了两部竞争胶着的动画的纷争，成为了今年原创动画的唯一真神。\n看第一集是在考六级刷分的前一天，考前不想复习的时候打开微博刷了刷，发现这部动画的讨论度超过了我原先的预期，并且评价也都十分不错，于是我将信将疑地打开了第一集。看完第一集的时候我就知道这部番十分对我胃口，无论是动画中还原的游戏设定还是美术风格。前思后想，在看完第三集之后，我还是强迫自己去睡觉了，第二天六级考完后，回到62号隔离楼，我的第一件事就是打开电脑把剩下的集数看完。\n不得不说，后劲是真的大。思来想去，在20多天后的一个没课的上午，还是决定想为这部动画写点什么。\n(Warning：本文含大量剧透内容) 剧情 即使我为《边缘行者》第一次写漫评，我也不能说它是一部多完美的作品，它在很多地方都会让我感受到些许俗套。\n看宣传海报和pv大概就能猜到大卫和Lucy的相遇是一种类似于传统BMG(Boy Meets Girl)的剧情，即：少年与少女命运般的邂逅，经历了一路波折，最终成为了情侣，这样标准的结局。事实也大差不差。在相遇之前，男主眼前擦过头发的那几个画面甚至莫名让我想起了蝶祈（不是\n前几集的剧情其实非常好猜，男主生活出现变故，这时突然出现女主，男主觉得是那种能把自己从原来的日常解救出来的那种人，然后死心塌地地跟着女主，再体会女主的世界，有着新奇的体验。是一种较为传统的剧情。\n甚至在第四集，两人在月下拥吻时，即使我被那唯美的画面和恰到好处的音乐给打动到。但在那集结束字幕的Cyberpunk飘出后，我心里还会有“这样就安排在一起了会不会太快了”的疑问。\n但瑕不掩瑜，赛博朋克的剧情整体是一个较为悲剧的氛围，从op的暗示大概就能猜出最后不会是一个大团圆结局。剧情并没有描绘游戏里“大名鼎鼎的V”那样的几乎是怪物的玩家化身，而是一群被义体技术异化，被赛博精神病折磨，被夜之城吞没的小人物，这也就注定了这部动画的悲剧内核。\n其悲剧性在第一集就充分展现了出来，与母亲相依为命的男主，在夜之城的社会底层如履薄冰，生活难以为继，母亲想让大卫实现阶级跃迁，不惜花重金也要让他就读荒坂旗下的私立学校。但命运并没有放过苦命人，因为用盗版软件让经济情况雪上加霜，在学校被富二代霸凌，卷入飞车战，母亲去世，最后甚至连母亲的遗体都没见到（根据游戏设定，那个位置是清道夫即器官贩卖者的地盘）。\n即使大卫和义体医生在剧中时刻暗示“大卫是特别的”，但大卫身上的许多flag，仍挡不住最后死亡的结局。我在看这部动画之前看的一些评价，隐约能猜到大卫和露西中有一人可能是牺牲了的。（还好看的早） 我虽然心知肚明赛博朋克题材的作品不会有与主题相悖的大团圆结局，但是在最后看到Lucy在月球上孤独地张开双臂，我的心还是狠狠地抽动了一下。\n我是在难过什么呢？瑞贝卡哥哥死的时候，我不觉得难过，我觉得那是场意外，我玩过游戏，所以深知这样的事情在夜之城只能叫做家常便饭 （死人大乐透）。并且他的死亡也使大卫成熟了许多。大哥曼恩死的时候，我虽然被那集的表现手法给震撼住了，对大哥的死感觉有点遗憾，但其实大哥的死也是有伏笔的，我只是遗憾大哥没能克服过去。瑞贝卡的死也差不多，在我的感觉里她在战斗里一直都有一点不要命的打法，哪天真寄了也不奇怪。\n那么我为什么会对大卫的死感到这么难过呢？照例说，有着那么多flag，我应该会觉得理所应当的才对。\n后来看了泛式的杂谈回才明白过来，其实是Lucy这个“未亡人”的设定，如果最后大卫和Lucy双双赴死，并且最后两人牵手看着月光，这样的话对我来说悲剧的氛围就会减弱，因为我会觉得这是某种意义上的“Wish Granted”，但事实上并没有。两个人的心愿在最后都没有达成。大卫做到了保护Lucy，也用最后一次任务的金钱让Lucy上了月球，但是他在第4集赏月时许诺的“我会带你到月球去”却是实实在在地落空了\nLucy想去月球的愿望其实是源自于怕被荒坂找到的恐惧，所以在遇见大卫之前会想去一个远离所有纷争的，平静的地方。但在遇见大卫之后，一些事情改变了，她有了对她来说十分重要的人，并不是像以前那样无牵无挂。她的愿望也逐渐成“去月球”变成了“和大卫一起去月球”。\n而最后，两人的愿望都落空了，我个人认为，正是这份落差是让很多人意难平，感到后劲很大的主要原因\n表现手法 我觉得《边缘行者》的人物塑造是非常成功的，短短几集就把主角团的所有角色塑造得十分丰满。追寻梦想的恋人，可靠的大哥大嫂，有点可爱的疯批美人等等。\nCyberPunk这个词在动画里被描述成了一群人的身份名称，在秩序边缘游走，也在精神边缘游走，在无情的社会中努力反抗，苟活的一群人，叫做CyberPunk。\n因此 EdgeRunner 就是在跟这些赛跑。整个标题，都可以算作是第六集神回的伏笔。\n在第六集里，过量的义体压垮了曼恩，行动失败，团队分离崩析，暴恐机动队突入的瞬间，在被Sanevistan压缩的时间里，大卫以痛苦的慢放目睹了大哥的死相，在母亲死后跟着团队行动堆叠起来的安全感跟着大哥的精神一起倒塌，配乐则选取了游戏中FM96.1广播中出现的《Zurawie》，歌曲中的嘶吼仿佛代替了大卫发出疯狂和绝望的嘶吼\n没有人能逃过，曼恩不能，大卫也不行。\n瑞贝卡的整活也阻止不了故事也从这里开始调性下沉。大卫成长成了独当一面的团队领袖，全身逼近极限的义体化让他也走上了曼恩的末路，从一开始他就被企业盯上当作棋子，最后能做的也室友拯救爱人，在彻底失去自我前赴死。\n很多人以靠近朋克的方式去理解赛博朋克，其根源是抗争性，强调叛逆和反叛精神，对抗主流价值观等。从这个角度看，大卫只身一人救下露西，对抗亚当重锤，并在最后为了Lucy的梦想安然接受死亡的终局，确实是一件十分“朋克”的事。\n关于Lucy Lucy应该算是近几年的动画作品中我最喜欢的女主了，不仅仅是因为她是那种 “看着坏坏的，能带你摆脱无聊日常” 的女孩，还因为她在动画里体现出来的聪慧与机警，扳机社是真的将这个人物塑造的很好。\n很少有这么强大、聪明、理性、浪漫，美丽的女主角。精致的脸，高挑的身材。低饱和度的粉色\u0026amp;冰蓝色拼接短发，霓虹瞳色。下眼睑和下嘴唇的纹印，将它和诸多动漫中脸型类似的漂亮女主区别开来。\n在前期，Lucy的存在可以说是较为神秘的，无法看透她在想什么。\n当所有夜之城的居民，都为夜之城的繁华与物质而疯狂，为了成为传说的大人物而费尽心机。她的双眼中只有对这种狂热的疲劳与厌倦，\n她抓着男孩的病床在川流不息的马路上驰骋，那一刻，男孩眼里闪过了霓虹灯光。\n她将男孩带入自己的月球，她将自己的哀愁自己的防备留在夜之城的夜晚，而在月球上露出她内心毫不掩饰的喜悦。\n她摆在身后的手做出可爱的手势，她抓住男孩的手一起在月球上飞跃。\nLucy前期的这种撩人大姐姐型、似乎能把你的一切都能看透的神秘人设我觉得是十分吸引人的。\n很多人说Lucy后期变成了恋爱脑妹妹，但我的观点与之相左。我认为Lucy至始至终都是一个独立自强的女性，前期做任务时，她能用高分子线救队友于水火，能在任务里发挥自己的贡献。\n即使在很多人说的“呜呜大卫”的后期，Lucy也是凭自己的力量把觊觎大卫的人给清除的，是因为这个时候大卫对她而言十分重要，将为心爱之人毅然做出行动的行为也单纯地归入“恋爱脑妹妹”的评价，我个人是认为不太准确的。\nLucy的人设至始至终应该都没有崩的，她不同于传统的“塔斯给得”，“多西哟”型女主，她始终都会以行动来达成自己的目标，她的成熟，聪慧，帅气还带一点可爱的内在是比好看的身材更加吸引我的地方。\n突然想起上一次这么喜欢的女主还是石头门的克里斯蒂娜 也许我就是喜欢大姐姐吧\n动画之外 游改影视作品这个领域以往很少出佳作，不过近两年似乎出现了黎明。去年的《双城之战》是一封拳头写给玩家的情书，今年的《边缘行者》也将2077的在线人数有了回到往日繁荣的势头。\n不管2077的游戏多么残缺，其世界观和美术设定及任务安排仍是一流的水准，我很庆幸我是先玩过游戏再看的动画，它让我看懂这部动画中一些游戏彩蛋，也对这部作品的内核有了更深的理解。\n论设定，我觉得不如初看巨人前三季时带给我的震撼；论内核，我觉得比不上《来自深渊》；论原创，我觉得也许能刚好与去年的《奇巧计程车》打个平手（指表现力与讨论度等）。但为什么我单独在看完这部作品以后，会想着为其写一篇感想呢？\n我想，也许在因为学业压力而被迫暂时放弃游戏的现在，我的内心深处，仍然是那个Player吧。因此，会对游改动画有着一种别样的情感，也还会去圣地巡礼。\n结语 对我来说，“抗争”和“抗争失败后的无力”也是我喜欢《边缘行者》的原因之一。特别是最后Lucy在月球上时，面罩上倒映出大卫身影的那一刻，伴随着他们第一次上月球时的《I Really Want To Stay At Your House》，这时，我对这部动画的体验完整了。真挚的感情被巨型企业给吞没，大卫·马丁内斯如流星般闪耀而过，天空重新归于平静，只掀起数片水花。\n其中的阴郁有多么无力，绝望，而真实的爱又如何甜美，真挚，热烈。\n不同于《来自深渊》带给我的“温暖的黑暗”，《边缘行者》的故事更像是漆黑郊外夜景下突然出现的霓虹灯，美得有些不合时宜。\n因此，在美好破碎时，会让人感到疼痛。\n曼恩变成赛博精神病的时候见到自己在荒原上奔跑，之后是大卫，他跑的更快，跑的更远，现在轮到了Lucy。在这片一无所有又无穷无尽的荒原，到处都是路，亦或是到处都没有路，唯有死神，令一切化为乌有的死神，正在黑暗中以不可知的速度行进着，日日夜夜向这荒原中心的人奔来。\n动画之外，浪起之时，我也唯有奔跑。\n","date":"2022-10-10T10:04:36Z","image":"https://s1.ax1x.com/2022/10/10/xYgx5F.png","permalink":"https://inariindream.cn/blog/2022/10/10/cyberpunkedgerunner%E8%A2%AB%E6%89%B3%E6%9C%BA%E7%A4%BE%E5%94%A4%E5%9B%9E%E6%B4%BB%E5%8A%9B%E7%9A%84%E5%A4%9C%E4%B9%8B%E5%9F%8E/","title":"《Cyberpunk·Edgerunner》被扳机社唤回活力的夜之城"},{"content":" 扫描 题目描述 有一个 $1 \\times n$ 的矩阵，有 $n$ 个整数。\n现在给你一个可以盖住连续 $k$ 个数的木板。\n一开始木板盖住了矩阵的第 $1 \\sim k$ 个数，每次将木板向右移动一个单位，直到右端与第 $n$ 个数重合。\n每次移动前输出被覆盖住的数字中最大的数是多少。\n输入格式 第一行两个整数 $n,k$，表示共有 $n$ 个数，木板可以盖住 $k$ 个数。\n第二行 $n$ 个整数，表示矩阵中的元素。\n输出格式 共 $n - k + 1$ 行，每行一个整数。\n第 $i$ 行表示第 $i \\sim i + k - 1$ 个数中最大值是多少。\n样例 #1 样例输入 #1 5 3 1 5 3 4 2 样例输出 #1 5 5 4 提示 对于 $20%$ 的数据，$1 \\leq k \\leq n \\leq 10^3$。\n对于 $50%$ 的数据，$1 \\leq k \\leq n \\leq 10^4$。\n对于 $100%$ 的数据，$1 \\leq k \\leq n \\leq 2 \\times 10^6$，矩阵中的元素大小不超过 $10^4$ 并且均为正整数。\n思路 定义一个大根堆，里边放一对数，这个数的大小和位置。\n我们对于每次查询，判断首元素的位置是否在[i-k+1,i]这个范围内，不符合的话就弹出来。\n代码 priority_queue\u0026lt;pii,vector\u0026lt;pii\u0026gt;\u0026gt;q; void solve(){ int n, k; cin \u0026gt;\u0026gt; n \u0026gt;\u0026gt; k; vector\u0026lt;int\u0026gt; a(n); for (int i = 0; i \u0026lt; n; i++) { cin \u0026gt;\u0026gt; a[i]; } for (int i = 0; i \u0026lt; n; i++) { q.push({a[i], i + 1}); if (i + 1 \u0026gt;= k) { while (q.top().second \u0026lt;= i + 1 - k) { q.pop(); } cout \u0026lt;\u0026lt; q.top().first \u0026lt;\u0026lt; endl; } } } 求m区间内的最小值 题目描述 一个含有 $n$ 项的数列，求出每一项前的 $m$ 个数到它这个区间内的最小值。若前面的数不足 $m$ 项则从第 $1$ 个数开始，若前面没有数则输出 $0$。\n输入格式 第一行两个整数，分别表示 $n$，$m$。\n第二行，$n$ 个正整数，为所给定的数列 $a_i$。\n输出格式 $n$ 行，每行一个整数，第 $i$ 个数为序列中 $a_i$ 之前 $m$ 个数的最小值。\n样例 #1 样例输入 #1 6 2 7 8 1 4 3 2 样例输出 #1 0 7 7 1 1 3 提示 对于 $100%$ 的数据，保证 $1\\le m\\le n\\le2\\times10^6$，$1\\le a_i\\le3\\times10^7$。\n","date":"2022-08-04T11:31:31Z","image":"https://s1.ax1x.com/2022/04/30/LzHLHf.jpg","permalink":"https://inariindream.cn/blog/2022/08/04/%E6%B4%9B%E8%B0%B7%E4%B8%93%E9%A2%98%E8%AE%B0%E5%BD%95%E4%BC%98%E5%85%88%E9%98%9F%E5%88%97/","title":"洛谷专题记录（优先队列）"},{"content":" 一些备用的rss源\nhttp://rsshub.sksren.com/ https://rsshub.170601.xyz/ http://rss.5ux.net/ https://rss.injahow.cn/ https://rss.feiyuyu.net/ https://rsshub.uneasy.win/ https://rss.shab.fun/ http://selectivedog.com/ https://rsshub.zsliang.me/ https://rsshub.rssforever.com/ https://rss.shab.fun/ https://rss.injahow.cn/ http://i.scnu.edu.cn/sub http://rsshub.sksren.com/ https://rsshub-7x3pyolbs.vercel.app/ rsshub.uneasy.win rsshub.rssforever.com ","date":"2022-05-26T10:16:47Z","permalink":"https://inariindream.cn/blog/2022/05/26/rss%E5%A4%87%E7%94%A8%E6%BA%90/","title":"RSS备用源"},{"content":" Ubuntu20.04美化篇 像之前说过的，用Linux的起因是看到了很炫酷的桌面，在问了之后发现Ubuntu也能用deepin的dde桌面，甚至还找到了一篇教程。但是后来感觉有点大兴土木了（不是\n于是就打算只换个主题先用着看看，然后发现找的一堆教程都早已过了时效性了，有些功能早就挪了位置。所以此篇博客也只以文章发布时间后一段时间有时效性。期间在第一遍快完成的时候还把系统搞坏过一次，重启的时候开不了机一直在左上角闪横杠（其实应该是电脑的硬盘问题），重装了一次系统。然后还重来了一遍（悲\n操作步骤 1. 前置准备 先执行如下下载命令（可能有些命令不是必须的但我忘了）\nsudo apt update sudo apt-get update sudo apt install gnome-tweaks sudo apt install chrome-gnome-shell //这条非常重要 sudo apt install gnome-tweaks-extension 这个时候打开应用能搜索到Tweaks了（中文版应该叫优化）\n但打开后会发现是这样的（版本号不同可能大同小异）\n重点是Shell前面有个三角形，而我们换主题主要依赖的就是这个选项，因此这个时候需要登陆插件网站下载插件来将这个三角形去掉。\n打开gnome扩展网站：https://extensions.gnome.org/\n刚打开就会看到这样的提示让你下载浏览器插件\n重点来了，当时在这个地方栽了半天没想明白为什么，直接跳过了，也是第一遍失败的直接原因\n这个地方装插件用默认的Firefox是不行的！！！\n必须要换Chrome，再点击下载插件（访问谷歌插件商店的方式请自行发挥）\n2. 安装gnome扩展 访问：https://extensions.gnome.org/extension/19/user-themes/\n下载用户主题插件，或在上一步的页面搜索user-themes\n将按钮打开成ON\n如果用火狐的话会看见右边的画面\n3. 下载主题 访问gnome主题网站：https://www.gnome-look.org/\n选择一个自己喜欢的主题\n这里以WhiteSur Gtk为例\n点第一个下载即可\n配套的图标下载在这里\n下载方式相同\n4. 应用主题 默认的读取主题路径是/usr/share/themes\n默认的读取图标路径是/usr/share/icons\n这里注意，直接解压然后将文件夹复制粘贴过去是没有权限的\n所以直接一步到位解压文件到/usr/share/themes文件夹：\nsudo tar -xvJf ~/Downloads/WhiteSurDark.tar.xz -C /usr/share/themes 或将解压后的文件\nsudo cp -r+“空格”+~/你要复制的文件的原目录/你要复制的文件+“空格”+/usr/目标目录 然后更改这两项即可\n然后再在插件应用商店寻找更改任务栏的插件，博主电脑使用dash to dock会有bug，遂放弃而改用dock from dash\n在一次唤醒之后你可能会发现有两个dock，解决办法：\n卸载系统自带的Dock，命令如下：\nsudo apt remove gnome-shell-extension-ubuntu-dock 如果以后需要重新使用原生dock，安装命令如下：\nsudo apt install gnome-shell-extension-ubuntu-dock 然后就大功告成了\n配置鼠标光标 Cursor的操作大同小异，文件夹同样在icons里\n5. 配置登陆背景 下载ubuntu-20.04-change-gdm-background文件： wget https://raw.githubusercontent.com/thiggy01/change-gdm-background/master/change-gdm-background 出现443... failed: Connection refused.错误的解决方案：https://blog.csdn.net/m0_52650517/article/details/119831630\n给change-gdm-background文件执行的权限： sudo chmod 777 change-gdm-background 修改背景图片： sudo ./change-gdm-background /usr/share/backgrounds/Nick_Wilde_and_Judy_Hopps.jpg 其中/usr/share/backgrounds/Nick_Wilde_and_Judy_Hopps.jpg为背景图片所在路径。\n屏蔽紫色过渡动画： 对于登录系统的紫色过渡动画，就是输入密码回车，到进入系统这个过程的紫色动画，可以通过 gnome 的扩展进行屏蔽，名字是Good Bye GDM3 Login Screen to Desktop Flick for Ubuntu 20.04 only 地址为 https://extensions.gnome.org/extension/3037/good-bye-gdm-flick/。 ","date":"2022-05-18T22:04:44Z","image":"https://s1.ax1x.com/2022/05/18/O7Q4JO.jpg","permalink":"https://inariindream.cn/blog/2022/05/18/%E4%BF%9D%E5%A7%86%E7%BA%A7%E7%9A%84ubuntu20.04%E7%BE%8E%E5%8C%96/","title":"保姆级的Ubuntu20.04美化"},{"content":" 从零开始的Ubuntu安装（Hyper-V虚拟机篇） [TOC]\n其实我是先装的虚拟机再装的实机的，但是装完实机之后趁记忆比较深刻先写了上一篇实机的，但其实虚拟机还要简单一点。而用Hyper—V一键装机就更是极简了。\n安装步骤 确保系统是 Windows 10 专业版/企业版/教育版，且必须是64位操作系统才支持。\n如果不是那可以退出了，Win10家庭版不支持hyper-v。\n打开启动或关闭Windows功能\n将Hyper—V下属的两项都给勾上\n若第二项勾选不上则需要重启进入bios界面，不同型号的电脑进入方式不同，微星是按del，华硕是F2（其他的没用过建议自行使用搜索引擎） 进入bios后以微星主板amdcpu为例 依次点击\n然后重启电脑 此时应该可以将两项都勾选上了。 3. 完成后需要稍等一段时间，然后重启电脑； 4. 重启之后，点击“开始”，“所有程序”，点击“windows管理工具”然后就可以看到“Hyper-V”\n点击进入，便可根据自己的喜好一键装机了\n（保姆级服务\n","date":"2022-05-18T13:15:21Z","image":"https://s1.ax1x.com/2022/05/17/O4vPHS.png","permalink":"https://inariindream.cn/blog/2022/05/18/%E4%BB%8E%E9%9B%B6%E5%BC%80%E5%A7%8B%E7%9A%84ubuntu%E5%AE%89%E8%A3%85hyper-v%E8%99%9A%E6%8B%9F%E6%9C%BA%E7%AF%87/","title":"从零开始的Ubuntu安装（Hyper-V虚拟机篇）"},{"content":" 从零开始的Ubuntu安装（实机篇） [TOC]\n写在前面 想装Linux的原因最早是在空间看到派派发了一个Archlinux 的 deepin 桌面环境，感觉很炫酷且简洁，然后刚好自己有多的一台备用笔记本可以用来折腾，遂也想搞一个来钻研技术和提升逼格\n然后昨天在响哥手把手的教学下在虚拟机上面装好了Ubuntu，并且把镜像刻进了U盘里面，今天下午就进行了愉快的装机之旅了。\n在找教程的时候发现了一个对新手十分友好的教程，但是是英文的，有一定阅读门槛，还是先贴在这吧\nhttps://itsfoss.com/install-ubuntu-1404-dual-boot-mode-windows-8-81-uefi/\n由于在安装的时候没想到截图或拍照，所以部分步骤图用网图代替\n安装准备 一块空的8G以上的U盘（传输速度越快越好） 一台电脑\n众所周知，安装系统一般是需要系统光盘的，或者像大白菜那样的系统商业U盘，但是其实有个软件是能将镜像os直接烧录到U盘里面的，名字叫Rufus\n镜像的下载可以在国内的科大镜像站下载\n选中最新版下载\n注意一般浏览器下载目录默认在C盘的Downloads下，Ubuntu的镜像文件较大，下载前注意查看C盘剩余空间\n然后下好之后就可以开始烧录在U盘里了\n烧录之前一定注意U盘里原来的东西是否已备份，烧录过程会将U盘清空\n引导类型选择镜像文件，然后选择刚刚下载好的镜像文件\n分区类型的话老电脑一般选择GPT，比较新一点的可以选择MBR 到时候发现不对回来重新烧一遍吧\n然后就开始等待烧录，时间根据U盘性能不同而不同\n烧完之后就可以拔出U盘，这个时候准备工作就做完了。\n安装步骤 打开需要安装的电脑，在开机时候进入bios界面。不同品牌的电脑进入方式各不相同，例如微星的电脑普遍是狂按del进入，华硕的电脑是F2（同一品牌不同型号的电脑也可能会有一定差异，建议百度一下自己的电脑型号）\n在Security里面将 Secure Boot改为disabled\n在boot里面将Boot Mode改为 UEFI\n（我的华硕笔记本当时好像只用把UEFI Boot的选项改为True就行了，不是按这两步来的）\n之后保存并退出。\n插入烧录好的U盘，开机狂按F2（华硕），选择从什么硬盘启动，这个时候要选择自己插入U盘的型号（注意，不是U盘在电脑里自己改的名称，是型号）例如我选择了Kingston Traveler 2.0\nEnter之后又来到一个选择界面，选择最上面那项（我的是Try or install Ubuntu）\n然后稍等片刻即可进入安装\n进入Ubuntu界面后选择Install Ubuntu\n语言选择部分略过，按照自己的喜好来\n如果原来电脑上有Win10系统的话，可以选择Install Ubuntu alongside Win10，之后只用在开机的时候选择想进的系统即可。\n选择时区\n设置账户名和密码\n开始安装即可\n大功告成 安装完成之后重启即可\n开始愉快的Ubuntu探索之旅吧\n","date":"2022-05-17T15:52:08Z","image":"https://s1.ax1x.com/2022/05/26/XECXcR.jpg","permalink":"https://inariindream.cn/blog/2022/05/17/%E4%BB%8E%E9%9B%B6%E5%BC%80%E5%A7%8B%E7%9A%84ubuntu%E5%AE%89%E8%A3%85%E5%AE%9E%E6%9C%BA%E7%AF%87/","title":"从零开始的Ubuntu安装（实机篇）"},{"content":"最大子段和 题目描述 给出一个长度为 $n$ 的序列 $a$，选出其中连续且非空的一段使得这段和最大。\n思路 简单的前缀和 + 递推，用$a[i]$记录到第$i$个位置时与$i$相连续的最大值，用$ans$记录字段和的最大值\n转移方程a[i] = max(x, a[i - 1] + x)， ans = max(a[i], ans)\n代码 void solve(){ int n; cin \u0026gt;\u0026gt; n; vector\u0026lt;int\u0026gt;a(n); int ans = -INF; int x; for (int i = 0; i \u0026lt; n; i++) { cin \u0026gt;\u0026gt; x; if (i == 0){ a[i] = x; } else{ a[i] = max(x, a[i - 1] + x); ans = max(a[i], ans); } } cout \u0026lt;\u0026lt; ans \u0026lt;\u0026lt; endl; } 地毯 题目描述 在 $n\\times n$ 的格子上有 $m$ 个地毯。\n给出这些地毯的信息，问每个点被多少个地毯覆盖。\n输入格式 第一行，两个正整数 $n,m$。意义如题所述。\n接下来$m$ 行，每行两个坐标 $(x_1,y_1)$ 和 $(x_2,y_2)$，代表一块地毯，左上角是 $(x_1,y_1)$，右下角是 $(x_2,y_2)$。\n输出格式 输出 $n$ 行，每行 $n$ 个正整数。\n第 $i$ 行第 $j$ 列的正整数表示 $(i,j)$ 这个格子被多少个地毯覆盖。\n$n, m \\leqslant 1000$\n思路 差分\n复习 何为差分 假设我们现在要给[2,5]这个区间加一。\n原来的序列是： 0 0 0 0 0 0 0 0\n这时候我们在2上面打 +1 标记， 6 上面打 -1 标记。\n那么现在的序列是： 0 +1 0 0 0 -1 0\n这样的话，从左往右扫描这个数组，记录当前经过的标签之和，这个和就是那个数对应的答案\n这样，对于每个区间加操作，只需要$O(1)$的时间打上标记， 最后扫描输出即可\n现在把问题拓展到二维。假设我们要覆盖$[(2,2),(5,5)]$ ，那么标记便可以这样打：\n0 +1 0 0 0 -1 0 +1 0 0 0 -1 0 +1 0 0 0 -1 0 +1 0 0 0 -1 0 0 0 0 0 0 即在每一行都按照一维的方式来操作：\nfor (int j = x1; j \u0026lt;= x2; j++) { cf[j][y1]++; cf[j][y2 + 1]--; } 这样一来,打标记时候的复杂度为$O(n)$,总复杂度为$O(mn + n^2)$\n代码 int cf[2000][2000]; void solve(){ int n, m; cin \u0026gt;\u0026gt; n \u0026gt;\u0026gt; m; int x1, y1, x2, y2; for (int i = 0; i \u0026lt; m; i++) { cin \u0026gt;\u0026gt; x1 \u0026gt;\u0026gt; y1 \u0026gt;\u0026gt; x2 \u0026gt;\u0026gt; y2; for (int j = x1; j \u0026lt;= x2; j++) { cf[j][y1]++; cf[j][y2 + 1]--; } } for (int i = 1; i \u0026lt;= n; i++) { for (int j = 1; j \u0026lt;= n; j++) { cf[i][j] += cf[i][j - 1]; cout \u0026lt;\u0026lt; cf[i][j] \u0026lt;\u0026lt; \u0026#34; \u0026#34;; } cout \u0026lt;\u0026lt; endl; } } 海底高铁 题目描述 一个铁路经过$N$个城市，每个城市一个站，但不能直达，只能相邻城市的一段铁路单独买票\n对于一段铁路$i$，连接了城市$i$和城市$i+ 1$，有两种买票方式。\n单独购买纸质票，价格为$A_i$\n买卡，只需要花工本费$C_i$，每次通行花费$B_i（B_i \u0026lt; A_i )$\n现在一个人要出差去$M$个城市，按照$P_i$的顺序访问，可能会多次访问一个城市，且相邻访问的城市位置不一定相邻，而且不会是同一个城市。\n求总费用的最小值\n$M，N \\leqslant 10^5, A_i,B_i,C_i \\leqslant 10 ^ 5$\n思路 前缀和和差分数组结合， 对于其中一小段，我们要么全部买纸票，要么全部刷卡。\n所以问题拆分成了统计每一小段经过的总次数，再在两种费用方案之间取最小值\n后者不难，此题的考点在前者，直接暴力统计会绎演顶证，鉴定为纯纯的$TLE$\n因此先用差分数组预处理每次要去的起点和终点，打上标记。\n然后再求每一项的前缀和，这样最后前缀和数组就是每一段铁路的经过次数了\n例：如果我们要经过$1-3$ 和 $2-4$\n先打上标记\n+1 -1 +1 +1 -1 -1 - - - - - -- - - -- - -- -- - -- -- 1 2 3 4 5 1 2 3 4 5 1 2 3 4 5 图1 图2 图3 再进行前缀和\n1 2 2 1 0 - - - - - 1 2 3 4 5 图4 更多细节见代码\n代码 void solve(){ int n, m; cin \u0026gt;\u0026gt; n \u0026gt;\u0026gt; m; vector\u0026lt;ll\u0026gt;p(n + 2);//station vector\u0026lt;ll\u0026gt;cnt(n + 2);//count for (int i = 1; i \u0026lt;= m; i++) { cin \u0026gt;\u0026gt; p[i]; } ll ma, mi; for (int i = 1; i \u0026lt;= m - 1; i++) { ma = max(p[i], p[i + 1]); mi = min(p[i], p[i + 1]); cnt[ma]--;//因为第i段铁路是从第i连到第i+1个城市，所以减去ma就是减去第ma-1 +1段铁路 cnt[mi]++; } for (int i = 1; i \u0026lt;= n; i++) {//WA了一发，开始的range是[1,m] cnt[i] += cnt[i - 1];//这就是为什么前缀和处理的话数组下标要从1开始 } int a, b, c; ll ans = 0; for (int i = 1; i \u0026lt;= n - 1; i++) { cin \u0026gt;\u0026gt; a \u0026gt;\u0026gt; b \u0026gt;\u0026gt; c; ans += min(a * cnt[i], b * cnt[i] + c); } cout \u0026lt;\u0026lt; ans \u0026lt;\u0026lt; endl; } 最大加权矩形 题目描述 一个$N \\times N$的矩阵，矩阵里每个点有对应的权值，求子矩阵权值和的最大值\n$N \\leqslant 120$\n思路 一眼二维前缀和，数据范围很小，直接用$O(n^4)$的复杂度莽过去了。\n但二维前缀和的公式还是不熟\n二维矩阵的前缀和（到0，0点的）:\n$$f[i][j] = f[i][j - 1] + f[i -1][j] - f[i - 1][j - 1] + a[i][j]$$ 子矩阵的和从$(i，j)$到$(k，l)$ $O(n^4)$： $$f[k][l] - f[k][j - 1] - f[i - 1][l] + f[i - 1][j - 1]$$\n代码 （$O(n^4)$） int a[125][125], f[125][125]; void solve(){ int n; cin \u0026gt;\u0026gt; n; for (int i = 1; i \u0026lt;= n; i++) { for (int j = 1; j \u0026lt;= n; j++) { cin \u0026gt;\u0026gt; a[i][j]; f[i][j] = f[i][j - 1] + f[i -1][j] - f[i - 1][j - 1] + a[i][j]; } } int ans = -INF; for (int i = 1; i \u0026lt;= n; i++) { for (int j = 1; j \u0026lt;= n; j++) { for (int l = i; l \u0026lt;= n; l++) { for (int i1 = j; i1 \u0026lt;= n; i1++) { ans = max(f[l][i1] - f[l][j - 1] - f[i - 1][i1] + f[i - 1][j - 1], ans); } } } } cout \u0026lt;\u0026lt; ans \u0026lt;\u0026lt; endl; } 优化版 思路 我们可以考虑将矩形压缩成一维，比如处理一个2行的矩形时，将a [ i ][ j ]与a [ i - 1 ][ j ]相加，成为一个新的数组f [ n ]，再使用上述代码进行动态规划，找出局部最优解。\n首先进行前缀和，这样可以用减法来快速表示压缩的矩形。\n可以模拟一下，a[ i ][ j ] - a[ i - k ][ j ]正好是以i为最下面一行，往上k行的压缩结果，这就很方便地表示了压缩后的矩形。\n那再次循环，运用第一个代码的简单变形，可以求出以i为最下一行，向上k行的矩形最大值，多次更新ans就行\n代码 void solve2(){ int n; cin \u0026gt;\u0026gt; n; for (int i = 1; i \u0026lt;= n; i++) { for (int j = 1; j \u0026lt;= n; j++) { cin \u0026gt;\u0026gt; a[i][j]; a[i][j] += a[i - 1][j]; // 前缀和处理 } } int ans = -INF; int f1[150] = {0}, dp[150] = {0}; for (int i = 1; i \u0026lt;= n; i++) { for (int k = 1; k \u0026lt;= i; k++) { for (int j = 1; j \u0026lt;= n; j++) { f1[j] = a[i][j] - a[i - k][j]; dp[j] = max(dp[j - 1] + f1[j], f1[j]); ans = max(ans, dp[j]); } } } cout \u0026lt;\u0026lt; ans \u0026lt;\u0026lt; endl; } 这是前一种方法的速度 这是后一种的 可以看出来优化还是十分明显的\n领地选择 题目描述 首都被认为是一个占地 $C \\times C$ 的正方形。小 Z 希望你寻找到一个合适的位置，使得首都所占领的位置的土地价值和最高。\n思路 与上一题的第一种方法类似，使用二位前缀和预处理，然后$O(n^2)$扫一遍即可\n代码 int a[1005][1005]; int f[1005][1005]; void solve(){ int n, m, c; cin \u0026gt;\u0026gt; n \u0026gt;\u0026gt; m \u0026gt;\u0026gt; c; int ma = -INF; for (int i = 1; i \u0026lt;= n; i++) { for (int j = 1; j \u0026lt;= m; j++) { cin \u0026gt;\u0026gt; a[i][j]; f[i][j] = f[i][j - 1] + f[i - 1][j] - f[i - 1][j - 1] + a[i][j]; } } int x, y; for (int i = c; i \u0026lt;= n; i++) { for (int j = c; j \u0026lt;= m; j++) { if (f[i][j] - f[i][j - c] - f[i - c][j] + f[i - c][j - c] \u0026gt; ma){ ma = f[i][j] - f[i][j - c] - f[i - c][j] + f[i - c][j - c]; x = i - c + 1; y = j - c + 1; } } } cout \u0026lt;\u0026lt; x \u0026lt;\u0026lt; \u0026#34; \u0026#34; \u0026lt;\u0026lt; y \u0026lt;\u0026lt; endl; } 光骓者的荣耀 题目描述 小 K 为了关心人民生活，决定定期进行走访。他每一次会从 $1$ 号城市到 $n$ 号城市并在经过的城市进行访问。其中终点必须为城市 $n$。\n不仅如此，他还有一个传送器，传送半径为 $k$，也就是可以传送到 $i-k$ 和 $i+k$。如果目标城市编号小于 $1$ 则为 $1$，大于 $n$ 则为 $n$。\n但是他的传送器电量不足，只能传送一次，况且由于一些原因，他想尽量快的完成访问，于是就想问交通部部长您最快的时间是多少。\n思路 先前缀和预处理，然后以区间大小为$k$扫一遍求传送的最大值即可\n（92分坑）：在求区间和最大值的时候，下标不要从1开始，因为cnt[i + k] - cnt[i]如果从1开始的话会忽略cnt[1]本身的值\n代码 void solve(){ int n, k; cin \u0026gt;\u0026gt; n \u0026gt;\u0026gt; k; vector\u0026lt;ll\u0026gt;a(n); vector\u0026lt;ll\u0026gt;cnt(n); for (int i = 1; i \u0026lt; n; i++) { cin \u0026gt;\u0026gt; a[i]; } partial_sum(all(a),cnt.begin()); ll ans = -1; for (int i = 0; i \u0026lt; n - k; i++) { ans = max(ans, cnt[i + k] - cnt[i]); } cout \u0026lt;\u0026lt; cnt[n - 1] - ans \u0026lt;\u0026lt; endl; } ","date":"2022-04-30T13:15:13Z","image":"https://s1.ax1x.com/2022/04/30/LzHLHf.jpg","permalink":"https://inariindream.cn/blog/2022/04/30/%E6%B4%9B%E8%B0%B7%E4%B8%93%E9%A2%98%E8%AE%B0%E5%BD%95%E5%89%8D%E7%BC%80%E5%92%8C%E4%B8%8E%E5%B7%AE%E5%88%86/","title":"洛谷专题记录（前缀和与差分）"},{"content":"4.22 （待补） 题目链接\n题解链接\n描述 给定两个队列$a$,$b$，每队$n$人，身高分别为$a_i$, $b_i$\n每队的人都可以与前后相邻者交换位置，次数不限，仅在同队换，问使$\\sum (a_i - b_i)^2$最小的交换次数\n思路 两队同时换和只换一队效果相同，因此只需选一队来换。\n$\\sum (a_i - b_i)^2 = \\sum((a_i + b_i)^2 - 4 * a_i * b_i)$\n前者是定值，因此只需找到使后面那项最大的方式即可\n就是求一个数列相对于另一个的逆序对（好像某次abc做过，但后来没补题\u0026hellip;）\n代码（copy的） const int mod = 1e8 - 7; long long n, x[10000005], p[1000005], ans = 0; struct fire { int hi, bh; } l1[1000005], l2[1000005]; bool cmp1(fire a, fire b) { return a.hi \u0026lt; b.hi; } void msort(int s, int t)//归并排序; { if (s == t)return; int mid = (s + t) / 2; msort(s, mid); msort(mid + 1, t); int i = s, k = s, j = mid + 1; while (i \u0026lt;= mid \u0026amp;\u0026amp; j \u0026lt;= t) { if (x[i] \u0026lt;= x[j]) { p[k] = x[i]; ++k; ++i; } else { p[k] = x[j]; ++k; ++j; ans = (ans + mid - i + 1) % mod; //此处找到逆序对，mid-i~mid中数全都与j构成逆序，还会少算一个，+1; } } while (i \u0026lt;= mid) { p[k] = x[i]; ++k; ++i; } while (j \u0026lt;= t) { p[k] = x[j]; ++k; ++j; } for (int i = s; i \u0026lt;= t; i++) { x[i] = p[i]; } } int main() { scanf(\u0026#34;%lld\u0026#34;, \u0026amp;n); for (int i = 1; i \u0026lt;= n; i++) scanf(\u0026#34;%d\u0026#34;, \u0026amp;l1[i].hi), l1[i].bh = i; for (int i = 1; i \u0026lt;= n; i++) scanf(\u0026#34;%d\u0026#34;, \u0026amp;l2[i].hi), l2[i].bh = i; sort(l1 + 1, l1 + n + 1, cmp1); sort(l2 + 1, l2 + n + 1, cmp1); //排序; for (int i = 1; i \u0026lt;= n; i++) x[l2[i].bh] = l1[i].bh; msort(1, n); //调用归并; printf(\u0026#34;%lld\u0026#34;, ans); return 0; } 4.23 (BFS板题) 题目链接\n题目描述 给出一个 N 个顶点 M 条边的无向无权图。\n问从顶点 1 开始，到其他每个点的最短路有几条。\n思路 BFS板题，每次遍历的时候记录层数，如果当前遍历到的$x$节点是$t$节点的下一层，那么$x$的最短路数量就是当前$x$的最短路数量加上$t$的最短路数量\n因为每次遍历到的时候都会加一遍，就相当于乘法了\n代码 const int N = 1e6 + 5; const int mod = 100003; vector\u0026lt;int\u0026gt;e[N]; int used[N]; int cnt[N]; int dep[N]; void bfs(){ queue\u0026lt;int\u0026gt;q; dep[1] = 0; used[1] = 1; q.push(1), cnt[1] = 1; while (!q.empty()){ int t = q.front(); q.pop(); for (auto x : e[t]) { if (!used[x]){ used[x] = 1;//标记为遍历过了 dep[x] = dep[t] + 1;//层数++(因为是bfs所以层数一定是最小的) q.push(x); } if (dep[x] == dep[t] + 1){//如果当前x是t的下一层 cnt[x] = (cnt[x] + cnt[t]) % mod;//那么x的最短路数量再加上t的最短路数量(每个x都加相当于乘) } } } } void solve(){ int n, m; cin \u0026gt;\u0026gt; n \u0026gt;\u0026gt; m; for (int i = 0; i \u0026lt; m; i++) { int x , y; cin \u0026gt;\u0026gt; x \u0026gt;\u0026gt; y; e[x].push_back(y); e[y].push_back(x); } bfs(); for (int i = 1; i \u0026lt;= n; i++) { cout \u0026lt;\u0026lt; cnt[i] \u0026lt;\u0026lt; endl; } } int main(){ ios::sync_with_stdio(false); cin.tie(nullptr); solve(); return 0; } 4.26 题目链接 描述 判断有没有一种办法可以将从$1$ 到 $N$ 的 $N$个人排成一排，并满足给定的$M$个要求。\n对于每个要求给出两个整数 $A_i$和$B_i$，表示编号$A_i$和$B_i$的人是相邻的\n保证每个要求都不同，即给出$1$，$5$就不会再给出$5$，$1$或重复的\n分析 满足题目要求的只有无环的链\n即判断两件事：\n1.度数是否大于等于$2$\n2.是否有环\n代码 const int N = 1e5 + 5; int father[N]; int ufind(int x) {//寻找操作 if (x == father[x]) return x; int fx = ufind(father[x]); return father[x] = fx; } void solve() { int n, m; cin \u0026gt;\u0026gt; n \u0026gt;\u0026gt; m; for (int i = 0; i \u0026lt;= n; i++) { father[i] = i; } map\u0026lt;int, int\u0026gt; mp; int ok = (n \u0026gt; m); // 这一点最开始没想到，如果要求大于n - 1条可以直接返回 if (!ok) { cout \u0026lt;\u0026lt; \u0026#34;No\u0026#34; \u0026lt;\u0026lt; endl; return; } int x, y; for (int i = 0; ok \u0026amp;\u0026amp; i \u0026lt; m; i++) { cin \u0026gt;\u0026gt; x \u0026gt;\u0026gt; y; mp[x]++; mp[y]++; int fx = ufind(x); int fy = ufind(y); if (fx != fy) { father[fx] = y; } ok = (fx != fy); // 判断是否指向同一个（也包括判断环） if (mp[x] \u0026gt; 2 || mp[y] \u0026gt; 2) // 判断度数 ok = 0; } cout \u0026lt;\u0026lt; (ok ? \u0026#34;Yes\u0026#34; : \u0026#34;No\u0026#34;) \u0026lt;\u0026lt; endl; } int main() { ios::sync_with_stdio(false); cin.tie(nullptr); solve(); return 0; } 好像能默写并查集中“并”的部分了= =\n查的部分好像还是只能抄板子 菜菜QWQ\n（突然发现图论的部分涉及的不多\n4.27 题目链接 描述 现给定两个 四位素数 a,b。 你可以执行多次下面的操作：\n修改数字 a 的某一位, 使其成为另一个 四位素数。\n例如，1033→1733，其中 1033 与 1733 均为素数。\n问至少多少次变换后能从 a 得到 b ? 或回答不可能\n思路 想到了和cf某场的2B很像，只不过那场不需要按位处理，而是加1或加2后取余，做法是BFS。那这题也一样，但开始没想到怎么去枚举每一位的数字的变化，甚至想用to_string()来做，后来发现取每一位取模后除就行了\u0026hellip;是C语言期末考试难度的题\u0026hellip;\n提醒自己多注意细节问题，多个$testcase$的时候一定要将全局变量清空！！！\n更多细节见代码\n代码 int prime[10000], used[10000]; int cnt[10000]; void init(){ int j; for (int i = 1000; i \u0026lt;= 10000; i++) { for (j = 2; j \u0026lt; i; j++) { if (i % j == 0){ prime[i] = 0; break; } } if (j == i){ prime[i] = 1; } } } int bfs(int x, int y){ for (int i = 1000; i \u0026lt; 10000; i++) { // 因为忘清空WA了一次 cnt[i] = 0; used[i] = 0; } queue\u0026lt;int\u0026gt;q; int temp = 0, v[4]; q.push(x); used[x] = 1; cnt[x] = 0; while (!q.empty()){ int t = q.front(); if (t == y) return cnt[t]; q.pop(); v[0] = t / 1000; v[1] = t % 1000 / 100; v[2] = t % 100 / 10; v[3] = t % 10; for (int i = 0; i \u0026lt; 4; i++) { int vtemp = v[i]; for (int j = 0; j \u0026lt; 10; j++) { if (j != vtemp){ v[i] = j; temp = 1000 * v[0] + 100 * v[1] + 10 * v[2] + v[3]; if (prime[temp] \u0026amp;\u0026amp; !used[temp]){ q.push(temp); used[temp] = 1; cnt[temp] = cnt[t] + 1; } // if (temp == y) // return cnt[temp];后来发现这步完全是多余的，因为如果是第一次到的话cnt应该是没值的 } v[i] = vtemp; // 写的时候遗漏了这一步，在进入下一个i的循环之前要将上一次的v[i]复原 } } } return -1; // 前面都没return这里只能return -1了 } void solve(){ int n; cin \u0026gt;\u0026gt; n; init(); int a, b; while (n--){ cin \u0026gt;\u0026gt; a \u0026gt;\u0026gt; b; cout \u0026lt;\u0026lt; bfs(a, b) \u0026lt;\u0026lt; endl; } } 这种简单题以后争取十分钟以内切吧（\n4.28 题目链接 描述 给定一个$H$行和$W$列的网格，我们让$(i,j)$表示从北边第i行和从西边第j列的网格\n在一个网格上修建一个火车站的代价是$A_{i,j}$\n在两个网格间建一条铁轨的代价是这两个点位置的曼哈顿距离\n求造一条铁路的最小花费\n思路 基本拿到手就是懵的，知道要用dp去做，但是完全没思路，看了题解视频好像是dp + 二维前缀和的思想去做。抄了份代码过了之后看了贴两份代码吧，之后再补（\n（4.29补）： 看懂思路了，分为两种情况考虑：\n第二个点的$x$和$y$均大于第一个点，此时向第二个点的左上方扫 第一个点只有$x$大于第二个点，此时向第二个点的右上方扫 当然，在二维数组里面往斜上方硬扫应该是会超时的，复杂度应该是$O(n^2m^2)$\n所以在第一次扫的时候要利用类似二维前缀和的思想去处理（其实感觉dp思想多一点，但是dls题解说是前缀和）\n对于第一种情况，$ans$拆开来的结果是\n$$A_{x2y2} + C \\times (x_2 + y_2) + A_{x1y1} - C \\times (x_1 + y_1)$$\n当第二个点确定以后，问题就转化成求$A_{x1y1} - C \\times (x_1 + y_1)$的最小值了，用$f[i][j]$去记录左上方的这个式子的最小值\n可得转移方程为f[i][j] = min(f[i-1][j],f[i][j-1])\n然后进行答案的更新ans = min(ans,f[i][j] + a[i][j] + c * (i + j))（注：$f[i][j]$是不包含$a[i][j]$的）\n最后，已经在$a[i][j]$更新过$ans$了，那就可以把$a[i][j]$算进去了f[i][j] = min(a[i][j] - c * (i + j),f[i][j])\n第二种情况往右上扫思路相同，略。\n代码（copy） /*** 第一份 ***/ const int N = 1005; ll a[N][N],b[N],d[N]; void solve() { for (ll i = 0; i \u0026lt; N; i++) b[i] = d[i] = 1e18; ll n, m, c; ll ans = 1e18; cin \u0026gt;\u0026gt; n \u0026gt;\u0026gt; m \u0026gt;\u0026gt; c; for (ll i = 1; i \u0026lt;= n; i++) { for (ll j = m; j \u0026gt;= 0; j--) d[j] = min(d[j], d[j + 1]); for (ll j = 1; j \u0026lt;= m; j++) { cin \u0026gt;\u0026gt; a[i][j]; b[j] = min(b[j], b[j - 1]); d[j] = min(d[j], d[j + 1]); ans = min(ans, b[j] + a[i][j] + c * i + c * j); ans = min(ans, d[j] + a[i][j] + c * i - c * j); b[j] = min(b[j], a[i][j] - c * i - c * j); d[j] = min(d[j], a[i][j] - c * i + c * j); } } cout \u0026lt;\u0026lt; ans; } /*** 第二份（好像还有注释 太良心了） ***/ const int N = 1100 ; int n,m ; int a[N][N] ; ll f[N][N],c ; // 其实就是找到两个点，这两个点的 C * (| x1 - x2 | + | y1 - y2 |) + a_x1_y1 + a_x2_y2 // 为了让这个值更小，我们可以使用常用的技巧将这个式子拆开 // 拆开之后看看 值有没有改变 // 发现两个点的位置会有四种关系，，如果定义一种偏序关系，那么我们就可以设定为2种关系 // 1. 第一个点完全在第二个点的下面，就是说，第一个点的 x1 和 y1 分别小于 x2，y2 // 那么拆开式子之后就是 a_x1_y1 + C * (x2 - x1 + y2 - y1) + a_x2_y2 // a_x2_y2 + C * (x2 + y2) + a_x1_y_1 - C * (x1 + y1) ; // 为了让这个式子最小值，那么当固定了x2，那么就需要求出1这个点的 a_x1_y_1 - C * (x1 + y1) 最小值 // 如果让第一个点的 x 永远大于第二个点 // a_x1_y1 + a_x2_y2 + C * ( x1 - x2 + y2 - y1) ; // a_x2_y2 + C * (-x2 + y2) + a_x1_y1 + c * (x1 - y1) ; int main(){ scanf(\u0026#34;%d%d%lld\u0026#34;,\u0026amp;n,\u0026amp;m,\u0026amp;c) ; for(int i = 1 ;i \u0026lt;= n ; i ++) for(int j = 1; j \u0026lt;= m ; j ++) scanf(\u0026#34;%d\u0026#34;,\u0026amp;a[i][j]) ; ll ans = 1e18 ; memset(f,0x3f,sizeof f) ; for(int i = 1; i \u0026lt;= n ; i ++){ for(int j = 1; j \u0026lt;= m ; j ++){ f[i][j] = min(f[i-1][j],f[i][j-1]) ; //cout \u0026lt;\u0026lt; i \u0026lt;\u0026lt; \u0026#34; \u0026#34; \u0026lt;\u0026lt; j \u0026lt;\u0026lt; \u0026#34; \u0026#34; \u0026lt;\u0026lt; f[i][j] + a[i][j] + c * (i + j) \u0026lt;\u0026lt; \u0026#34;\\n\u0026#34; ; ans = min(ans,f[i][j] + a[i][j] + c * (i + j)) ; f[i][j] = min(a[i][j] - c * (i + j),f[i][j]) ; } } memset(f,0x3f,sizeof f) ; for(int i = 1 ; i \u0026lt;= n ; i++){ for(int j = m ; j \u0026gt;= 1 ;j --){ f[i][j] = min(f[i-1][j],f[i][j+1]) ; //cout \u0026lt;\u0026lt; i \u0026lt;\u0026lt; \u0026#34; \u0026#34; \u0026lt;\u0026lt; j \u0026lt;\u0026lt; \u0026#34; \u0026#34; \u0026lt;\u0026lt; f[i][j] \u0026lt;\u0026lt; \u0026#34; \u0026#34; \u0026lt;\u0026lt; a[i][j] + c * (j - i) \u0026lt;\u0026lt; \u0026#34;\\n\u0026#34; ; ans = min(ans,f[i][j] + a[i][j] + c * (i - j)) ; f[i][j] = min(a[i][j] + c * (j - i),f[i][j]) ; } } printf(\u0026#34;%lld\\n\u0026#34;,ans); return 0 ; } 4.29 题目链接 描述 桌子上从左到右放着 $n$ 个糖果。糖果从左到右编号，第 $i$ 块糖果的重量为 $w_i$。小明和小红要吃糖果。\n小明从左边开始吃任意数量的糖果。（连续吃，不能跳过糖果）\n小红从右边开始吃任意数量的糖果。（连续吃，不能跳过糖果）\n当然，如果小明吃了某个糖果，小红就不能吃它（反之亦然）。\n他们的目标是吃同样重量的糖果，请问此时他们总共最多能吃多少个糖果？\n思路 div4的F题原题，方法是双指针，当两个指针没合到一起时分三种情况讨论：\n当小明当前吃的重量小于小红，那么小明吃一颗，且指针向右移动一位\n小红小于小明，小红吃一颗，指针左移一位\n二人相等，则此时更新$ans$，$ans = max(ans, l + 1 + n - r)$\n代码 void solve(){ int n; cin \u0026gt;\u0026gt; n; vector\u0026lt;int\u0026gt;a(n); for (int i = 0; i \u0026lt; n; i++) { cin \u0026gt;\u0026gt; a[i]; } int l = -1, r = n; ll al = 0, bo = 0; int ans = 0; while (l \u0026lt; r){ if (al \u0026lt; bo){ l++; al += a[l]; } else if (al \u0026gt; bo){ r--; bo += a[r]; } else{ ans = max(ans, l + 1 + n - r); l++; al +=a[l]; } } cout \u0026lt;\u0026lt; ans \u0026lt;\u0026lt; endl; } 光速下班\n4.30 题目链接 描述 有一个长度为 $∑a_i$ 的木板，需要切割成 $n$ 段，每段木板的长度分别为 $a_1,a_2,…,a_n$。\n每次切割，会产生大小为被切割木板长度的开销。\n请你求出将此木板切割成如上 $n$ 段的最小开销。\n思路 倒着考虑，每次切割会产生大小为被切割木板长度的开销 $==$ 每次合并产生合并后长度的开销\n那么此时这个题就变成了非常经典的二叉堆的题目了 且一月份做过原\n用优先队列，复杂度是$O(nlogn)$\n优先队列还是没怎么用过，多练练吧\n代码 void solve(){ int n; cin \u0026gt;\u0026gt; n; priority_queue\u0026lt;ll,vector\u0026lt;ll\u0026gt;,greater\u0026lt;ll\u0026gt;\u0026gt;q; for (int i = 0; i \u0026lt; n; i++) { int x; cin \u0026gt;\u0026gt; x; q.push(x); } ll ans = 0; while (q.size() \u0026gt; 1){ ll t1 = q.top(); q.pop(); ll t2 = q.top(); q.pop(); q.push(t1 + t2); ans += t1 + t2; } cout \u0026lt;\u0026lt; ans \u0026lt;\u0026lt; endl; } 光速下班\n拓展 题意完全一样，只是$n$的范围由$10^5$增加至$10^7$，$a_i$仍为$10^5$\n思路 回到问题的本质，很容易想到就是排序然后选最小两堆，再把最小的那一堆插入。\n但是对于$10^7$的数据，$O(nlogn)$的插入复杂度显然是不可接受的\n那就需要优化插入操作的复杂度了，且将初始化的排序优化为桶排序（因为$a_i$只有$10^5$）\n做法是建立两个队列，将桶排的结果放进第一个队列$Q_1$，将合并的结果放进第二个队列$Q_2$，每次取两个队列的最小值合并\n(其实就是把合并的结果单独放在一个队列里面，这样就不用插入了)\n复杂度为$O(n)$\n代码 int cnt[100005]; queue\u0026lt;ll\u0026gt;q1; queue\u0026lt;ll\u0026gt;q2; ll temp; ll get_first(){ if (q2.empty() || (!q1.empty() \u0026amp;\u0026amp; q1.front() \u0026lt; q2.front())){ temp = q1.front(); q1.pop(); return temp; } else{ temp = q2.front(); q2.pop(); return temp; } } void solve(){ int n, x; cin \u0026gt;\u0026gt; n; for (int i = 0; i \u0026lt; n; i++) { cin \u0026gt;\u0026gt; x; cnt[x]++;//准备桶排 } for (int i = 0; i \u0026lt;= 100000; i++) {//WA了一发才发现最开始没挂等号... while (cnt[i]--) q1.push(i); //还是得多注意细心，第一次这个地方写成push(x)找了半天没发现 } ll ans = 0; ll a, b; while (q1.size() + q2.size() \u0026gt; 1){ a = get_first(); b = get_first(); q2.push(a + b); ans += a + b; } cout \u0026lt;\u0026lt; ans \u0026lt;\u0026lt; endl; } int main(){ ios::sync_with_stdio(false); cin.tie(nullptr); solve(); return 0; } 在洛谷原题被卡常数卡傻了，吸氧都过不去，571ms都不能过？？？\n5.1 （待补） 题目链接 描述 给定一个长度为$n$的数组$a_1,a_2,\u0026hellip;,a_n$。请求出下面式子模$1e9+7$的值。\n$$\\sum_{i = 1}^{n - 1}\\sum_{j = i + 1}^{n}(a_i XOR a_j)$$\n思路 待补\n代码（copy） const int mod = 1e9 + 7; int s[2][61]; void solve(){ int n; cin \u0026gt;\u0026gt; n; ll ans = 0; ll x; for (int i = 0; i \u0026lt; n; i++) { cin \u0026gt;\u0026gt; x; for (int j = 59; j \u0026gt;= 0; j--) { ll t = x \u0026gt;\u0026gt; j \u0026amp; 1; ans = (ans + s[t ^ 1][j] * ((1ll \u0026lt;\u0026lt; j) % mod)) % mod; s[t][j]++; } } cout \u0026lt;\u0026lt; ans \u0026lt;\u0026lt; endl; } 5.2 题目链接 描述 输入正整数$k$，找到所有正整数$y\\leqslant x$，使得$\\dfrac{1}{k} = \\dfrac{1}{x} + \\dfrac{1}{y}$’\n$k \\leqslant 10^7$\n思路 看到数据范围就知道肯定不可能$n^2$枚举，只能用$O(n)$扫一遍\n通过推公式化简得： $$x = \\dfrac{k \\times y}{y - k}$$\n而y有一个隐藏条件：因为$y\\leqslant x$，所以当y等于x的时候能取到最大值，而此时$x=y=2\\times k$\n所以$y$的范围就限定在了$（k \u0026lt; y \\leqslant 2\\times k）$\n因此只需要枚举每一个$y$，再判断$x$是否合法就行了\n需要注意的细节：\n1. 推出公式得到的$k \\times y$在$1e7$的时候会爆int\n2. 最好能不用double就不用double，判断是否为整数除了用（int）还可以分子对分母取模\n3. $y$的范围是从$k + 1$开始，如果从$k$开始会出现模$0$的状况而退出程序（或返回任意值）\n其实这三点就是做这个简单题踩过的坑\u0026hellip;现在知道为什么蓝桥杯会输麻了\n代码 void solve(){ int k; cin \u0026gt;\u0026gt; k; ll y, cnt = 0; for(y = k + 1; y \u0026lt;= 2 * k; y++){ ll ok = (k * y) % (y - k); if (!ok) cnt++; } cout \u0026lt;\u0026lt; cnt \u0026lt;\u0026lt; endl; } 5.3 题目链接 描述 给出一个长度为$N$的数组$A$和一个数字$k$\n请问数组A中有多少个子数组，其元素和为$k$？\n$1≤N≤2×10^5 ，|A_i|≤10^9，|k|≤10^{15}$\n思路 首先看数据范围，因为有负数，所以双指针应该是不行的。\n看到区间和首先想到的就是前缀和，遍历一遍$a_i$，每次如果找到区间和为$k$的就$cnt$++\n但是如果直接硬扫的话是$O(n^2)$的，肯定不行，所以要换另一种查询的方法，可以选择set或者map（这个思想zj在某次div2B也说过）\n以map为例，满足条件的前缀和和当前前缀和必定差值为$k$，只需要$O(n)$扫一遍，用map统计前缀和的出现次数然后cnt+=mp[sum - k]即可\n还有就是记得mp[0]记得初始化为$1$\n代码 ll get_sum(vector\u0026lt;int\u0026gt;\u0026amp; nums, ll k){ ll res = 0, sum = 0; unordered_map\u0026lt;ll,int\u0026gt;mp; mp[0] = 1; for(auto num : nums){ sum += num;//用sum表示当前到当前数字的前缀和 if (mp[sum - k] \u0026gt; 0) res += mp[sum - k]; mp[sum]++; } return res; } void solve(){ int n; cin \u0026gt;\u0026gt; n; ll k; cin \u0026gt;\u0026gt; k; vector\u0026lt;int\u0026gt;a(n); for (int i = 0; i \u0026lt; n; i++) { cin \u0026gt;\u0026gt; a[i]; } cout \u0026lt;\u0026lt; get_sum(a, k) \u0026lt;\u0026lt; endl; } 5.4 题目链接 描述 对于每一个长度为 $n$ 的排列 $a$，我们都可以按照下面的两种方式将它建成一个图：\n1.对于每一个 $1≤i≤n$，找到一个最大的 $j$ 满足 $1≤j\u0026lt;i,a_j\u0026gt;a_i$，将 $i$ 和 $j$ 之间建一条无向边\n2.对于每一个 $1≤i≤n$，找到一个最小的 $j$ 满足 $i\u0026lt;j≤n,a_j\u0026gt;a_i$，将 $i$ 和 $j$ 之间建一条无向边\n注意：建立的边是在对应的下标 $i$,$j$ 之间建的边\n请问有多少种长度为 $n$ 的排列 $a$ 满足，建出来的图含环\n排列的数量可能会非常大，请输出它模上 $10^9+7$ 后的值\n$n\\leqslant 10 ^ 6$\n思路 题面比较谜语人，大概翻译过来的意思就是，要找到含环的图的情况。但这样还是有点抽象，于是就反过来想。\n去寻找不含环的边，那么在题意中，不含环的图是这样的：\n对于一个数，要么只在左边有比他大的，要么只在右边有比他大的\n而只有一类图满足这种情况\n说人话就是找以最大值为顶点的单峰的图有多少个\n把这种情况去掉的情况就是含环的情况了\n对$n$的全排列为$n!$,以最大值为顶点的单峰图有$2^{n - 1}$种情况（摆法）：对于除了最大值的$n-1$个数，按降序摆放。每次摆放的时候都有在最大值左边和最大值右边两种选择，因此为$2^{n - 1}$\n答案即为 $$n! - 2^{n - 1}$$\n更多细节见代码（主要是取模）\n代码 const int mod = 1e9 + 7; const int N = 1e6 + 1; ll f[N]; ll qmi(ll m, ll k, ll p){//求 m^k mod p，时间复杂度 O(logk) ll res = 1 % p, t = m; while (k){ if (k\u0026amp;1) res = res * t % p; t = t * t % p; k \u0026gt;\u0026gt;= 1; } return res; } void init(){//初始化处理阶乘数组 f[1] = f[0] = 1ll; for (ll i = 2; i \u0026lt;= N; i++) { f[i] = i * f[i - 1] % mod; } } void solve(){ ll n; cin \u0026gt;\u0026gt; n; ll ans = qmi(2ll, n - 1, mod); cout \u0026lt;\u0026lt; (f[n] + mod - ans) % mod \u0026lt;\u0026lt; endl; // 这个地方的 + mod 非常关键，防止负数，很多要取模的题都应注意 } int main(){ ios::sync_with_stdio(false); cin.tie(nullptr); int kase; cin \u0026gt;\u0026gt; kase; init(); while (kase--) { solve(); } return 0; } 其实不太用得到快速幂，主要是在每次阶乘或平方的时候都要取模\n不过刚好换个更好的快速幂板子了吧（\n5.5 （待补） 题目链接 描述 给定$n$个点和$n-1$条路，镇从 $1$ 到 $n$ 依次编号，每条双向道路连接两个不同的村镇。接下来请你回答 $q$ 个问题，每次给出两个整数 $c, d$，表示现在分别有一个人在村镇 $c$,一个人在村镇 $d$，现在在 $c$ 的人要用最短的时间到达村镇$d$，在村镇 d 的人要以最短的时间到达村镇 $c$，假设两人同时出发，两人的速度也是一样的，每条双向道路的长度也是一样的，请问两人相遇的时候是在某一个村镇，还是在某条双向道路上？\n$2≤n≤100000$\n$1≤q≤100000$\n对于每一个询问 $1 ≤ c_i \u0026lt; d_i ≤ n$\n思路 这题拿到手最开始想的是就是一个简单的无向图求最短路然后判断奇偶，写了个BFS过了样例，自信满满交了一发，结果在第一个点就T飞了。\n重新读了一遍题才发现询问次数$q$是$1e5$的，这样的话无论是BFS还是Dijkstra跑一趟都会超时，因为在每次询问的时候都要memset距离数组和used数组一次（后发现是自己BFS套板子套的太笨了，一样有人用BFS过了）\n后在dls的建议下用LCA，因为$n-1$条路的话是树。套了个二月底写div1每日一题的LCA板子过了，但是还是晕晕乎乎的，有时间一定补!（顺便把代码用vector重构一下）\n看了别人的代码才发现发现BFS是完全能做的，因为完全没有必要去求两点间的最短路，可以直接预处理根节点到每个节点的距离，再求距离差的奇偶性即可，这样也只需要一次memset了。\n代码 const int N = 200005; struct node{ int t, next; }edge[2*N]; int a[N], head[N], tot, sum[N], depth[N], father[N][20]; void add(int x, int y){ edge[++tot].t = y; edge[tot].next = head[x]; head[x] = tot; } void dfs(int u, int p){ sum[u] = sum[p] + a[u]; depth[u] = depth[p] + 1; father[u][0] = p; for (int j = 1; j \u0026lt; 19; j++) { father[u][j] = father[father[u][j - 1]][j - 1]; } for (int i = head[u]; i ; i = edge[i].next) { int v = edge[i].t; if (v == p) continue; else if (v != p){ father[v][0] = u; dfs(v, u); } } } int LCA(int x, int y){ if (depth[x] \u0026lt; depth[y]) swap(x,y); for (int i = 18; i \u0026gt;= 0; i--) { if (depth[father[x][i]] \u0026gt;= depth[y]) x = father[x][i]; } if (x == y) return x; for (int i = 18; i \u0026gt;= 0; i--) { if (father[x][i] != father[y][i]) { x = father[x][i]; y = father[y][i]; } } return father[x][0]; } void solve(){ int n, m; cin \u0026gt;\u0026gt; n \u0026gt;\u0026gt; m; for (int i = 1; i \u0026lt;= n; i++) { a[i] = 1; } for (int i = 1, u, v; i \u0026lt; n; i++) { cin \u0026gt;\u0026gt; u \u0026gt;\u0026gt; v; add(u,v); add(v,u); } dfs(1,0); for (int i = 1; i \u0026lt;= m; i++) { int u, v; cin \u0026gt;\u0026gt; u \u0026gt;\u0026gt; v; cout \u0026lt;\u0026lt; ( (sum[u] + sum[v] - 2 * a[LCA(u, v)] )% 2 ? \u0026#34;Road\u0026#34; : \u0026#34;Town\u0026#34;) \u0026lt;\u0026lt; endl; } } /* --------------------------------- BFS过法 ---------------------------------*/ const int N = 1e5 + 5; vector\u0026lt;int\u0026gt;e[N]; int dis[N]; void bfs(){ memset(dis, -1, sizeof(dis)); dis[1] = 0; queue\u0026lt;int\u0026gt;q; q.push(1); while (!q.empty()){ int t = q.front(); q.pop(); for(auto i : e[t]){ if(dis[i] == -1){ dis[i] = dis[t] + 1; q.push(i); } } } } void solve(){ int n, m; cin \u0026gt;\u0026gt; n \u0026gt;\u0026gt; m; for (int i = 0; i \u0026lt; n - 1; i++){ int x, y; cin \u0026gt;\u0026gt; x \u0026gt;\u0026gt; y; e[x].push_back(y); e[y].push_back(x); } bfs(); int a, b; while (m--) { cin \u0026gt;\u0026gt; a \u0026gt;\u0026gt; b; cout \u0026lt;\u0026lt; ((abs(dis[a] - dis[b]) \u0026amp; 1) ? \u0026#34;Road\u0026#34; : \u0026#34;Town\u0026#34;) \u0026lt;\u0026lt; endl; } } 5.6 （代码待补） 题目链接 描述 现在给出一个表达式，形如 $a_1/a_2/a_3/\u0026hellip;/a_n$。\n如果直接计算，就是一个个除过去，比如 $1/2/1/4=1/8$。\n然而小 A 看到一个分数感觉很不舒服，希望通过添加一些括号使其变成一个整数。一种可行的办法是 $(1/2)/(1/4)=2$。\n现在给出这个表达式，求问是否可以通过添加一些括号改变运算顺序使其成为一个整数\n$2≤n≤10000,1≤t≤100,1≤ai≤2^{31}−1$\n思路 因为$a_2$前面的除号不能变成乘号，所以贪心的想，把后面除的数越变越小，再让$a_2$去除，才能得到最优解，因此用括号将$a_2$后面的括起来，即\n$$a_1 / (a_2 / (a_3 / a_4\u0026hellip;./a_n)) = a_1 \\times a_3 \\times\u0026hellip;\\times a_n / a_2 $$\n这样的话就找每个数和$a_2$的gcd，只要有一个不是1就行\n代码（copy） void solve(){ int n; cin \u0026gt;\u0026gt; n; if (n == 1) { puts(\u0026#34;Yes\u0026#34;); return; } vector\u0026lt;int\u0026gt;a(n); for (int i = 0; i \u0026lt; n; i++) { cin \u0026gt;\u0026gt; a[i]; } int temp = gcd(a[0], a[1]); a[1] /= temp; temp = a[1]; for (int i = 2; i \u0026lt; n; i++) { if (temp \u0026gt; 1) temp /= gcd(temp, a[i]); } cout \u0026lt;\u0026lt; (temp == 1 ? \u0026#34;Yes\u0026#34; : \u0026#34;No\u0026#34;) \u0026lt;\u0026lt; endl; } 5.7 （待补） 题目链接 描述 有一棵 $n$ 个节点的以1为根的有根树。现在可以对这棵树进行若干次操作，每一次操作可以选择树上的一个点然后删掉这个点和它的儿子之间的所有边。\n现在想要知道对于每一个 $k∈[1,n]$，最少需要多少次操作才能让图中恰好存在 $k$ 个联通块。\n输入格式 第一行输入一个正整数 $n$。\n第二行输入 $n−1$ 个整数 $f_i$ 表示 $i+1$ 号点的父亲，保证 $1≤fi≤i$。\n输出格式 输出 $n$ 个整数，第 $i$ 个数表示 $k=i$ 时的答案，如果无法让图中恰好存在 $k$ 个联通块，则输出$-1$。\n思路 每减去一个节点，产生的联通块的数量就是该节点的孩子数量。 所以， 实质上是一道单重背包问题的变形。\n代码（copy） const int MAXN = 3005; int n, max_x, root[MAXN], dp[MAXN]; void DP(){ for (int i = max_x; i \u0026gt;= 1; --i) { if (root[i] != 0) { for (int j = n; j \u0026gt;= root[i]; --j) { if (dp[j - root[i]] != 0) { if (dp[j] != 0) { dp[j] = min(dp[j], dp[j - root[i]] + 1); } else { dp[j] = dp[j - root[i]] + 1; } } } } } } void solve() { int x; cin \u0026gt;\u0026gt; n; max_x = 0; for (int i = 1; i \u0026lt; n; ++i) { cin \u0026gt;\u0026gt; x; root[x]++; if (max_x \u0026lt; x) { max_x = x; } } dp[0] = 1; DP(); for (int i = 0; i \u0026lt; n; ++i) { if (dp[i]) { cout \u0026lt;\u0026lt; dp[i] - 1 \u0026lt;\u0026lt; \u0026#34; \u0026#34;; } else { cout \u0026lt;\u0026lt; -1 \u0026lt;\u0026lt; \u0026#34; \u0026#34;; } } printf(\u0026#34;\\n\u0026#34;); } 5.8 题目链接 描述 有一个长度为$n$的序列，现在我们想把它切割成三段(每一段都是连续的），使得每一段的元素总和都相同，请问有多少种不同的切割方法\n思路 前缀和处理数组，从前往后扫一遍。切割成相同且连续的三段的话必然每个方案的切点都有$\\dfrac{sum}{3}$和$\\dfrac{2\\times sum}{3}$且前者一定在右者的左边，这样一来，只需要记录三分之一处的数量，然后在每次遇见三分之二处的时候加上到目前为止的左端点的数量即可。\n注意在$n$处不能当右端点。\n代码 ll l, r, x, cnt = 0; void solve(){ int n; cin \u0026gt;\u0026gt; n; vector\u0026lt;ll\u0026gt;a(n + 1); for (int i = 1; i \u0026lt;= n; i++) { cin \u0026gt;\u0026gt; x; a[i] = a[i - 1] + x; } if (a[n] % 3){ cout \u0026lt;\u0026lt; 0 \u0026lt;\u0026lt; endl; return; } l = a[n] / 3; r = 2 * l; x = 0; for (int i = 1; i \u0026lt;= n; i++) { if (a[i] == r \u0026amp;\u0026amp; i \u0026lt; n) cnt += x; if (a[i] == l) x++; } cout \u0026lt;\u0026lt; cnt \u0026lt;\u0026lt; endl; } 5.9 题目链接 描述 给定整数 $n$，想将$1∼n$这$n$个数字分成两组，每一组至少有一个数，并且使得两组数字的和的最大公约数最大，请输出最大的最大公约数。\n$n≤10^9$\n思路 将$n$个数的和设为$sum$，每次分组，就是分为$x$和$sum-x$，题意即求$gcd(x,sum - x)$的最大值。\n再次转化问题，即求$sum$最少能分成多少份，求此时让份数最小的$x$\n代码 void solve(){ ll n; cin \u0026gt;\u0026gt; n; ll sum; sum = (n + 1) * n / 2; for (ll i = 2; i * i \u0026lt;= sum; i++) { if (sum % i == 0) { cout \u0026lt;\u0026lt; sum / i \u0026lt;\u0026lt; endl; break; } } } 5.10 题目链接 描述 给定一个长度为 $n$ 数组 $A$，执行以下操作 $m$ 次：\n​ 选择一段区间 $[l,r]$，将区间中所有的数加上整数 $x$。\n​ 操作完成后回答 $k$ 个问题：\n​ 每个问题给定一段区间 $[l,r]$，输出区间中所有数的和。\n$1≤n≤2×10^5，1≤m,k≤10^5，|x|≤10^5$\n思路 一眼差分加前缀和，不过这里注意要多用一个差分数组来记录，而不能直接在原数组上打标记，因为之后要进行前缀和操作。\n时间复杂度为$O(n)$\n代码 void solve(){ int n, m, k; cin \u0026gt;\u0026gt; n \u0026gt;\u0026gt; m \u0026gt;\u0026gt; k; vector\u0026lt;ll\u0026gt;a(n + 1); vector\u0026lt;int\u0026gt;d(n + 1); vector\u0026lt;ll\u0026gt;s(n + 1); for (int i = 1; i \u0026lt;= n; i++) { cin \u0026gt;\u0026gt; a[i]; } for (int i = 1; i \u0026lt;= n; i++) { d[i] = a[i] - a[i - 1]; } while (m--){ int l, r, x; cin \u0026gt;\u0026gt; l \u0026gt;\u0026gt; r \u0026gt;\u0026gt; x; d[l] += x; d[r + 1] -= x; } for (int i = 1; i \u0026lt;= n; i++) { a[i] = a[i - 1] + d[i]; s[i] = a[i]; s[i] += s[i - 1]; } while (k--){ int l, r; cin \u0026gt;\u0026gt; l \u0026gt;\u0026gt; r; cout \u0026lt;\u0026lt; s[r] - s[l - 1] \u0026lt;\u0026lt; endl; } } 经典忘开LL然后WA了一发\n看到个神仙做法，贴一下\nsigned main() { read(n);read(m);read(k); for(int i=1;i\u0026lt;=n;++i) read(a[i]); adjacent_difference(a+1, a+n+1, a+1); while(m){ read(l); read(r); read(x); a[l] += x; a[r+1] -= x; --m; } partial_sum(a+1, a+n+1, a+1); partial_sum(a+1, a+n+1, a+1); while(k){ read(l); read(r); printf(\u0026#34;%lld\\n\u0026#34;,a[r]-a[l-1]); --k; } return 0; } 看懂了adjacent_difference和partial_sum后写了个带注释版的\nvoid solve2(){ int n, m, k; cin \u0026gt;\u0026gt; n \u0026gt;\u0026gt; m \u0026gt;\u0026gt; k; vector\u0026lt;ll\u0026gt;a(n + 1); for (int i = 1; i \u0026lt;= n; i++) { cin \u0026gt;\u0026gt; a[i]; } adjacent_difference(a.begin() + 1, a.end(), a.begin() + 1);//将原数组变为差分数组 int l, r, x; while (m--){ cin \u0026gt;\u0026gt; l \u0026gt;\u0026gt; r \u0026gt;\u0026gt; x; a[l] += x; a[r + 1] -= x;//在差分数组里面进行区间修改 } partial_sum(a.begin() + 1, a.end(), a.begin() + 1);//将差分数组还原为原数组（后一项加前一项） partial_sum(a.begin() + 1, a.end(), a.begin() + 1);//将原数组变化为前缀和 while (k--){ cin \u0026gt;\u0026gt; l \u0026gt;\u0026gt; r; cout \u0026lt;\u0026lt; a[r] - a[l - 1] \u0026lt;\u0026lt; endl; } } 5.11 题目链接 描述 有一个 $01$ 序列，每次可以对其中的某一位取反（$0$变$1$，$1$变$0$）\n求最少翻转其中的几位可以使得该序列变为非递减序列\n思路 不能相信这个题我昨天居然没看出来。。。最开始想的是找第一个$1$后面的$0$，每两个一组，数数就完了。\n然后寄得很彻底，然后开摆了 然后甚至也没复习模电去看剧了\n正确思路是找到$0$和$1$的分界点，分界点前面有$0$必须全是$0$，后面有$1$必须全是$1$。所以要分别找前面的$1$的数量和后面的$0$的数量。\n用$a_i$记录到$i$点的前缀和，此分界点需要修改的数量为\n$$a[i] + n - i - (a[n] - a[i])$$\n扫一遍找最小值即可，复杂度是$O(n)$的\n代码 void solve() { int n; cin \u0026gt;\u0026gt; n; string s; cin \u0026gt;\u0026gt; s; vector\u0026lt;int\u0026gt;a(n + 1); for (int i = 1; i \u0026lt;= n; i++) { a[i] = a[i - 1] + s[i - 1] - \u0026#39;0\u0026#39;; } int ans = INF; for (int i = 0; i \u0026lt;= n; i++) { ans = min(ans, a[i] + n - i - a[n] + a[i]); } cout \u0026lt;\u0026lt; ans \u0026lt;\u0026lt; endl; } 感觉就是个div2A的题，已经是个废人了\u0026hellip;\n5.12 （待补） 题目链接 描述 约翰是一个农场主，他的农场有$n$块田，编号从 $1$到 $n$，这 $n$块田通过 $m$条双向道路相连（数据保证这$n$块田都是联通的），我们假设第$i$块田会产生 $2^i$$kg$ 的收益，现在约翰想把农田的工作全部交给自己的两个孩子，划分方式必须满足以下规则:\n1.每一块田都需要恰好被分给一个孩子.\n2.分给两个孩子的农田必须是联通的.就是说对于任意一个孩子在划分给自己的任意一块田，都可以不经过另外一个孩子的田，到达自己的任意一块田.\n3.划分给两个孩子的收益必须尽可能的相等，如果无法相等，年长的孩子会得到大的那一份.\n对于第 $i$块田，如果你要把它分给年长的孩子，请输出$A$,否则输出$B$.\n$2≤n≤3e5,1≤m≤3e5$\n思路 并查集\n代码（copy） class DSU{ vector\u0026lt;int\u0026gt; fa, sz; public: explicit DSU(int n ) : fa(n), sz(n){ iota(all(fa),0); fill(all(sz),1); } int find(int i){ return i == fa[i] ? i : (fa[i] = find(fa[i])); } void join(int i, int j){ int a = find(i), b = find(j); if (a == b) return; if (a \u0026gt; b) swap(a, b); fa[b] = a, sz[a] += sz[b]; } int size(int i){ return sz[i]; } }; void solve(){ int n, m; cin \u0026gt;\u0026gt; n \u0026gt;\u0026gt; m; DSU dsu(n); while (m--){ int x, y; cin \u0026gt;\u0026gt; x \u0026gt;\u0026gt; y; x--,y--; if (x != n - 1 \u0026amp;\u0026amp; y != n - 1){ dsu.join(x, y); } } string ans (n, \u0026#39;A\u0026#39;); for (int i = 0; i \u0026lt; n - 1; i++) { if (dsu.find(i) == dsu.find(n - 2)) ans[i] = \u0026#39;B\u0026#39;; } cout \u0026lt;\u0026lt; ans \u0026lt;\u0026lt; endl; } 5.13 （待补） 题目链接 原题链接 描述 B 地区在地震过后，所有村庄都造成了一定的损毁，而这场地震却没对公路造成什么影响。但是在村庄重建好之前，所有与未重建完成的村庄的公路均无法通车。换句话说，只有连接着两个重建完成的村庄的公路才能通车，只能到达重建完成的村庄。\n给出 B 地区的村庄数 $N$，村庄编号从 $0$ 到 $N-1$，和所有 $M$ 条公路的长度，公路是双向的。并给出第 ii 个村庄重建完成的时间 $t_i$，你可以认为是同时开始重建并在第 $t_i$天重建完成，并且在当天即可通车。若 $t_i$为 $0$ 则说明地震未对此地区造成损坏，一开始就可以通车。之后有 $Q$ 个询问 $(x,y,t)$，对于每个询问你要回答在第 $t$ 天，从村庄 $x$ 到村庄 $y$ 的最短路径长度为多少。如果无法找到从 $X$ 村庄到 $y$ 村庄的路径，经过若干个已重建完成的村庄，或者村庄 $x$ 或村庄 $y$ 在第 $t$ 天仍未重建完成，则需要返回 -1\n思路 Floyd\n代码（Copy） #define N 205 int n,m; int a[N]; int f[N][N];//邻接矩阵存边 inline void updata(int k){ for(int i=0;i\u0026lt;n;i++) for(int j=0;j\u0026lt;n;j++) if(f[i][j]\u0026gt;f[i][k]+f[j][k]) f[i][j]=f[j][i]=f[i][k]+f[j][k];//用这个新的更新所有前面的 return; } int main(){ cin\u0026gt;\u0026gt;n\u0026gt;\u0026gt;m; for(int i=0;i\u0026lt;n;i++) scanf(\u0026#34;%d\u0026#34;,a+i);//依次输入每一个村庄建立完成时需要的时间 for(int i=0;i\u0026lt;n;i++) for(int j=0;j\u0026lt;n;j++){ f[i][j]=1e9;//初始化为保证它不爆炸范围内的最大值 } for(int i=0;i\u0026lt;n;i++) f[i][i]=0; int s1,s2,s3; for(int i=1;i\u0026lt;=m;i++){ scanf(\u0026#34;%d%d%d\u0026#34;,\u0026amp;s1,\u0026amp;s2,\u0026amp;s3); f[s1][s2]=f[s2][s1]=s3;//初始化边长 } int q; cin\u0026gt;\u0026gt;q; int now=0; for(int i=1;i\u0026lt;=q;i++){//处理各询问 scanf(\u0026#34;%d%d%d\u0026#34;,\u0026amp;s1,\u0026amp;s2,\u0026amp;s3); while(a[now]\u0026lt;=s3\u0026amp;\u0026amp;now\u0026lt;n){ updata(now);//依次更新点，使它可以被用来更新其他的点 now++; } if(a[s1]\u0026gt;s3||a[s2]\u0026gt;s3)cout\u0026lt;\u0026lt;-1\u0026lt;\u0026lt;endl; else { if(f[s1][s2]==1e9)cout\u0026lt;\u0026lt;-1\u0026lt;\u0026lt;endl; else cout\u0026lt;\u0026lt;f[s1][s2]\u0026lt;\u0026lt;endl; } } return 0; } ","date":"2022-04-23T11:56:46Z","image":"https://s1.ax1x.com/2022/04/27/Lqf2o8.png","permalink":"https://inariindream.cn/blog/2022/04/23/namomocamp%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98div2/","title":"NamomoCamp每日一题（div2）"},{"content":"2021对我来说十分匆忙与短暂，以至于我在最后一天才有闲暇，来回望过去的这一年。\n我想了很久，今年似乎很难用一句话或一个词来概括我过去十二个月的经历了。以五月底的插班生考试为分界线，我的2021的上下半年过得截然不同。\n贯穿我上半年的两个词应该是犹豫与遗憾。年初犹豫着是否要正式进入一段感情，四月初犹豫着是否要把考插的路坚持走完，也在插班生和课内绩点之间犹豫不决。最终，这些犹豫都变成了遗憾。\n插班生考试以一道证明大题的差距结束了我九个月的旅程，绩点以0.002的差距而错失了转入CS的机会。我只能给自己冠上“惜败”的名号聊以自慰。本来对未来有无穷的憧憬与计划，但变化总会挫败计划好的道路，使人怀疑按原有的计划是否还能走到理想的目的地，也会使人踌躇，究竟是该坚持还是放弃。\n关于考插的感想我在年中的时候已经写过，如果有现在也在这条路上感到迷茫的21级同学也可以去看看 : )\n我的生活似乎没什么变化，一点小小的梦想刚发芽就死去，不算什么大事，毕竟梦想的田野上，到处都是长眠的种子。但考完插班生之后的一段时间，我似乎进入了一种浑浑噩噩的状态。再也不必六点钟起床和考研人抢自习室了，再也不用对着竞赛题抓破脑袋了，再也不用看着手机上的倒数日期而焦虑了。我报复式地玩了两星期的怪猎和Apex。考完后一个月就是期末考试，但我似乎只是为了绩点而机械地复习着。就连暑假时的数模训练和icpc训练，也只是为了让自己不感到空虚的填充物而已。\n在仲夏时节，我听闻了几个同学复读出分的消息。在十二个月的努力之后，他们都获得了十分理想的结果。也有几个人来问过我“后悔没去复读吗”。我的回答跟问我“后悔考插吗”时候的回答相同: 我不后悔。如果重来一次的话，以现在的心智和阅历，还是会做出同样的选择。\n但是噩梦仍萦绕着我，树叶与飞鸟新旧轮替，夜晚却每夜如期而至。不只几个晚上，我都在想，如果在插班生考前看过柯西不等式的证明，如果我的工图画的再好一点点拉高绩点，那么现实会不会有那么一点点的不一样？\n在几个月后，因写论文需要，我翻看了尼采的《权力意志》，才知道那段时间的我，其实陷入了类似虚无主义的漩涡之中。他说:“虚无主义意味着最高价值的自行贬值。”\n当自己的需求可以被轻易代替时，那么以前有意义的事就会变得没有意义。仅仅是个人的主观给一个事物赋予意义，我需要它就有意义，若不需要，它存在的本身对我而言就是毫无意义。\n是我梦想中的将来想成为的那个自己，那个开阔，非凡，卓越和不凡的自己，成为了把我拉出虚无的救赎。我最终还是跟上半年的我和解。\n星宇低垂，旷野寥落，暮夏时节的银河分外清朗，也无比落寞。\n九月份开学后，还是很忙，繁重的课业似乎让我明白了为什么插班生只有大一能考（？\n我还是喜欢夜跑，还是习惯在跑完后抬头仰望寰宇，它如此辽阔。暮夏时分仍能看见夏日大三角，深秋之时猎户座依然清晰可见，就跟一年前我看到的时候没有区别。就跟上亿岁月前的它们没有区别。此时跑道和球场上还有挥洒汗水的人们，图书馆二楼应该有几张桌子围坐着小声讨论的小组成员，学院楼和泰山科研楼里应该仍旧灯火通明，马路沿边也许零散的分布着牵手散步的情侣，与我擦身而过的那个人可能是个内心十分丰富多彩的人，北广应该弥漫着勾魂的夜宵香味。不过，这些似乎都与我无关。每晚这时，也许也是我最与在赤壁下泛舟时的苏文忠先生心境最相近的时候。\n我忙于各种竞赛，还参加了学生组织，尽力让自己的生活变得充实。直到发现一个人的精力是无法在所有方面都做好的。几经挣扎，我最终还是选择退掉了一个科创队。（在这里向拉我进去的金康和莫指导说声对不起)最终我的目标还是定在了算法竞赛上，虽然我起步晚了点，再努力最终可能也就是个铜牌或者什么也没有，但我仍决定前往。也许这也是一种“罗曼罗兰式的英雄主义”吧（雾\n尼采其实也不是那么悲观的人，他还写过这样的话 “某天，你会邂逅高大的自己，不是平日里的自己，而是更清澈，更高级的自己。在那一瞬间，你会如受到恩宠一般察觉到高大自我的存在。”\n“请珍视那个瞬间。”\n后记:\n今年是我第二年给自己写年终总结了。相比去年，今年我的总结似乎字数少了点，没有了去年那么多浮华的词藻。或许是因为我意识到我不需要太多夸张的词汇去表述我的心情，或许是因为我经历的事情变少了一点，又或许只是单纯的因为我的读书数量没有去年多了（\n除去上面稍微有些沉重的部分，今年我的收获还是很多的。第一次在数学竞赛得奖，第一次跑完了十公里，第一次通宵后去看日出，第一次玩恐怖密室，第一次去猫咖，第一次参加数学建模，第一次打保龄球等等。这些点滴，也让我的今年显得没那么枯燥。\n我很高兴我把在年底写总结的习惯坚持了下来，像去年这时说过的那样，我也不希望内心丰富的情感在生活公式化的磨砺中消逝，因此我选择以这样的方式来记录。\n祝大家新的一年万事顺遂\n新年快乐！\n","date":"2022-01-29T09:39:43Z","image":"https://s1.ax1x.com/2022/04/29/Lx8ogU.jpg","permalink":"https://inariindream.cn/blog/2022/01/29/2021%E5%B9%B4%E7%BB%88%E6%80%BB%E7%BB%93/","title":"2021年终总结"},{"content":"用一句话总结我所经历的2020年\n“在理想中死亡，在现实中重生。”\n今年是无比艰难的一年，以至于每个人都在年末的时候对未来有着美好的祝愿。\n像2019年的这个时候我们祝愿的那样。\n突如其来的疫情打乱了我们每一个人的既定节奏，年初一直待在家里，我在一段时间内对外面发生的事情没有什么实感。但电视里看到的疫情速报是真的，手机里浏览到的在疫情下普通人的求助是真的，看着窗外的三环路从川流不息变为空无一车也是真的。在本应是开学典礼的时间，各科老师在线上，透过摄像头向我们传来了特殊的问候。在家里上课和考试特别考验一个人的心志，尤其是毅力和自制力，两样我最缺的东西。网课的新奇感渐渐变为无聊和放纵。甚至后来把部分课和晚自习当成我的自习课，连上课网站都懒得打开签到。\n开学再见面时，我或多或少有些彷若隔世的感觉。\n高考前的时间，在紧凑的课程和成堆的卷子面前显得弥足珍贵，同时也快得让我几乎感受不到时间的飞逝。我曾经觉得我是一个十分在意他人评价的人，并且常常因为褒扬沾沾自喜。但在我成绩真真实实的上升之后，在我听到同学戏谑地称我“黑”马的时候，在我听到室友说我扮猪吃老虎的时候，在听到金老在班会点名表扬我的时候，我的内心却没有多少喜悦的感觉。也许是因为我自知，我那远大的理想相对于我的努力而言仍然只是一个天边遥不可及的幻梦罢了。\n在倒计时十五天的时候，我翘掉了那天下午的数学考试，敲开了金老办公室的门。我想在剩下的时间回家自习，即使他在之前的班会明确地表示过禁止，我仍想要一试，因为我觉得这可能是我达成理想的最后机会了。我以为我的口才和出奇好的三诊成绩足以说服他，可当他以一种不容置疑的口气说出“不行。”的时候，我却发现 我除了流泪什么也做不到。他让我去找副校长请假，犹豫再三，我最终叩响了校长办公室的门\u0026hellip;\n事情最后有了个折中的解决，金老最后松了口，但仍需要找副校长商量，因为作为班主任没有权限放学生离校那么长的时间。而我，在学校继续待了五天后，在家里度过了高考前的最后十天，幻想着这十天能让我的成绩再来次质的飞跃。\n可惜生活是不会按着个人主观意愿的剧本来进行的。在亲眼看到结果之后，我感到头晕目眩。堆积如山的书和资料在高考后就被我卖掉，我自己断了复读这条路。我感到一股深深的愧疚，我觉得我对不起金老和其他各科老师对我的信任，我觉得我对不起和朋友夜谈时所谈及的远大梦想，我觉得我对不起爷爷，没能做到去年夏天给病榻上的他发去的视频里对他的承诺。我没能见到理想中的人，没能去到理想的学校，没能选到理想的专业，没能成为理想中的自己\u0026hellip;\n一段时间之后我才明白，这是一场再公平不过的考试，我不能简单地归因于紧张或是失利，它检验的是整个高中三年的学习。我的成绩既包含了最后一学期的努力，也有前两年的放纵。而我看到那些持之以恒努力的人，熬过一个又一个的黑夜，在日出之后，他们都得到了他们想要的梦想和成绩。\n高考后的暑假我总是会对大学有各种各样的畅想。更大的平台，更多的自由，更广的见识，更多的机会，这些都是我对大学生活的憧憬。进学校的第一天我被新鲜感淹没，在第一天晚上，我躺在床上，多少有点睡不着。我仍在畅想着即将可能到来的丰富的社团，紧张的竞赛，珍贵的感情。\n虽然实际的大学生活没有想象中的那般精彩，但我在几个月的时间里仍然收获了很多。最大的感受是十分真切的感受到: 越是看的越多，学的越多，越能感受到自己的浅陋无知，傲慢自大。我了解到有个学长以前在毛坦厂一年从大专水平努力到了我们学校的分数线；我在夜跑团里看到有人每天都坚持至少五公里，风雨无阻；我那最自信的英语，在我听到同班的有个人词汇量1w2时，在我看到有考插班生的人在十二月就已背完考研词汇的时，我那可怜的自尊与优越感被实实在在地击碎了。我想起暑假与朋友共勉的“总不能让高三成为人生的巅峰吧”，深知我还有很长的一条路要走。没能考到理想的分数不影响我喜欢现在的学校，哪怕它没有那么优秀，但它是我的平台，有它我才能有努力的机会。\n下半年我听到最多的一个词是“内卷”，它是四川高考的现状，是图书馆七点就爆满的深层原因，是灯火通明的通宵自习室里考研人的焦虑。我不知道我的未来是否会更加艰难。在谈及梦想的时候，我对我未来的五年都有精细的规划和打算，但我却不知道如何迈出第一步。我到了小时候羡慕的年龄，却没有成为小时候想成为的人。我没有迷茫，我只有恐慌。\n学校离海边很近，因此我有幸欣赏了一次海上日出和海上日落。临港离市区很远，没有光污染，晴朗的时候，即使在冬天 每天也能看到十颗以上的星星，我喜欢在夜跑之后就呆呆地望着天上的星星，从初秋时仍然可见的夏季大三角，到天气转凉时每天可见的火星，再到严冬时节的猎户座和闪耀的天狼星。每当我望着这些瑰丽而美好的景色的时候，我的思绪在操场边走马观花。唯独在这些时候，我不会因临近deadline而没做完作业而紧张，不会因还没达成梦想而彷徨失落，不会因对爱情抱有憧憬而神色迷离。临港的风很大，我拥抱着咸湿的海风，似乎这样就能将我所有的焦虑抛在风里，任它刮走远去。\n“无穷的远方，无数的人们，都和我有关。”\n后记\n今年是我写年终总结的第一年，初心可能是小时候看到南方周末新年祝福的感动，又或许只是需要将一些情感用文字抒写出来，以将我乱糟糟的生活给稍微理顺一点，就像游戏中一个又一个的checkpoint，是一种记录，也是一种反思。\n从知道到做到，有着一道鸿沟。“我们明白很多道理，却仍过不好这一生。”的原因大概如此。\n路波折坎坷，这又长又短的一年也算是到了头，可有些事并不为人力所控。\n努力了也会失败。\n祈祷了也会落空。\n逃避了也会遭重。\n谋事在人，成事在天，不外如是。\n即使如此，也不妨碍我们向前看。总得去努力才能知道结果，总得去尝试才能知成败，可别在开始前就露了怯。\n在最后，我由衷的希望来年有好事发生，由衷的希望各位来年能心想事成。\n愿各位平安喜乐\n新年快乐！ ","date":"2021-01-01T09:36:43Z","image":"https://s1.ax1x.com/2022/04/27/LqhKmt.jpg","permalink":"https://inariindream.cn/blog/2021/01/01/2020%E5%B9%B4%E7%BB%88%E6%80%BB%E7%BB%93/","title":"2020年终总结"}]