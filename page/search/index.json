[{"content":"历法是人们为了在辽阔的时空中不迷茫走散，所开创制定的参考系；而在本质上，每一天都是平等的。地球公转的寒暑枯荣，确定了今天是公历年的最后一天，同时也更是平凡的一天。\n但我在每个岁聿其莫之际，仍都会回望这一段。\n今年是我写年终总结的第三年。\n写下这句话的时候，我也意识到我的大学生活好像也步入了后半程。那现在似乎是一个好的时机，对我前一半时间的感想做一个回应。\n在20年的年终总结中，我曾记录道我进校第一天晚上躺在床上 “畅想着即将可能到来的丰富的社团，紧张的竞赛，珍贵的感情。”在21年的年终总结中，我写道 “虽然我起步晚了点，再努力最终可能也就是个铜牌或者什么也没有”。如今在参加竞赛一年后半退役的此时此刻来看，真是充满戏剧性。\n我与ACM的结缘应该始于21年4月，学校组织接种疫苗的时候，我在后排和同学聊天，对方也是一个对编程有兴趣的同学，我说道 “我觉得python比C++好写，因为Python不会忘记在句尾加分号。” 其实那个时候我根本没写过python，说这句话也只是因为当时刚重新捡起以前学的半吊子C++语法，经常忘加分号而已。说出来也只是为了装个逼。 然后就被旁边的杜老师听见了，现在想来，他可能也挺惊奇物工有人会聊编程，然后把我们拉进了校XCPC群。\n从这一刻起，我的大学的流向改变了。\n关于XCPC 我在那之后的一年半里时常会回想起这一刻，如果没有这剂疫苗，如果我排队稍微晚了一点，如果我当时忍住没有硬要显摆一下，那么，我可能就不会遇见杜老师，也就不会走上这条路了。我也许会醉心于数学建模和挑战杯等等，会成为一个自认为不是做题家的做题家（没有说做题家不好的意思），也许会因比较不同比赛的含金量而焦头烂额。如果没有这个契机，我也许将永远与XCPC无缘，因为非科班的我在物工，信工学院对XCPC的宣传再大也不会宣传到我这里来。\n那么，XCPC带给了我什么呢？一年前的今天，我也许会期望它带给我一个奖牌，能成为我求职/升学的敲门砖，因为那时，我并不知道里面有什么，在我有限的理解里，我将其看作和数学建模一样，是“含金量很高的比赛”。一年后的今天，我才发现这个比赛带给我的远高于此。\n其实我的比赛成绩并不好，作为铁牌退役仔甚至没好意思像其他人那样写退役小作文。但我仍十分幸运能够进入这个圈子。我认识了很多的人，有本校的信工同学，更有其他学校的大佬。他们中有很多是高中甚至初中时期就有竞赛经历的人，是我中学时代最为仰慕的一批人，通过与他们的对话，我得以窥知他们眼中的世界一二。这也使我的眼界没有被局限住。我也记得我有过晚上没写出来的题在梦中写出来，第二天一早开电脑一试真的是正解的经历。这些过程对我而言都是十分宝贵且值得回忆的。\n在年底的南京站，跟我差不多时间进入这个圈子的同级同学带领的队伍，获得了校史第一块奖牌。我衷心祝贺他们，我自问我是没有他那样的决心与毅力，无法做到破釜沉舟。在过去的一年中，我很多次都有“只要这段时间努力过了，自己就会量变达到质变，蜕变成全新的人”的想法，看着很多进步很快的人，以为自己也能成为这样的人。但是，我的努力常常也是三分钟热度，结果也十分显而易见。\n梦想是廉价的，失败者的言论总是微不足道。平时做简单题摸鱼嘻嘻哈哈，到真正比赛才知道刻苦训练的重要性。也许无牌退役这件事，真的会成为我很长一段时间内的遗憾吧。\n借用一句之前看到的一个回答：\n“acm也许是我介于中二期与成熟期之间过渡时期的梦想，闪闪发光的梦想，恐怕以后不会再有这样追逐梦想的机会了。我成熟了，长大了，要学会权衡利弊了，要学会选择性价比高的事物了。”\n关于其他 其实今年我的收获还是很多，大量的网课时间让我得以有空闲探索自己喜欢的领域，我做了个好玩的qq机器人，学会了服务器的基本功能和使用，找导师参与到了几个AI项目，写了个小插件并获得了很多star等等。年初的我，一定想不到在这一年里我能学到这么多东西，遇到这么多厉害的人。\n认识的人越来越多，接收的信息也越来越广泛，在双创和acmer实习群里我也见到了很多在自己领域处于尖端水平的前辈的发言，这些充满专业眼光和独到见解的信息让我对自己要掌握的技能，要投身的行业，要选择怎么样的人生，变得愈发清晰明了。\n但是，从无到有，要迈出的仅仅只有一小步，而从浅入深，需要付出的努力应该远比我所能估量的要大，了解的越多，越是能深知我仍有一条很长的路要走。\n当然遗憾也还是有的，没能拿牌、没参加过现场赛、一整年没有静下来看完一本书、眼高手低的毛病仍没改掉、没狠下心买写字机导致这学期抄7门实验报告手快抄断了\n我仍怀着一点小小的期望，希望在明年的此时我在回顾刚刚过去的一年时，能够回应现在的自己：告诉此时的我又学到了以现在眼光难以想象的东西，遗憾也比上一年少了很多。\n“朝变幻无穷的目标前进吧，我内心中的跃动永不休止。”\n后记 太阳系的一颗蓝色岩质行星又公转了一周，寒暑枯荣确立了年复一年的旋回。我们能轻易挖掘到千百年前的历史，却难以想象五年后的未来，即使它近在咫尺。\n在这一年，“改变”的争先恐后和纷至沓来让我们不安，也许变化已经成为一种常态，我们如何接纳变化，将决定我们的道路通向何方。\n但或许这正是文明，能以每个人的微小力量，努力摆脱由自然界周期完全决定的命运；也能在无数的未知和随机涨落的沉浮间，依旧矢志前行。\n愿大家身体健康。\n新年快乐！\n","date":"2022-12-29T10:39:43Z","image":"https://inariindream.fun/blog/2022/12/29/2022%E5%B9%B4%E7%BB%88%E6%80%BB%E7%BB%93/333_huee0377b4297da8b2a157c49f7c6703d5_80449_120x120_fill_q75_box_smart1.jpg","permalink":"https://inariindream.fun/blog/2022/12/29/2022%E5%B9%B4%E7%BB%88%E6%80%BB%E7%BB%93/","title":"2022年终总结"},{"content":"开新坑\n","date":"2022-12-23T11:06:32Z","image":"https://inariindream.fun/blog/2022/12/23/atc%E8%A1%A5%E9%A2%98%E5%90%88%E9%9B%86/222_hu8a0ae0b5ba06d0fc393571ca4609b8d9_189713_120x120_fill_q75_box_smart1.jpg","permalink":"https://inariindream.fun/blog/2022/12/23/atc%E8%A1%A5%E9%A2%98%E5%90%88%E9%9B%86/","title":"ATC补题合集"},{"content":"本文用于记录在炼丹时踩过的坑，以及解决方案。\n之前在AutoDL训的时候很多都忘记录了\u0026hellip;只记得基本每训一次之前得改5 6个bug\n所以现在从padddleX开始记录。\nTypeError: Argument \u0026lsquo;bb\u0026rsquo; has incorrect type (expected numpy.ndarray, got list) 问题描述 在使用自己打标好的COCO数据集训练时，出现了如下错误：\n---------------------------------------------------------------------------TypeError Traceback (most recent call last)/tmp/ipykernel_128/738473502.py in \u0026lt;module\u0026gt; 15 warmup_start_lr=0.0, 16 save_dir=\u0026#39;output/mask_rcnn_r50_fpn\u0026#39;, ---\u0026gt; 17 use_vdl=True) /opt/conda/envs/python35-paddle120-env/lib/python3.7/site-packages/paddlex/cv/models/detector.py in train(self, num_epochs, train_dataset, train_batch_size, eval_dataset, optimizer, save_interval_epochs, log_interval_steps, save_dir, pretrain_weights, learning_rate, warmup_steps, warmup_start_lr, lr_decay_epochs, lr_decay_gamma, metric, use_ema, early_stop, early_stop_patience, use_vdl, resume_checkpoint) 289 early_stop=early_stop, 290 early_stop_patience=early_stop_patience, --\u0026gt; 291 use_vdl=use_vdl) 292 293 def quant_aware_train(self, /opt/conda/envs/python35-paddle120-env/lib/python3.7/site-packages/paddlex/cv/models/base.py in train_loop(self, num_epochs, train_dataset, train_batch_size, eval_dataset, save_interval_epochs, log_interval_steps, save_dir, ema, early_stop, early_stop_patience, use_vdl) 331 outputs = self.run(ddp_net, data, mode=\u0026#39;train\u0026#39;) 332 else: --\u0026gt; 333 outputs = self.run(self.net, data, mode=\u0026#39;train\u0026#39;) 334 loss = outputs[\u0026#39;loss\u0026#39;] 335 loss.backward() /opt/conda/envs/python35-paddle120-env/lib/python3.7/site-packages/paddlex/cv/models/detector.py in run(self, net, inputs, mode) 102 103 def run(self, net, inputs, mode): --\u0026gt; 104 net_out = net(inputs) 105 if mode in [\u0026#39;train\u0026#39;, \u0026#39;eval\u0026#39;]: 106 outputs = net_out /opt/conda/envs/python35-paddle120-env/lib/python3.7/site-packages/paddle/fluid/dygraph/layers.py in __call__(self, *inputs, **kwargs) 900 self._built = True 901 --\u0026gt; 902 outputs = self.forward(*inputs, **kwargs) 903 904 for forward_post_hook in self._forward_post_hooks.values(): /opt/conda/envs/python35-paddle120-env/lib/python3.7/site-packages/paddlex/ppdet/modeling/architectures/meta_arch.py in forward(self, inputs) 24 25 if self.training: ---\u0026gt; 26 out = self.get_loss() 27 else: 28 out = self.get_pred() /opt/conda/envs/python35-paddle120-env/lib/python3.7/site-packages/paddlex/ppdet/modeling/architectures/mask_rcnn.py in get_loss(self) 121 122 def get_loss(self, ): --\u0026gt; 123 bbox_loss, mask_loss, rpn_loss = self._forward() 124 loss = {} 125 loss.update(rpn_loss) /opt/conda/envs/python35-paddle120-env/lib/python3.7/site-packages/paddlex/ppdet/modeling/architectures/mask_rcnn.py in _forward(self) 98 # Mask Head needs bbox_feat in Mask RCNN 99 mask_loss = self.mask_head(body_feats, rois, rois_num, self.inputs, --\u0026gt; 100 bbox_targets, bbox_feat) 101 return rpn_loss, bbox_loss, mask_loss 102 else: /opt/conda/envs/python35-paddle120-env/lib/python3.7/site-packages/paddle/fluid/dygraph/layers.py in __call__(self, *inputs, **kwargs) 900 self._built = True 901 --\u0026gt; 902 outputs = self.forward(*inputs, **kwargs) 903 904 for forward_post_hook in self._forward_post_hooks.values(): /opt/conda/envs/python35-paddle120-env/lib/python3.7/site-packages/paddlex/ppdet/modeling/heads/mask_head.py in forward(self, body_feats, rois, rois_num, inputs, targets, bbox_feat, feat_func) 244 if self.training: 245 return self.forward_train(body_feats, rois, rois_num, inputs, --\u0026gt; 246 targets, bbox_feat) 247 else: 248 im_scale = inputs[\u0026#39;scale_factor\u0026#39;] /opt/conda/envs/python35-paddle120-env/lib/python3.7/site-packages/paddlex/ppdet/modeling/heads/mask_head.py in forward_train(self, body_feats, rois, rois_num, inputs, targets, bbox_feat) 182 tgt_labels, _, tgt_gt_inds = targets 183 rois, rois_num, tgt_classes, tgt_masks, mask_index, tgt_weights = self.mask_assigner( --\u0026gt; 184 rois, tgt_labels, tgt_gt_inds, inputs) 185 186 if self.share_bbox_feat: /opt/conda/envs/python35-paddle120-env/lib/python3.7/site-packages/paddlex/ppdet/modeling/proposal_generator/target_layer.py in __call__(self, rois, tgt_labels, tgt_gt_inds, inputs) 256 257 outs = generate_mask_target(gt_segms, rois, tgt_labels, tgt_gt_inds, --\u0026gt; 258 self.num_classes, self.mask_resolution) 259 260 # mask_rois, mask_rois_num, tgt_classes, tgt_masks, mask_index, tgt_weights /opt/conda/envs/python35-paddle120-env/lib/python3.7/site-packages/paddlex/ppdet/modeling/proposal_generator/target.py in generate_mask_target(gt_segms, rois, labels_int32, sampled_gt_inds, num_classes, resolution) 351 results.append( 352 rasterize_polygons_within_box(new_segm[j], boxes[j], --\u0026gt; 353 resolution)) 354 else: 355 results.append( /opt/conda/envs/python35-paddle120-env/lib/python3.7/site-packages/paddlex/ppdet/modeling/proposal_generator/target.py in rasterize_polygons_within_box(poly, box, resolution) 306 307 # 3. Rasterize the polygons with coco api --\u0026gt; 308 mask = polygons_to_mask(polygons, resolution, resolution) 309 mask = paddle.to_tensor(mask, dtype=\u0026#39;int32\u0026#39;) 310 return mask /opt/conda/envs/python35-paddle120-env/lib/python3.7/site-packages/paddlex/ppdet/modeling/proposal_generator/target.py in polygons_to_mask(polygons, height, width) 282 import pycocotools.mask as mask_util 283 assert len(polygons) \u0026gt; 0, \u0026#34;COCOAPI does not support empty polygons\u0026#34; --\u0026gt; 284 rles = mask_util.frPyObjects(polygons, height, width) 285 rle = mask_util.merge(rles) 286 return mask_util.decode(rle).astype(np.bool) pycocotools/_mask.pyx in pycocotools._mask.frPyObjects() TypeError: Argument \u0026#39;bb\u0026#39; has incorrect type (expected numpy.ndarray, got list) 解决方案 这是因为json文件里面的segmentation中的数据不符合要求，正常来说这里面是类似于[x,y,x,y,x,y\u0026hellip;..x,y]按顺序排列的点序列，并且这里面的点序列个数是偶数，同时点的个数至少要超过2个（4个最稳），也就是要构面。\n而我在打标时用的是矩形打标，只记录了对角两个点。因此这里面的数据是[x1,y1,x2,y2]，这里面的点序列个数是4个，而且是不符合要求的，因此需要将这里面的数据转换成符合要求的数据。\n写一个小脚本将[x1,y1,x2,y2]转换成[x1,y1,x1,y2,x2,y2,x2,y1]，这样就符合要求了。\nimport json with open(\u0026#39;instances_val2017.json\u0026#39;) as f: data = json.load(f) ann = data[\u0026#39;annotations\u0026#39;] for i in ann: if len(i[\u0026#39;segmentation\u0026#39;][0]) == 4: x1, y1, x2, y2 = i[\u0026#39;segmentation\u0026#39;][0] i[\u0026#39;segmentation\u0026#39;][0] = [x1, y1, x2, y1, x2, y2, x1, y2] with open(\u0026#39;instances_val2017.json\u0026#39;, \u0026#39;w\u0026#39;) as f: json.dump(data, f, indent=4) SystemError: (Fatal) Blocking queue is killed because the data reader raises an exception. 解决方案 参考这个ISSUE\n","date":"2022-12-17T10:24:08Z","image":"https://inariindream.fun/blog/2022/12/17/%E7%82%BC%E4%B8%B9%E9%97%AE%E9%A2%98%E5%AE%9E%E5%BD%95/111_hu67345f7c87db9a9ca58e7dbc37776702_80206_120x120_fill_box_smart1_3.png","permalink":"https://inariindream.fun/blog/2022/12/17/%E7%82%BC%E4%B8%B9%E9%97%AE%E9%A2%98%E5%AE%9E%E5%BD%95/","title":"炼丹问题实录"},{"content":"此纪录从2022-10-21 09:56:46始\nEducational Codeforces Round 140 C. Count Binary Strings 待补\nEducational Codeforces Round 139 D. Lucky Chains 题意 给定两个数$a, b(1 \\leq a, b \\leq 1e7)$，执行如下语句：\nwhile(gcd(a, b) == 1) a++, b++, cnt++ ;\n求cnt的值\n思路 数学苦手，看典哥题解都理解了好一会\n一个gcd的性质\n$gcd(a, b) == gcd(a, b - a)$\n假设 $a$ 是更小的那个数，我们根据gcd的性质推导一下： $gcd(a, b) == gcd(a, b - a)$ 因此 $gcd(a + k, b + k) == gcd(a + k, b - a)$ 。\n$b - a$是一个定值，因此问题转化成对于每一个$ b - a $的质因数$p$（刚开始还想了半天为什么找质因数，菜死了），$(a + k) % p == 0$ 时$k$的最小值，式子可转化为求$a - a%p$ 的最值。\n一种更快的办法是直接找每个数的最小质因子，然后对$p$进行除的操作来找到其下一个质因数，这样就不用处理所有的质数\n前者复杂度为$O(nsqrt(n))$，因为需筛出所有的质数\n后者为$O(nlog(n))$\n代码 primes = [-1] * 10 ** 7 def init(): # 所有数的最小质因子 for i in range(2, 10 ** 7): if primes[i] == -1: for j in range(i, 10 ** 7, i): primes[j] = i def solve(): a, b = map(int, input().split()) dif = b - a if dif == 1: print(-1) return if math.gcd(a, b) != 1: print(0) return if dif \u0026amp; 1 == 0: print(1) return ans = dif - a % dif while dif != 1: ans = min(ans, primes[dif] - a % primes[dif]) # 找到下一个质因数 dif //= primes[dif] # print(primes[1:25]) print(ans) if __name__ == \u0026#34;__main__\u0026#34;: init() for test_case in range(1, int(input()) + 1): solve() 贴一个前一天的C，是相似的题，一起补了\n不过数据范围是$1e9$，直接根号筛的话用py过不去，因为C++都跑了1100ms\n看了下别人的py代码没太看懂，也许需要更高级的筛法，比如用随机化筛，能变成$O(M^{\\dfrac{1}{4}})$, 但没存py的板子也没必要存，就直接换C++用$O(\\sqrt{M})$的筛法莽过去了\nconst int N =33333; vector\u0026lt;int\u0026gt;primes(N, 0); vector\u0026lt;int\u0026gt;vis(N, 0); void init() { int now = 0; for (int i = 2; i \u0026lt; N; i++) { if (!vis[i]) primes[now++] = i; for (int j = 0; primes[j] * i \u0026lt; N; j++) { vis[primes[j] * i] = true; if (i % primes[j] == 0) break; } } } void solve(){ int n; cin \u0026gt;\u0026gt; n; vector\u0026lt;int\u0026gt;a(n); for (int i = 0; i \u0026lt; n; i++) { cin \u0026gt;\u0026gt; a[i]; } for(auto i : primes){ if (i == 0){ break; } int cnt = 0; for (int j = 0; j \u0026lt; n; j++) { if (a[j] % i == 0){ cnt++; while (a[j] % i == 0){ a[j] /= i; } } } if (cnt \u0026gt;= 2){ cout \u0026lt;\u0026lt; \u0026#34;YES\u0026#34; \u0026lt;\u0026lt; endl; return; } } map\u0026lt;int, int\u0026gt;mp; for (int i = 0; i \u0026lt; n; i++) { if (a[i] != 1){ mp[a[i]]++; } if (mp[a[i]] \u0026gt;= 2){ cout \u0026lt;\u0026lt; \u0026#34;YES\u0026#34; \u0026lt;\u0026lt; endl; return; } } cout \u0026lt;\u0026lt; \u0026#34;NO\u0026#34; \u0026lt;\u0026lt; endl; } Educational Codeforces Round 138 C Number Game 题意: 给定一个长度为$n$的整数数组$a$, Alice和Bob玩游戏.对于一个$k$, 游戏进行$k$轮, 第$i$轮,Alice选择从a中删除一个小于等于$k - i + 1$的数, Bob选择一个数加上$k - i + 1$.如果某一轮Alice没有数字可以选择,则Bob赢,否则Alice赢.问使得Alice赢的最大的k是多少?\n$(n \u0026lt;= 100)$\n思路 最开始以为是二分答案，但注意到n比较小，所以可以直接写模拟，Bob的策略应该是每回合将Alice当前的$k - i + 1$加到当前数列的最小项上面，这样能最大化减少Alice能删掉的数量。Alice的策略则是趁$k - i + 1$减小之前每次尽可能删掉能删掉的最大数。\n其实这个思路很好想，昨晚在看题十分钟后就想到了，但写模拟代码写了一万年还调错了，典中典之脑子会了手没会。\n今早想清楚模拟过程之后10分钟1A了\n代码 $O(n^3)$\ndef solve(): n = int(input()) b = list(map(int, input().split())) b.sort() k = n while k \u0026gt; 0: a = b.copy() # 最开始写的 a = b，没发现，调其他地方调了一万年 index = 1 while index \u0026lt;= k: pos = -1 temp = k - index + 1 for i in range(len(a)): if temp \u0026gt;= a[i]: pos = i if pos == -1: k -= 1 break if index == k: print(k) return a.remove(a[pos]) if len(a) \u0026gt; 0: a[0] += temp a.sort() index += 1 print(k) $O(nlogn)$ 待补\nvoid solve() { int n; cin \u0026gt;\u0026gt; n; vector\u0026lt;int\u0026gt; a(n); cin \u0026gt;\u0026gt; a; sort(a.begin(), a.end()); int left = 0, right = (n + 1) / 2; auto check = [\u0026amp;](int k) { if (k == 0) return true; if (a[k - 1] != 1) return false; for (int i = k; i \u0026lt; 2 * k - 1; i++) { if (a[i] \u0026gt; i - k + 2) { return false; } } return true; }; while (left \u0026lt;= right) { int k = (left + right) / 2; if (check(k)) left = k + 1; else right = k - 1; } cout \u0026lt;\u0026lt; left - 1 \u0026lt;\u0026lt; \u0026#34;\\n\u0026#34;; } Educational Codeforces Round 134 D. Maximum AND 题意 给定两个数列$a$, $b$, 令$c_i = a_i \\bigoplus b_i$， 定义价值为 $c_1$ \u0026amp; $c_2$ \u0026amp; $c_3$\u0026amp; \u0026hellip; $c_n$ 求价值的最大值\n$(1≤n≤10^5)$ $(0≤a_i, b_i\u0026lt;2^{30})$\n思路 注意到c在某一位为1时只能是当所有的$c_i$在这一位都为1才能取到，进而需要所有匹配的$a_i$ 和 $b_i$在这一位的异或都为1。\n那么如何找这样满足条件的匹配呢，看题解发现有一种很妙的方法可以实现。$c$贪心地从最高位为$1$开始往下取，然后先假设$c$这一位为1，通过map计数check是否所有的$a_i, b_i$都能满足条件，而并不需要排列来对每个$i$进行匹配。\n如上图所示，如果存在一组满足这样关系的a和b，则用map计数添加进去，而如果c在这一位能够取到1的话，那么map的value一定是一个确定值。\n最后再让$c |= (1 \u0026laquo; i)$（更新值），继续往后推：在这样的高位取值下，c的低位取值情况即可\ndef solve(): n = int(input()) a = list(map(int, input().split())) b = list(map(int, input().split())) d = defaultdict(int) ans = 0 for i in range(30, -1, -1): temp = ans | (1 \u0026lt;\u0026lt; i) d.clear() ok = 1 for j in range(n): d[a[j] \u0026amp; temp] += 1 d[~b[j] \u0026amp; temp] -= 1 # 判断是否异或为1 for j in d.values(): if j != 0: ok = 0 break if ok != 0: # 如果能取到才用或运算加上值 ans = temp print(ans) Educational Codeforces Round 112 D. Say No to Palindromes（DP） 题意 给定一个由a,b,c组成字符串，定义一个字符串是美丽的当且仅当它的字串中没有回文。\n$m$次询问，每次给定左右端点$l, r$，如果此字符串不美丽，则每修改一个字符cost+=1，问使将这一段字符串修改成美丽字符串的最小花费是多少。\n$(1≤n,m≤2⋅10^5)$\n思路 注意到对于每个$s_i$, $s_i \\neq s_{i - 1}$并且$s_i \\neq s_{i - 2}$才能不形成回文，由于一共只有三种字母，所以$s_i$一定等于$s_{i - 3}$，因此，修改后的整个字符串一定是\u0026quot;abcabcabc\u0026hellip;\u0026quot; 或\u0026quot;bacbacba\u0026hellip;\u0026quot; 等共六种排列情况的串。\n然后在询问前把6种字符串修改情况的操作次数前缀和一下，s[i]代表字符串修改到$i$时的修改次数，在每次询问时用s[r] - s[l - 1]就是这种排列情况时的需要修改的次数（不用关心具体修改了哪些），然后取6个情况中的最小值即可，查询复杂度为$O(1)$\n因为一共就三种字符，所以6种情况一定可以覆盖完全\n代码 def solve(): n, m = map(int, input().split()) s = input() lis = [\u0026#39;abc\u0026#39;, \u0026#39;acb\u0026#39;, \u0026#39;bca\u0026#39;, \u0026#39;bac\u0026#39;, \u0026#39;cab\u0026#39;, \u0026#39;cba\u0026#39;] dp = [[0] * (n + 1) for i in range(6)] for i in range(6): for j in range(n): dp[i][j + 1] = dp[i][j] if s[j] != lis[i][j % 3]: dp[i][j + 1] += 1 for _ in range(m): x, y = map(int, input().split()) ans = 114514114514 for i in range(6): ans = min(ans, dp[i][y] - dp[i][x - 1]) print(ans) ","date":"2022-10-21T09:56:46Z","image":"https://inariindream.fun/blog/2022/10/21/codeforcesedu%E8%A1%A5%E9%A2%98%E5%90%88%E9%9B%86/222_hu15b1962fdc5d535b167ff7ac7d802c19_3173586_120x120_fill_box_smart1_3.png","permalink":"https://inariindream.fun/blog/2022/10/21/codeforcesedu%E8%A1%A5%E9%A2%98%E5%90%88%E9%9B%86/","title":"CodeforcesEdu补题合集"},{"content":"前言 最早知道这部动画是在7月份，大概知道近期会有一个基于2077世界观的动画会出，但知道有CDPR的参与后，有着2077的前车之鉴，最开始我是不太看好这部动画的。跟很多人一样，我一边追着蒜吻一边看着蒜吻大战，不亦乐乎。直到9月 《边缘行者》的出现，以一己之力停止了两部竞争胶着的动画的纷争，成为了今年原创动画的唯一真神。\n看第一集是在考六级刷分的前一天，考前不想复习的时候打开微博刷了刷，发现这部动画的讨论度超过了我原先的预期，并且评价也都十分不错，于是我将信将疑地打开了第一集。看完第一集的时候我就知道这部番十分对我胃口，无论是动画中还原的游戏设定还是美术风格。前思后想，在看完第三集之后，我还是强迫自己去睡觉了，第二天六级考完后，回到62号隔离楼，我的第一件事就是打开电脑把剩下的集数看完。\n不得不说，后劲是真的大。思来想去，在20多天后的一个没课的上午，还是决定想为这部动画写点什么。\n(Warning：本文含大量剧透内容) 剧情 即使我为《边缘行者》第一次写漫评，我也不能说它是一部多完美的作品，它在很多地方都会让我感受到些许俗套。\n看宣传海报和pv大概就能猜到大卫和Lucy的相遇是一种类似于传统BMG(Boy Meets Girl)的剧情，即：少年与少女命运般的邂逅，经历了一路波折，最终成为了情侣，这样标准的结局。事实也大差不差。在相遇之前，男主眼前擦过头发的那几个画面甚至莫名让我想起了蝶祈（不是\n前几集的剧情其实非常好猜，男主生活出现变故，这时突然出现女主，男主觉得是那种能把自己从原来的日常解救出来的那种人，然后死心塌地地跟着女主，再体会女主的世界，有着新奇的体验。是一种较为传统的剧情。\n甚至在第四集，两人在月下拥吻时，即使我被那唯美的画面和恰到好处的音乐给打动到。但在那集结束字幕的Cyberpunk飘出后，我心里还会有“这样就安排在一起了会不会太快了”的疑问。\n但瑕不掩瑜，赛博朋克的剧情整体是一个较为悲剧的氛围，从op的暗示大概就能猜出最后不会是一个大团圆结局。剧情并没有描绘游戏里“大名鼎鼎的V”那样的几乎是怪物的玩家化身，而是一群被义体技术异化，被赛博精神病折磨，被夜之城吞没的小人物，这也就注定了这部动画的悲剧内核。\n其悲剧性在第一集就充分展现了出来，与母亲相依为命的男主，在夜之城的社会底层如履薄冰，生活难以为继，母亲想让大卫实现阶级跃迁，不惜花重金也要让他就读荒坂旗下的私立学校。但命运并没有放过苦命人，因为用盗版软件让经济情况雪上加霜，在学校被富二代霸凌，卷入飞车战，母亲去世，最后甚至连母亲的遗体都没见到（根据游戏设定，那个位置是清道夫即器官贩卖者的地盘）。\n即使大卫和义体医生在剧中时刻暗示“大卫是特别的”，但大卫身上的许多flag，仍挡不住最后死亡的结局。我在看这部动画之前看的一些评价，隐约能猜到大卫和露西中有一人可能是牺牲了的。（还好看的早） 我虽然心知肚明赛博朋克题材的作品不会有与主题相悖的大团圆结局，但是在最后看到Lucy在月球上孤独地张开双臂，我的心还是狠狠地抽动了一下。\n我是在难过什么呢？瑞贝卡哥哥死的时候，我不觉得难过，我觉得那是场意外，我玩过游戏，所以深知这样的事情在夜之城只能叫做家常便饭 （死人大乐透）。并且他的死亡也使大卫成熟了许多。大哥曼恩死的时候，我虽然被那集的表现手法给震撼住了，对大哥的死感觉有点遗憾，但其实大哥的死也是有伏笔的，我只是遗憾大哥没能克服过去。瑞贝卡的死也差不多，在我的感觉里她在战斗里一直都有一点不要命的打法，哪天真寄了也不奇怪。\n那么我为什么会对大卫的死感到这么难过呢？照例说，有着那么多flag，我应该会觉得理所应当的才对。\n后来看了泛式的杂谈回才明白过来，其实是Lucy这个“未亡人”的设定，如果最后大卫和Lucy双双赴死，并且最后两人牵手看着月光，这样的话对我来说悲剧的氛围就会减弱，因为我会觉得这是某种意义上的“Wish Granted”，但事实上并没有。两个人的心愿在最后都没有达成。大卫做到了保护Lucy，也用最后一次任务的金钱让Lucy上了月球，但是他在第4集赏月时许诺的“我会带你到月球去”却是实实在在地落空了\nLucy想去月球的愿望其实是源自于怕被荒坂找到的恐惧，所以在遇见大卫之前会想去一个远离所有纷争的，平静的地方。但在遇见大卫之后，一些事情改变了，她有了对她来说十分重要的人，并不是像以前那样无牵无挂。她的愿望也逐渐成“去月球”变成了“和大卫一起去月球”。\n而最后，两人的愿望都落空了，我个人认为，正是这份落差是让很多人意难平，感到后劲很大的主要原因\n表现手法 我觉得《边缘行者》的人物塑造是非常成功的，短短几集就把主角团的所有角色塑造得十分丰满。追寻梦想的恋人，可靠的大哥大嫂，有点可爱的疯批美人等等。\nCyberPunk这个词在动画里被描述成了一群人的身份名称，在秩序边缘游走，也在精神边缘游走，在无情的社会中努力反抗，苟活的一群人，叫做CyberPunk。\n因此 EdgeRunner 就是在跟这些赛跑。整个标题，都可以算作是第六集神回的伏笔。\n在第六集里，过量的义体压垮了曼恩，行动失败，团队分离崩析，暴恐机动队突入的瞬间，在被Sanevistan压缩的时间里，大卫以痛苦的慢放目睹了大哥的死相，在母亲死后跟着团队行动堆叠起来的安全感跟着大哥的精神一起倒塌，配乐则选取了游戏中FM96.1广播中出现的《Zurawie》，歌曲中的嘶吼仿佛代替了大卫发出疯狂和绝望的嘶吼\n没有人能逃过，曼恩不能，大卫也不行。\n瑞贝卡的整活也阻止不了故事也从这里开始调性下沉。大卫成长成了独当一面的团队领袖，全身逼近极限的义体化让他也走上了曼恩的末路，从一开始他就被企业盯上当作棋子，最后能做的也室友拯救爱人，在彻底失去自我前赴死。\n很多人以靠近朋克的方式去理解赛博朋克，其根源是抗争性，强调叛逆和反叛精神，对抗主流价值观等。从这个角度看，大卫只身一人救下露西，对抗亚当重锤，并在最后为了Lucy的梦想安然接受死亡的终局，确实是一件十分“朋克”的事。\n关于Lucy Lucy应该算是近几年的动画作品中我最喜欢的女主了，不仅仅是因为她是那种 “看着坏坏的，能带你摆脱无聊日常” 的女孩，还因为她在动画里体现出来的聪慧与机警，扳机社是真的将这个人物塑造的很好。\n很少有这么强大、聪明、理性、浪漫，美丽的女主角。精致的脸，高挑的身材。低饱和度的粉色\u0026amp;冰蓝色拼接短发，霓虹瞳色。下眼睑和下嘴唇的纹印，将它和诸多动漫中脸型类似的漂亮女主区别开来。\n在前期，Lucy的存在可以说是较为神秘的，无法看透她在想什么。\n当所有夜之城的居民，都为夜之城的繁华与物质而疯狂，为了成为传说的大人物而费尽心机。她的双眼中只有对这种狂热的疲劳与厌倦，\n她抓着男孩的病床在川流不息的马路上驰骋，那一刻，男孩眼里闪过了霓虹灯光。\n她将男孩带入自己的月球，她将自己的哀愁自己的防备留在夜之城的夜晚，而在月球上露出她内心毫不掩饰的喜悦。\n她摆在身后的手做出可爱的手势，她抓住男孩的手一起在月球上飞跃。\nLucy前期的这种撩人大姐姐型、似乎能把你的一切都能看透的神秘人设我觉得是十分吸引人的。\n很多人说Lucy后期变成了恋爱脑妹妹，但我的观点与之相左。我认为Lucy至始至终都是一个独立自强的女性，前期做任务时，她能用高分子线救队友于水火，能在任务里发挥自己的贡献。\n即使在很多人说的“呜呜大卫”的后期，Lucy也是凭自己的力量把觊觎大卫的人给清除的，是因为这个时候大卫对她而言十分重要，将为心爱之人毅然做出行动的行为也单纯地归入“恋爱脑妹妹”的评价，我个人是认为不太准确的。\nLucy的人设至始至终应该都没有崩的，她不同于传统的“塔斯给得”，“多西哟”型女主，她始终都会以行动来达成自己的目标，她的成熟，聪慧，帅气还带一点可爱的内在是比好看的身材更加吸引我的地方。\n突然想起上一次这么喜欢的女主还是石头门的克里斯蒂娜 也许我就是喜欢大姐姐吧\n动画之外 游改影视作品这个领域以往很少出佳作，不过近两年似乎出现了黎明。去年的《双城之战》是一封拳头写给玩家的情书，今年的《边缘行者》也将2077的在线人数有了回到往日繁荣的势头。\n不管2077的游戏多么残缺，其世界观和美术设定及任务安排仍是一流的水准，我很庆幸我是先玩过游戏再看的动画，它让我看懂这部动画中一些游戏彩蛋，也对这部作品的内核有了更深的理解。\n论设定，我觉得不如初看巨人前三季时带给我的震撼；论内核，我觉得比不上《来自深渊》；论原创，我觉得也许能刚好与去年的《奇巧计程车》打个平手（指表现力与讨论度等）。但为什么我单独在看完这部作品以后，会想着为其写一篇感想呢？\n我想，也许在因为学业压力而被迫暂时放弃游戏的现在，我的内心深处，仍然是那个Player吧。因此，会对游改动画有着一种别样的情感，也还会去圣地巡礼。\n结语 对我来说，“抗争”和“抗争失败后的无力”也是我喜欢《边缘行者》的原因之一。特别是最后Lucy在月球上时，面罩上倒映出大卫身影的那一刻，伴随着他们第一次上月球时的《I Really Want To Stay At Your House》，这时，我对这部动画的体验完整了。真挚的感情被巨型企业给吞没，大卫·马丁内斯如流星般闪耀而过，天空重新归于平静，只掀起数片水花。\n其中的阴郁有多么无力，绝望，而真实的爱又如何甜美，真挚，热烈。\n不同于《来自深渊》带给我的“温暖的黑暗”，《边缘行者》的故事更像是漆黑郊外夜景下突然出现的霓虹灯，美得有些不合时宜。\n因此，在美好破碎时，会让人感到疼痛。\n曼恩变成赛博精神病的时候见到自己在荒原上奔跑，之后是大卫，他跑的更快，跑的更远，现在轮到了Lucy。在这片一无所有又无穷无尽的荒原，到处都是路，亦或是到处都没有路，唯有死神，令一切化为乌有的死神，正在黑暗中以不可知的速度行进着，日日夜夜向这荒原中心的人奔来。\n动画之外，浪起之时，我也唯有奔跑。\n","date":"2022-10-10T10:04:36Z","image":"https://s1.ax1x.com/2022/10/10/xYgx5F.png","permalink":"https://inariindream.fun/blog/2022/10/10/cyberpunkedgerunner%E8%A2%AB%E6%89%B3%E6%9C%BA%E7%A4%BE%E5%94%A4%E5%9B%9E%E6%B4%BB%E5%8A%9B%E7%9A%84%E5%A4%9C%E4%B9%8B%E5%9F%8E/","title":"《Cyberpunk·Edgerunner》被扳机社唤回活力的夜之城"},{"content":" 扫描 题目描述 有一个 $1 \\times n$ 的矩阵，有 $n$ 个整数。\n现在给你一个可以盖住连续 $k$ 个数的木板。\n一开始木板盖住了矩阵的第 $1 \\sim k$ 个数，每次将木板向右移动一个单位，直到右端与第 $n$ 个数重合。\n每次移动前输出被覆盖住的数字中最大的数是多少。\n输入格式 第一行两个整数 $n,k$，表示共有 $n$ 个数，木板可以盖住 $k$ 个数。\n第二行 $n$ 个整数，表示矩阵中的元素。\n输出格式 共 $n - k + 1$ 行，每行一个整数。\n第 $i$ 行表示第 $i \\sim i + k - 1$ 个数中最大值是多少。\n样例 #1 样例输入 #1 5 3 1 5 3 4 2 样例输出 #1 5 5 4 提示 对于 $20%$ 的数据，$1 \\leq k \\leq n \\leq 10^3$。\n对于 $50%$ 的数据，$1 \\leq k \\leq n \\leq 10^4$。\n对于 $100%$ 的数据，$1 \\leq k \\leq n \\leq 2 \\times 10^6$，矩阵中的元素大小不超过 $10^4$ 并且均为正整数。\n思路 定义一个大根堆，里边放一对数，这个数的大小和位置。\n我们对于每次查询，判断首元素的位置是否在[i-k+1,i]这个范围内，不符合的话就弹出来。\n代码 priority_queue\u0026lt;pii,vector\u0026lt;pii\u0026gt;\u0026gt;q; void solve(){ int n, k; cin \u0026gt;\u0026gt; n \u0026gt;\u0026gt; k; vector\u0026lt;int\u0026gt; a(n); for (int i = 0; i \u0026lt; n; i++) { cin \u0026gt;\u0026gt; a[i]; } for (int i = 0; i \u0026lt; n; i++) { q.push({a[i], i + 1}); if (i + 1 \u0026gt;= k) { while (q.top().second \u0026lt;= i + 1 - k) { q.pop(); } cout \u0026lt;\u0026lt; q.top().first \u0026lt;\u0026lt; endl; } } } 求m区间内的最小值 题目描述 一个含有 $n$ 项的数列，求出每一项前的 $m$ 个数到它这个区间内的最小值。若前面的数不足 $m$ 项则从第 $1$ 个数开始，若前面没有数则输出 $0$。\n输入格式 第一行两个整数，分别表示 $n$，$m$。\n第二行，$n$ 个正整数，为所给定的数列 $a_i$。\n输出格式 $n$ 行，每行一个整数，第 $i$ 个数为序列中 $a_i$ 之前 $m$ 个数的最小值。\n样例 #1 样例输入 #1 6 2 7 8 1 4 3 2 样例输出 #1 0 7 7 1 1 3 提示 对于 $100%$ 的数据，保证 $1\\le m\\le n\\le2\\times10^6$，$1\\le a_i\\le3\\times10^7$。\n","date":"2022-08-04T11:31:31Z","image":"https://s1.ax1x.com/2022/04/30/LzHLHf.jpg","permalink":"https://inariindream.fun/blog/2022/08/04/%E6%B4%9B%E8%B0%B7%E4%B8%93%E9%A2%98%E8%AE%B0%E5%BD%95%E4%BC%98%E5%85%88%E9%98%9F%E5%88%97/","title":"洛谷专题记录（优先队列）"},{"content":" 一些备用的rss源\nhttp://rsshub.sksren.com/ https://rsshub.170601.xyz/ http://rss.5ux.net/ https://rss.injahow.cn/ https://rss.feiyuyu.net/ https://rsshub.uneasy.win/ https://rss.shab.fun/ http://selectivedog.com/ https://rsshub.zsliang.me/ https://rsshub.rssforever.com/ https://rss.shab.fun/ https://rss.injahow.cn/ http://i.scnu.edu.cn/sub http://rsshub.sksren.com/ https://rsshub-7x3pyolbs.vercel.app/ rsshub.uneasy.win rsshub.rssforever.com ","date":"2022-05-26T10:16:47Z","permalink":"https://inariindream.fun/blog/2022/05/26/rss%E5%A4%87%E7%94%A8%E6%BA%90/","title":"RSS备用源"},{"content":" Ubuntu20.04美化篇 像之前说过的，用Linux的起因是看到了很炫酷的桌面，在问了之后发现Ubuntu也能用deepin的dde桌面，甚至还找到了一篇教程。但是后来感觉有点大兴土木了（不是\n于是就打算只换个主题先用着看看，然后发现找的一堆教程都早已过了时效性了，有些功能早就挪了位置。所以此篇博客也只以文章发布时间后一段时间有时效性。期间在第一遍快完成的时候还把系统搞坏过一次，重启的时候开不了机一直在左上角闪横杠（其实应该是电脑的硬盘问题），重装了一次系统。然后还重来了一遍（悲\n操作步骤 1. 前置准备 先执行如下下载命令（可能有些命令不是必须的但我忘了）\nsudo apt update sudo apt-get update sudo apt install gnome-tweaks sudo apt install chrome-gnome-shell //这条非常重要 sudo apt install gnome-tweaks-extension 这个时候打开应用能搜索到Tweaks了（中文版应该叫优化）\n但打开后会发现是这样的（版本号不同可能大同小异）\n重点是Shell前面有个三角形，而我们换主题主要依赖的就是这个选项，因此这个时候需要登陆插件网站下载插件来将这个三角形去掉。\n打开gnome扩展网站：https://extensions.gnome.org/\n刚打开就会看到这样的提示让你下载浏览器插件\n重点来了，当时在这个地方栽了半天没想明白为什么，直接跳过了，也是第一遍失败的直接原因\n这个地方装插件用默认的Firefox是不行的！！！\n必须要换Chrome，再点击下载插件（访问谷歌插件商店的方式请自行发挥）\n2. 安装gnome扩展 访问：https://extensions.gnome.org/extension/19/user-themes/\n下载用户主题插件，或在上一步的页面搜索user-themes\n将按钮打开成ON\n如果用火狐的话会看见右边的画面\n3. 下载主题 访问gnome主题网站：https://www.gnome-look.org/\n选择一个自己喜欢的主题\n这里以WhiteSur Gtk为例\n点第一个下载即可\n配套的图标下载在这里\n下载方式相同\n4. 应用主题 默认的读取主题路径是/usr/share/themes\n默认的读取图标路径是/usr/share/icons\n这里注意，直接解压然后将文件夹复制粘贴过去是没有权限的\n所以直接一步到位解压文件到/usr/share/themes文件夹：\nsudo tar -xvJf ~/Downloads/WhiteSurDark.tar.xz -C /usr/share/themes 或将解压后的文件\nsudo cp -r+“空格”+~/你要复制的文件的原目录/你要复制的文件+“空格”+/usr/目标目录 然后更改这两项即可\n然后再在插件应用商店寻找更改任务栏的插件，博主电脑使用dash to dock会有bug，遂放弃而改用dock from dash\n在一次唤醒之后你可能会发现有两个dock，解决办法：\n卸载系统自带的Dock，命令如下：\nsudo apt remove gnome-shell-extension-ubuntu-dock 如果以后需要重新使用原生dock，安装命令如下：\nsudo apt install gnome-shell-extension-ubuntu-dock 然后就大功告成了\n配置鼠标光标 Cursor的操作大同小异，文件夹同样在icons里\n5. 配置登陆背景 下载ubuntu-20.04-change-gdm-background文件： wget https://raw.githubusercontent.com/thiggy01/change-gdm-background/master/change-gdm-background 出现443... failed: Connection refused.错误的解决方案：https://blog.csdn.net/m0_52650517/article/details/119831630\n给change-gdm-background文件执行的权限： sudo chmod 777 change-gdm-background 修改背景图片： sudo ./change-gdm-background /usr/share/backgrounds/Nick_Wilde_and_Judy_Hopps.jpg 其中/usr/share/backgrounds/Nick_Wilde_and_Judy_Hopps.jpg为背景图片所在路径。\n屏蔽紫色过渡动画： 对于登录系统的紫色过渡动画，就是输入密码回车，到进入系统这个过程的紫色动画，可以通过 gnome 的扩展进行屏蔽，名字是Good Bye GDM3 Login Screen to Desktop Flick for Ubuntu 20.04 only 地址为 https://extensions.gnome.org/extension/3037/good-bye-gdm-flick/。 ","date":"2022-05-18T22:04:44Z","image":"https://s1.ax1x.com/2022/05/18/O7Q4JO.jpg","permalink":"https://inariindream.fun/blog/2022/05/18/%E4%BF%9D%E5%A7%86%E7%BA%A7%E7%9A%84ubuntu20.04%E7%BE%8E%E5%8C%96/","title":"保姆级的Ubuntu20.04美化"},{"content":" 从零开始的Ubuntu安装（Hyper-V虚拟机篇） [TOC]\n其实我是先装的虚拟机再装的实机的，但是装完实机之后趁记忆比较深刻先写了上一篇实机的，但其实虚拟机还要简单一点。而用Hyper—V一键装机就更是极简了。\n安装步骤 确保系统是 Windows 10 专业版/企业版/教育版，且必须是64位操作系统才支持。\n如果不是那可以退出了，Win10家庭版不支持hyper-v。\n打开启动或关闭Windows功能\n将Hyper—V下属的两项都给勾上\n若第二项勾选不上则需要重启进入bios界面，不同型号的电脑进入方式不同，微星是按del，华硕是F2（其他的没用过建议自行使用搜索引擎） 进入bios后以微星主板amdcpu为例 依次点击\n然后重启电脑 此时应该可以将两项都勾选上了。 3. 完成后需要稍等一段时间，然后重启电脑； 4. 重启之后，点击“开始”，“所有程序”，点击“windows管理工具”然后就可以看到“Hyper-V”\n点击进入，便可根据自己的喜好一键装机了\n（保姆级服务\n","date":"2022-05-18T13:15:21Z","image":"https://s1.ax1x.com/2022/05/17/O4vPHS.png","permalink":"https://inariindream.fun/blog/2022/05/18/%E4%BB%8E%E9%9B%B6%E5%BC%80%E5%A7%8B%E7%9A%84ubuntu%E5%AE%89%E8%A3%85hyper-v%E8%99%9A%E6%8B%9F%E6%9C%BA%E7%AF%87/","title":"从零开始的Ubuntu安装（Hyper-V虚拟机篇）"},{"content":" 从零开始的Ubuntu安装（实机篇） [TOC]\n写在前面 想装Linux的原因最早是在空间看到派派发了一个Archlinux 的 deepin 桌面环境，感觉很炫酷且简洁，然后刚好自己有多的一台备用笔记本可以用来折腾，遂也想搞一个来钻研技术和提升逼格\n然后昨天在响哥手把手的教学下在虚拟机上面装好了Ubuntu，并且把镜像刻进了U盘里面，今天下午就进行了愉快的装机之旅了。\n在找教程的时候发现了一个对新手十分友好的教程，但是是英文的，有一定阅读门槛，还是先贴在这吧\nhttps://itsfoss.com/install-ubuntu-1404-dual-boot-mode-windows-8-81-uefi/\n由于在安装的时候没想到截图或拍照，所以部分步骤图用网图代替\n安装准备 一块空的8G以上的U盘（传输速度越快越好） 一台电脑\n众所周知，安装系统一般是需要系统光盘的，或者像大白菜那样的系统商业U盘，但是其实有个软件是能将镜像os直接烧录到U盘里面的，名字叫Rufus\n镜像的下载可以在国内的科大镜像站下载\n选中最新版下载\n注意一般浏览器下载目录默认在C盘的Downloads下，Ubuntu的镜像文件较大，下载前注意查看C盘剩余空间\n然后下好之后就可以开始烧录在U盘里了\n烧录之前一定注意U盘里原来的东西是否已备份，烧录过程会将U盘清空\n引导类型选择镜像文件，然后选择刚刚下载好的镜像文件\n分区类型的话老电脑一般选择GPT，比较新一点的可以选择MBR 到时候发现不对回来重新烧一遍吧\n然后就开始等待烧录，时间根据U盘性能不同而不同\n烧完之后就可以拔出U盘，这个时候准备工作就做完了。\n安装步骤 打开需要安装的电脑，在开机时候进入bios界面。不同品牌的电脑进入方式各不相同，例如微星的电脑普遍是狂按del进入，华硕的电脑是F2（同一品牌不同型号的电脑也可能会有一定差异，建议百度一下自己的电脑型号）\n在Security里面将 Secure Boot改为disabled\n在boot里面将Boot Mode改为 UEFI\n（我的华硕笔记本当时好像只用把UEFI Boot的选项改为True就行了，不是按这两步来的）\n之后保存并退出。\n插入烧录好的U盘，开机狂按F2（华硕），选择从什么硬盘启动，这个时候要选择自己插入U盘的型号（注意，不是U盘在电脑里自己改的名称，是型号）例如我选择了Kingston Traveler 2.0\nEnter之后又来到一个选择界面，选择最上面那项（我的是Try or install Ubuntu）\n然后稍等片刻即可进入安装\n进入Ubuntu界面后选择Install Ubuntu\n语言选择部分略过，按照自己的喜好来\n如果原来电脑上有Win10系统的话，可以选择Install Ubuntu alongside Win10，之后只用在开机的时候选择想进的系统即可。\n选择时区\n设置账户名和密码\n开始安装即可\n大功告成 安装完成之后重启即可\n开始愉快的Ubuntu探索之旅吧\n","date":"2022-05-17T15:52:08Z","image":"https://s1.ax1x.com/2022/05/26/XECXcR.jpg","permalink":"https://inariindream.fun/blog/2022/05/17/%E4%BB%8E%E9%9B%B6%E5%BC%80%E5%A7%8B%E7%9A%84ubuntu%E5%AE%89%E8%A3%85%E5%AE%9E%E6%9C%BA%E7%AF%87/","title":"从零开始的Ubuntu安装（实机篇）"},{"content":"最大子段和 题目描述 给出一个长度为 $n$ 的序列 $a$，选出其中连续且非空的一段使得这段和最大。\n思路 简单的前缀和 + 递推，用$a[i]$记录到第$i$个位置时与$i$相连续的最大值，用$ans$记录字段和的最大值\n转移方程a[i] = max(x, a[i - 1] + x)， ans = max(a[i], ans)\n代码 void solve(){ int n; cin \u0026gt;\u0026gt; n; vector\u0026lt;int\u0026gt;a(n); int ans = -INF; int x; for (int i = 0; i \u0026lt; n; i++) { cin \u0026gt;\u0026gt; x; if (i == 0){ a[i] = x; } else{ a[i] = max(x, a[i - 1] + x); ans = max(a[i], ans); } } cout \u0026lt;\u0026lt; ans \u0026lt;\u0026lt; endl; } 地毯 题目描述 在 $n\\times n$ 的格子上有 $m$ 个地毯。\n给出这些地毯的信息，问每个点被多少个地毯覆盖。\n输入格式 第一行，两个正整数 $n,m$。意义如题所述。\n接下来$m$ 行，每行两个坐标 $(x_1,y_1)$ 和 $(x_2,y_2)$，代表一块地毯，左上角是 $(x_1,y_1)$，右下角是 $(x_2,y_2)$。\n输出格式 输出 $n$ 行，每行 $n$ 个正整数。\n第 $i$ 行第 $j$ 列的正整数表示 $(i,j)$ 这个格子被多少个地毯覆盖。\n$n, m \\leqslant 1000$\n思路 差分\n复习 何为差分 假设我们现在要给[2,5]这个区间加一。\n原来的序列是： 0 0 0 0 0 0 0 0\n这时候我们在2上面打 +1 标记， 6 上面打 -1 标记。\n那么现在的序列是： 0 +1 0 0 0 -1 0\n这样的话，从左往右扫描这个数组，记录当前经过的标签之和，这个和就是那个数对应的答案\n这样，对于每个区间加操作，只需要$O(1)$的时间打上标记， 最后扫描输出即可\n现在把问题拓展到二维。假设我们要覆盖$[(2,2),(5,5)]$ ，那么标记便可以这样打：\n0 +1 0 0 0 -1 0 +1 0 0 0 -1 0 +1 0 0 0 -1 0 +1 0 0 0 -1 0 0 0 0 0 0 即在每一行都按照一维的方式来操作：\nfor (int j = x1; j \u0026lt;= x2; j++) { cf[j][y1]++; cf[j][y2 + 1]--; } 这样一来,打标记时候的复杂度为$O(n)$,总复杂度为$O(mn + n^2)$\n代码 int cf[2000][2000]; void solve(){ int n, m; cin \u0026gt;\u0026gt; n \u0026gt;\u0026gt; m; int x1, y1, x2, y2; for (int i = 0; i \u0026lt; m; i++) { cin \u0026gt;\u0026gt; x1 \u0026gt;\u0026gt; y1 \u0026gt;\u0026gt; x2 \u0026gt;\u0026gt; y2; for (int j = x1; j \u0026lt;= x2; j++) { cf[j][y1]++; cf[j][y2 + 1]--; } } for (int i = 1; i \u0026lt;= n; i++) { for (int j = 1; j \u0026lt;= n; j++) { cf[i][j] += cf[i][j - 1]; cout \u0026lt;\u0026lt; cf[i][j] \u0026lt;\u0026lt; \u0026#34; \u0026#34;; } cout \u0026lt;\u0026lt; endl; } } 海底高铁 题目描述 一个铁路经过$N$个城市，每个城市一个站，但不能直达，只能相邻城市的一段铁路单独买票\n对于一段铁路$i$，连接了城市$i$和城市$i+ 1$，有两种买票方式。\n单独购买纸质票，价格为$A_i$\n买卡，只需要花工本费$C_i$，每次通行花费$B_i（B_i \u0026lt; A_i )$\n现在一个人要出差去$M$个城市，按照$P_i$的顺序访问，可能会多次访问一个城市，且相邻访问的城市位置不一定相邻，而且不会是同一个城市。\n求总费用的最小值\n$M，N \\leqslant 10^5, A_i,B_i,C_i \\leqslant 10 ^ 5$\n思路 前缀和和差分数组结合， 对于其中一小段，我们要么全部买纸票，要么全部刷卡。\n所以问题拆分成了统计每一小段经过的总次数，再在两种费用方案之间取最小值\n后者不难，此题的考点在前者，直接暴力统计会绎演顶证，鉴定为纯纯的$TLE$\n因此先用差分数组预处理每次要去的起点和终点，打上标记。\n然后再求每一项的前缀和，这样最后前缀和数组就是每一段铁路的经过次数了\n例：如果我们要经过$1-3$ 和 $2-4$\n先打上标记\n+1 -1 +1 +1 -1 -1 - - - - - -- - - -- - -- -- - -- -- 1 2 3 4 5 1 2 3 4 5 1 2 3 4 5 图1 图2 图3 再进行前缀和\n1 2 2 1 0 - - - - - 1 2 3 4 5 图4 更多细节见代码\n代码 void solve(){ int n, m; cin \u0026gt;\u0026gt; n \u0026gt;\u0026gt; m; vector\u0026lt;ll\u0026gt;p(n + 2);//station vector\u0026lt;ll\u0026gt;cnt(n + 2);//count for (int i = 1; i \u0026lt;= m; i++) { cin \u0026gt;\u0026gt; p[i]; } ll ma, mi; for (int i = 1; i \u0026lt;= m - 1; i++) { ma = max(p[i], p[i + 1]); mi = min(p[i], p[i + 1]); cnt[ma]--;//因为第i段铁路是从第i连到第i+1个城市，所以减去ma就是减去第ma-1 +1段铁路 cnt[mi]++; } for (int i = 1; i \u0026lt;= n; i++) {//WA了一发，开始的range是[1,m] cnt[i] += cnt[i - 1];//这就是为什么前缀和处理的话数组下标要从1开始 } int a, b, c; ll ans = 0; for (int i = 1; i \u0026lt;= n - 1; i++) { cin \u0026gt;\u0026gt; a \u0026gt;\u0026gt; b \u0026gt;\u0026gt; c; ans += min(a * cnt[i], b * cnt[i] + c); } cout \u0026lt;\u0026lt; ans \u0026lt;\u0026lt; endl; } 最大加权矩形 题目描述 一个$N \\times N$的矩阵，矩阵里每个点有对应的权值，求子矩阵权值和的最大值\n$N \\leqslant 120$\n思路 一眼二维前缀和，数据范围很小，直接用$O(n^4)$的复杂度莽过去了。\n但二维前缀和的公式还是不熟\n二维矩阵的前缀和（到0，0点的）:\n$$f[i][j] = f[i][j - 1] + f[i -1][j] - f[i - 1][j - 1] + a[i][j]$$ 子矩阵的和从$(i，j)$到$(k，l)$ $O(n^4)$： $$f[k][l] - f[k][j - 1] - f[i - 1][l] + f[i - 1][j - 1]$$\n代码 （$O(n^4)$） int a[125][125], f[125][125]; void solve(){ int n; cin \u0026gt;\u0026gt; n; for (int i = 1; i \u0026lt;= n; i++) { for (int j = 1; j \u0026lt;= n; j++) { cin \u0026gt;\u0026gt; a[i][j]; f[i][j] = f[i][j - 1] + f[i -1][j] - f[i - 1][j - 1] + a[i][j]; } } int ans = -INF; for (int i = 1; i \u0026lt;= n; i++) { for (int j = 1; j \u0026lt;= n; j++) { for (int l = i; l \u0026lt;= n; l++) { for (int i1 = j; i1 \u0026lt;= n; i1++) { ans = max(f[l][i1] - f[l][j - 1] - f[i - 1][i1] + f[i - 1][j - 1], ans); } } } } cout \u0026lt;\u0026lt; ans \u0026lt;\u0026lt; endl; } 优化版 思路 我们可以考虑将矩形压缩成一维，比如处理一个2行的矩形时，将a [ i ][ j ]与a [ i - 1 ][ j ]相加，成为一个新的数组f [ n ]，再使用上述代码进行动态规划，找出局部最优解。\n首先进行前缀和，这样可以用减法来快速表示压缩的矩形。\n可以模拟一下，a[ i ][ j ] - a[ i - k ][ j ]正好是以i为最下面一行，往上k行的压缩结果，这就很方便地表示了压缩后的矩形。\n那再次循环，运用第一个代码的简单变形，可以求出以i为最下一行，向上k行的矩形最大值，多次更新ans就行\n代码 void solve2(){ int n; cin \u0026gt;\u0026gt; n; for (int i = 1; i \u0026lt;= n; i++) { for (int j = 1; j \u0026lt;= n; j++) { cin \u0026gt;\u0026gt; a[i][j]; a[i][j] += a[i - 1][j]; // 前缀和处理 } } int ans = -INF; int f1[150] = {0}, dp[150] = {0}; for (int i = 1; i \u0026lt;= n; i++) { for (int k = 1; k \u0026lt;= i; k++) { for (int j = 1; j \u0026lt;= n; j++) { f1[j] = a[i][j] - a[i - k][j]; dp[j] = max(dp[j - 1] + f1[j], f1[j]); ans = max(ans, dp[j]); } } } cout \u0026lt;\u0026lt; ans \u0026lt;\u0026lt; endl; } 这是前一种方法的速度 这是后一种的 可以看出来优化还是十分明显的\n领地选择 题目描述 首都被认为是一个占地 $C \\times C$ 的正方形。小 Z 希望你寻找到一个合适的位置，使得首都所占领的位置的土地价值和最高。\n思路 与上一题的第一种方法类似，使用二位前缀和预处理，然后$O(n^2)$扫一遍即可\n代码 int a[1005][1005]; int f[1005][1005]; void solve(){ int n, m, c; cin \u0026gt;\u0026gt; n \u0026gt;\u0026gt; m \u0026gt;\u0026gt; c; int ma = -INF; for (int i = 1; i \u0026lt;= n; i++) { for (int j = 1; j \u0026lt;= m; j++) { cin \u0026gt;\u0026gt; a[i][j]; f[i][j] = f[i][j - 1] + f[i - 1][j] - f[i - 1][j - 1] + a[i][j]; } } int x, y; for (int i = c; i \u0026lt;= n; i++) { for (int j = c; j \u0026lt;= m; j++) { if (f[i][j] - f[i][j - c] - f[i - c][j] + f[i - c][j - c] \u0026gt; ma){ ma = f[i][j] - f[i][j - c] - f[i - c][j] + f[i - c][j - c]; x = i - c + 1; y = j - c + 1; } } } cout \u0026lt;\u0026lt; x \u0026lt;\u0026lt; \u0026#34; \u0026#34; \u0026lt;\u0026lt; y \u0026lt;\u0026lt; endl; } 光骓者的荣耀 题目描述 小 K 为了关心人民生活，决定定期进行走访。他每一次会从 $1$ 号城市到 $n$ 号城市并在经过的城市进行访问。其中终点必须为城市 $n$。\n不仅如此，他还有一个传送器，传送半径为 $k$，也就是可以传送到 $i-k$ 和 $i+k$。如果目标城市编号小于 $1$ 则为 $1$，大于 $n$ 则为 $n$。\n但是他的传送器电量不足，只能传送一次，况且由于一些原因，他想尽量快的完成访问，于是就想问交通部部长您最快的时间是多少。\n思路 先前缀和预处理，然后以区间大小为$k$扫一遍求传送的最大值即可\n（92分坑）：在求区间和最大值的时候，下标不要从1开始，因为cnt[i + k] - cnt[i]如果从1开始的话会忽略cnt[1]本身的值\n代码 void solve(){ int n, k; cin \u0026gt;\u0026gt; n \u0026gt;\u0026gt; k; vector\u0026lt;ll\u0026gt;a(n); vector\u0026lt;ll\u0026gt;cnt(n); for (int i = 1; i \u0026lt; n; i++) { cin \u0026gt;\u0026gt; a[i]; } partial_sum(all(a),cnt.begin()); ll ans = -1; for (int i = 0; i \u0026lt; n - k; i++) { ans = max(ans, cnt[i + k] - cnt[i]); } cout \u0026lt;\u0026lt; cnt[n - 1] - ans \u0026lt;\u0026lt; endl; } ","date":"2022-04-30T13:15:13Z","image":"https://s1.ax1x.com/2022/04/30/LzHLHf.jpg","permalink":"https://inariindream.fun/blog/2022/04/30/%E6%B4%9B%E8%B0%B7%E4%B8%93%E9%A2%98%E8%AE%B0%E5%BD%95%E5%89%8D%E7%BC%80%E5%92%8C%E4%B8%8E%E5%B7%AE%E5%88%86/","title":"洛谷专题记录（前缀和与差分）"},{"content":"4.22 （待补） 题目链接\n题解链接\n描述 给定两个队列$a$,$b$，每队$n$人，身高分别为$a_i$, $b_i$\n每队的人都可以与前后相邻者交换位置，次数不限，仅在同队换，问使$\\sum (a_i - b_i)^2$最小的交换次数\n思路 两队同时换和只换一队效果相同，因此只需选一队来换。\n$\\sum (a_i - b_i)^2 = \\sum((a_i + b_i)^2 - 4 * a_i * b_i)$\n前者是定值，因此只需找到使后面那项最大的方式即可\n就是求一个数列相对于另一个的逆序对（好像某次abc做过，但后来没补题\u0026hellip;）\n代码（copy的） const int mod = 1e8 - 7; long long n, x[10000005], p[1000005], ans = 0; struct fire { int hi, bh; } l1[1000005], l2[1000005]; bool cmp1(fire a, fire b) { return a.hi \u0026lt; b.hi; } void msort(int s, int t)//归并排序; { if (s == t)return; int mid = (s + t) / 2; msort(s, mid); msort(mid + 1, t); int i = s, k = s, j = mid + 1; while (i \u0026lt;= mid \u0026amp;\u0026amp; j \u0026lt;= t) { if (x[i] \u0026lt;= x[j]) { p[k] = x[i]; ++k; ++i; } else { p[k] = x[j]; ++k; ++j; ans = (ans + mid - i + 1) % mod; //此处找到逆序对，mid-i~mid中数全都与j构成逆序，还会少算一个，+1; } } while (i \u0026lt;= mid) { p[k] = x[i]; ++k; ++i; } while (j \u0026lt;= t) { p[k] = x[j]; ++k; ++j; } for (int i = s; i \u0026lt;= t; i++) { x[i] = p[i]; } } int main() { scanf(\u0026#34;%lld\u0026#34;, \u0026amp;n); for (int i = 1; i \u0026lt;= n; i++) scanf(\u0026#34;%d\u0026#34;, \u0026amp;l1[i].hi), l1[i].bh = i; for (int i = 1; i \u0026lt;= n; i++) scanf(\u0026#34;%d\u0026#34;, \u0026amp;l2[i].hi), l2[i].bh = i; sort(l1 + 1, l1 + n + 1, cmp1); sort(l2 + 1, l2 + n + 1, cmp1); //排序; for (int i = 1; i \u0026lt;= n; i++) x[l2[i].bh] = l1[i].bh; msort(1, n); //调用归并; printf(\u0026#34;%lld\u0026#34;, ans); return 0; } 4.23 (BFS板题) 题目链接\n题目描述 给出一个 N 个顶点 M 条边的无向无权图。\n问从顶点 1 开始，到其他每个点的最短路有几条。\n思路 BFS板题，每次遍历的时候记录层数，如果当前遍历到的$x$节点是$t$节点的下一层，那么$x$的最短路数量就是当前$x$的最短路数量加上$t$的最短路数量\n因为每次遍历到的时候都会加一遍，就相当于乘法了\n代码 const int N = 1e6 + 5; const int mod = 100003; vector\u0026lt;int\u0026gt;e[N]; int used[N]; int cnt[N]; int dep[N]; void bfs(){ queue\u0026lt;int\u0026gt;q; dep[1] = 0; used[1] = 1; q.push(1), cnt[1] = 1; while (!q.empty()){ int t = q.front(); q.pop(); for (auto x : e[t]) { if (!used[x]){ used[x] = 1;//标记为遍历过了 dep[x] = dep[t] + 1;//层数++(因为是bfs所以层数一定是最小的) q.push(x); } if (dep[x] == dep[t] + 1){//如果当前x是t的下一层 cnt[x] = (cnt[x] + cnt[t]) % mod;//那么x的最短路数量再加上t的最短路数量(每个x都加相当于乘) } } } } void solve(){ int n, m; cin \u0026gt;\u0026gt; n \u0026gt;\u0026gt; m; for (int i = 0; i \u0026lt; m; i++) { int x , y; cin \u0026gt;\u0026gt; x \u0026gt;\u0026gt; y; e[x].push_back(y); e[y].push_back(x); } bfs(); for (int i = 1; i \u0026lt;= n; i++) { cout \u0026lt;\u0026lt; cnt[i] \u0026lt;\u0026lt; endl; } } int main(){ ios::sync_with_stdio(false); cin.tie(nullptr); solve(); return 0; } 4.26 题目链接 描述 判断有没有一种办法可以将从$1$ 到 $N$ 的 $N$个人排成一排，并满足给定的$M$个要求。\n对于每个要求给出两个整数 $A_i$和$B_i$，表示编号$A_i$和$B_i$的人是相邻的\n保证每个要求都不同，即给出$1$，$5$就不会再给出$5$，$1$或重复的\n分析 满足题目要求的只有无环的链\n即判断两件事：\n1.度数是否大于等于$2$\n2.是否有环\n代码 const int N = 1e5 + 5; int father[N]; int ufind(int x) {//寻找操作 if (x == father[x]) return x; int fx = ufind(father[x]); return father[x] = fx; } void solve() { int n, m; cin \u0026gt;\u0026gt; n \u0026gt;\u0026gt; m; for (int i = 0; i \u0026lt;= n; i++) { father[i] = i; } map\u0026lt;int, int\u0026gt; mp; int ok = (n \u0026gt; m); // 这一点最开始没想到，如果要求大于n - 1条可以直接返回 if (!ok) { cout \u0026lt;\u0026lt; \u0026#34;No\u0026#34; \u0026lt;\u0026lt; endl; return; } int x, y; for (int i = 0; ok \u0026amp;\u0026amp; i \u0026lt; m; i++) { cin \u0026gt;\u0026gt; x \u0026gt;\u0026gt; y; mp[x]++; mp[y]++; int fx = ufind(x); int fy = ufind(y); if (fx != fy) { father[fx] = y; } ok = (fx != fy); // 判断是否指向同一个（也包括判断环） if (mp[x] \u0026gt; 2 || mp[y] \u0026gt; 2) // 判断度数 ok = 0; } cout \u0026lt;\u0026lt; (ok ? \u0026#34;Yes\u0026#34; : \u0026#34;No\u0026#34;) \u0026lt;\u0026lt; endl; } int main() { ios::sync_with_stdio(false); cin.tie(nullptr); solve(); return 0; } 好像能默写并查集中“并”的部分了= =\n查的部分好像还是只能抄板子 菜菜QWQ\n（突然发现图论的部分涉及的不多\n4.27 题目链接 描述 现给定两个 四位素数 a,b。 你可以执行多次下面的操作：\n修改数字 a 的某一位, 使其成为另一个 四位素数。\n例如，1033→1733，其中 1033 与 1733 均为素数。\n问至少多少次变换后能从 a 得到 b ? 或回答不可能\n思路 想到了和cf某场的2B很像，只不过那场不需要按位处理，而是加1或加2后取余，做法是BFS。那这题也一样，但开始没想到怎么去枚举每一位的数字的变化，甚至想用to_string()来做，后来发现取每一位取模后除就行了\u0026hellip;是C语言期末考试难度的题\u0026hellip;\n提醒自己多注意细节问题，多个$testcase$的时候一定要将全局变量清空！！！\n更多细节见代码\n代码 int prime[10000], used[10000]; int cnt[10000]; void init(){ int j; for (int i = 1000; i \u0026lt;= 10000; i++) { for (j = 2; j \u0026lt; i; j++) { if (i % j == 0){ prime[i] = 0; break; } } if (j == i){ prime[i] = 1; } } } int bfs(int x, int y){ for (int i = 1000; i \u0026lt; 10000; i++) { // 因为忘清空WA了一次 cnt[i] = 0; used[i] = 0; } queue\u0026lt;int\u0026gt;q; int temp = 0, v[4]; q.push(x); used[x] = 1; cnt[x] = 0; while (!q.empty()){ int t = q.front(); if (t == y) return cnt[t]; q.pop(); v[0] = t / 1000; v[1] = t % 1000 / 100; v[2] = t % 100 / 10; v[3] = t % 10; for (int i = 0; i \u0026lt; 4; i++) { int vtemp = v[i]; for (int j = 0; j \u0026lt; 10; j++) { if (j != vtemp){ v[i] = j; temp = 1000 * v[0] + 100 * v[1] + 10 * v[2] + v[3]; if (prime[temp] \u0026amp;\u0026amp; !used[temp]){ q.push(temp); used[temp] = 1; cnt[temp] = cnt[t] + 1; } // if (temp == y) // return cnt[temp];后来发现这步完全是多余的，因为如果是第一次到的话cnt应该是没值的 } v[i] = vtemp; // 写的时候遗漏了这一步，在进入下一个i的循环之前要将上一次的v[i]复原 } } } return -1; // 前面都没return这里只能return -1了 } void solve(){ int n; cin \u0026gt;\u0026gt; n; init(); int a, b; while (n--){ cin \u0026gt;\u0026gt; a \u0026gt;\u0026gt; b; cout \u0026lt;\u0026lt; bfs(a, b) \u0026lt;\u0026lt; endl; } } 这种简单题以后争取十分钟以内切吧（\n4.28 题目链接 描述 给定一个$H$行和$W$列的网格，我们让$(i,j)$表示从北边第i行和从西边第j列的网格\n在一个网格上修建一个火车站的代价是$A_{i,j}$\n在两个网格间建一条铁轨的代价是这两个点位置的曼哈顿距离\n求造一条铁路的最小花费\n思路 基本拿到手就是懵的，知道要用dp去做，但是完全没思路，看了题解视频好像是dp + 二维前缀和的思想去做。抄了份代码过了之后看了贴两份代码吧，之后再补（\n（4.29补）： 看懂思路了，分为两种情况考虑：\n第二个点的$x$和$y$均大于第一个点，此时向第二个点的左上方扫 第一个点只有$x$大于第二个点，此时向第二个点的右上方扫 当然，在二维数组里面往斜上方硬扫应该是会超时的，复杂度应该是$O(n^2m^2)$\n所以在第一次扫的时候要利用类似二维前缀和的思想去处理（其实感觉dp思想多一点，但是dls题解说是前缀和）\n对于第一种情况，$ans$拆开来的结果是\n$$A_{x2y2} + C \\times (x_2 + y_2) + A_{x1y1} - C \\times (x_1 + y_1)$$\n当第二个点确定以后，问题就转化成求$A_{x1y1} - C \\times (x_1 + y_1)$的最小值了，用$f[i][j]$去记录左上方的这个式子的最小值\n可得转移方程为f[i][j] = min(f[i-1][j],f[i][j-1])\n然后进行答案的更新ans = min(ans,f[i][j] + a[i][j] + c * (i + j))（注：$f[i][j]$是不包含$a[i][j]$的）\n最后，已经在$a[i][j]$更新过$ans$了，那就可以把$a[i][j]$算进去了f[i][j] = min(a[i][j] - c * (i + j),f[i][j])\n第二种情况往右上扫思路相同，略。\n代码（copy） /*** 第一份 ***/ const int N = 1005; ll a[N][N],b[N],d[N]; void solve() { for (ll i = 0; i \u0026lt; N; i++) b[i] = d[i] = 1e18; ll n, m, c; ll ans = 1e18; cin \u0026gt;\u0026gt; n \u0026gt;\u0026gt; m \u0026gt;\u0026gt; c; for (ll i = 1; i \u0026lt;= n; i++) { for (ll j = m; j \u0026gt;= 0; j--) d[j] = min(d[j], d[j + 1]); for (ll j = 1; j \u0026lt;= m; j++) { cin \u0026gt;\u0026gt; a[i][j]; b[j] = min(b[j], b[j - 1]); d[j] = min(d[j], d[j + 1]); ans = min(ans, b[j] + a[i][j] + c * i + c * j); ans = min(ans, d[j] + a[i][j] + c * i - c * j); b[j] = min(b[j], a[i][j] - c * i - c * j); d[j] = min(d[j], a[i][j] - c * i + c * j); } } cout \u0026lt;\u0026lt; ans; } /*** 第二份（好像还有注释 太良心了） ***/ const int N = 1100 ; int n,m ; int a[N][N] ; ll f[N][N],c ; // 其实就是找到两个点，这两个点的 C * (| x1 - x2 | + | y1 - y2 |) + a_x1_y1 + a_x2_y2 // 为了让这个值更小，我们可以使用常用的技巧将这个式子拆开 // 拆开之后看看 值有没有改变 // 发现两个点的位置会有四种关系，，如果定义一种偏序关系，那么我们就可以设定为2种关系 // 1. 第一个点完全在第二个点的下面，就是说，第一个点的 x1 和 y1 分别小于 x2，y2 // 那么拆开式子之后就是 a_x1_y1 + C * (x2 - x1 + y2 - y1) + a_x2_y2 // a_x2_y2 + C * (x2 + y2) + a_x1_y_1 - C * (x1 + y1) ; // 为了让这个式子最小值，那么当固定了x2，那么就需要求出1这个点的 a_x1_y_1 - C * (x1 + y1) 最小值 // 如果让第一个点的 x 永远大于第二个点 // a_x1_y1 + a_x2_y2 + C * ( x1 - x2 + y2 - y1) ; // a_x2_y2 + C * (-x2 + y2) + a_x1_y1 + c * (x1 - y1) ; int main(){ scanf(\u0026#34;%d%d%lld\u0026#34;,\u0026amp;n,\u0026amp;m,\u0026amp;c) ; for(int i = 1 ;i \u0026lt;= n ; i ++) for(int j = 1; j \u0026lt;= m ; j ++) scanf(\u0026#34;%d\u0026#34;,\u0026amp;a[i][j]) ; ll ans = 1e18 ; memset(f,0x3f,sizeof f) ; for(int i = 1; i \u0026lt;= n ; i ++){ for(int j = 1; j \u0026lt;= m ; j ++){ f[i][j] = min(f[i-1][j],f[i][j-1]) ; //cout \u0026lt;\u0026lt; i \u0026lt;\u0026lt; \u0026#34; \u0026#34; \u0026lt;\u0026lt; j \u0026lt;\u0026lt; \u0026#34; \u0026#34; \u0026lt;\u0026lt; f[i][j] + a[i][j] + c * (i + j) \u0026lt;\u0026lt; \u0026#34;\\n\u0026#34; ; ans = min(ans,f[i][j] + a[i][j] + c * (i + j)) ; f[i][j] = min(a[i][j] - c * (i + j),f[i][j]) ; } } memset(f,0x3f,sizeof f) ; for(int i = 1 ; i \u0026lt;= n ; i++){ for(int j = m ; j \u0026gt;= 1 ;j --){ f[i][j] = min(f[i-1][j],f[i][j+1]) ; //cout \u0026lt;\u0026lt; i \u0026lt;\u0026lt; \u0026#34; \u0026#34; \u0026lt;\u0026lt; j \u0026lt;\u0026lt; \u0026#34; \u0026#34; \u0026lt;\u0026lt; f[i][j] \u0026lt;\u0026lt; \u0026#34; \u0026#34; \u0026lt;\u0026lt; a[i][j] + c * (j - i) \u0026lt;\u0026lt; \u0026#34;\\n\u0026#34; ; ans = min(ans,f[i][j] + a[i][j] + c * (i - j)) ; f[i][j] = min(a[i][j] + c * (j - i),f[i][j]) ; } } printf(\u0026#34;%lld\\n\u0026#34;,ans); return 0 ; } 4.29 题目链接 描述 桌子上从左到右放着 $n$ 个糖果。糖果从左到右编号，第 $i$ 块糖果的重量为 $w_i$。小明和小红要吃糖果。\n小明从左边开始吃任意数量的糖果。（连续吃，不能跳过糖果）\n小红从右边开始吃任意数量的糖果。（连续吃，不能跳过糖果）\n当然，如果小明吃了某个糖果，小红就不能吃它（反之亦然）。\n他们的目标是吃同样重量的糖果，请问此时他们总共最多能吃多少个糖果？\n思路 div4的F题原题，方法是双指针，当两个指针没合到一起时分三种情况讨论：\n当小明当前吃的重量小于小红，那么小明吃一颗，且指针向右移动一位\n小红小于小明，小红吃一颗，指针左移一位\n二人相等，则此时更新$ans$，$ans = max(ans, l + 1 + n - r)$\n代码 void solve(){ int n; cin \u0026gt;\u0026gt; n; vector\u0026lt;int\u0026gt;a(n); for (int i = 0; i \u0026lt; n; i++) { cin \u0026gt;\u0026gt; a[i]; } int l = -1, r = n; ll al = 0, bo = 0; int ans = 0; while (l \u0026lt; r){ if (al \u0026lt; bo){ l++; al += a[l]; } else if (al \u0026gt; bo){ r--; bo += a[r]; } else{ ans = max(ans, l + 1 + n - r); l++; al +=a[l]; } } cout \u0026lt;\u0026lt; ans \u0026lt;\u0026lt; endl; } 光速下班\n4.30 题目链接 描述 有一个长度为 $∑a_i$ 的木板，需要切割成 $n$ 段，每段木板的长度分别为 $a_1,a_2,…,a_n$。\n每次切割，会产生大小为被切割木板长度的开销。\n请你求出将此木板切割成如上 $n$ 段的最小开销。\n思路 倒着考虑，每次切割会产生大小为被切割木板长度的开销 $==$ 每次合并产生合并后长度的开销\n那么此时这个题就变成了非常经典的二叉堆的题目了 且一月份做过原\n用优先队列，复杂度是$O(nlogn)$\n优先队列还是没怎么用过，多练练吧\n代码 void solve(){ int n; cin \u0026gt;\u0026gt; n; priority_queue\u0026lt;ll,vector\u0026lt;ll\u0026gt;,greater\u0026lt;ll\u0026gt;\u0026gt;q; for (int i = 0; i \u0026lt; n; i++) { int x; cin \u0026gt;\u0026gt; x; q.push(x); } ll ans = 0; while (q.size() \u0026gt; 1){ ll t1 = q.top(); q.pop(); ll t2 = q.top(); q.pop(); q.push(t1 + t2); ans += t1 + t2; } cout \u0026lt;\u0026lt; ans \u0026lt;\u0026lt; endl; } 光速下班\n拓展 题意完全一样，只是$n$的范围由$10^5$增加至$10^7$，$a_i$仍为$10^5$\n思路 回到问题的本质，很容易想到就是排序然后选最小两堆，再把最小的那一堆插入。\n但是对于$10^7$的数据，$O(nlogn)$的插入复杂度显然是不可接受的\n那就需要优化插入操作的复杂度了，且将初始化的排序优化为桶排序（因为$a_i$只有$10^5$）\n做法是建立两个队列，将桶排的结果放进第一个队列$Q_1$，将合并的结果放进第二个队列$Q_2$，每次取两个队列的最小值合并\n(其实就是把合并的结果单独放在一个队列里面，这样就不用插入了)\n复杂度为$O(n)$\n代码 int cnt[100005]; queue\u0026lt;ll\u0026gt;q1; queue\u0026lt;ll\u0026gt;q2; ll temp; ll get_first(){ if (q2.empty() || (!q1.empty() \u0026amp;\u0026amp; q1.front() \u0026lt; q2.front())){ temp = q1.front(); q1.pop(); return temp; } else{ temp = q2.front(); q2.pop(); return temp; } } void solve(){ int n, x; cin \u0026gt;\u0026gt; n; for (int i = 0; i \u0026lt; n; i++) { cin \u0026gt;\u0026gt; x; cnt[x]++;//准备桶排 } for (int i = 0; i \u0026lt;= 100000; i++) {//WA了一发才发现最开始没挂等号... while (cnt[i]--) q1.push(i); //还是得多注意细心，第一次这个地方写成push(x)找了半天没发现 } ll ans = 0; ll a, b; while (q1.size() + q2.size() \u0026gt; 1){ a = get_first(); b = get_first(); q2.push(a + b); ans += a + b; } cout \u0026lt;\u0026lt; ans \u0026lt;\u0026lt; endl; } int main(){ ios::sync_with_stdio(false); cin.tie(nullptr); solve(); return 0; } 在洛谷原题被卡常数卡傻了，吸氧都过不去，571ms都不能过？？？\n5.1 （待补） 题目链接 描述 给定一个长度为$n$的数组$a_1,a_2,\u0026hellip;,a_n$。请求出下面式子模$1e9+7$的值。\n$$\\sum_{i = 1}^{n - 1}\\sum_{j = i + 1}^{n}(a_i XOR a_j)$$\n思路 待补\n代码（copy） const int mod = 1e9 + 7; int s[2][61]; void solve(){ int n; cin \u0026gt;\u0026gt; n; ll ans = 0; ll x; for (int i = 0; i \u0026lt; n; i++) { cin \u0026gt;\u0026gt; x; for (int j = 59; j \u0026gt;= 0; j--) { ll t = x \u0026gt;\u0026gt; j \u0026amp; 1; ans = (ans + s[t ^ 1][j] * ((1ll \u0026lt;\u0026lt; j) % mod)) % mod; s[t][j]++; } } cout \u0026lt;\u0026lt; ans \u0026lt;\u0026lt; endl; } 5.2 题目链接 描述 输入正整数$k$，找到所有正整数$y\\leqslant x$，使得$\\dfrac{1}{k} = \\dfrac{1}{x} + \\dfrac{1}{y}$’\n$k \\leqslant 10^7$\n思路 看到数据范围就知道肯定不可能$n^2$枚举，只能用$O(n)$扫一遍\n通过推公式化简得： $$x = \\dfrac{k \\times y}{y - k}$$\n而y有一个隐藏条件：因为$y\\leqslant x$，所以当y等于x的时候能取到最大值，而此时$x=y=2\\times k$\n所以$y$的范围就限定在了$（k \u0026lt; y \\leqslant 2\\times k）$\n因此只需要枚举每一个$y$，再判断$x$是否合法就行了\n需要注意的细节：\n1. 推出公式得到的$k \\times y$在$1e7$的时候会爆int\n2. 最好能不用double就不用double，判断是否为整数除了用（int）还可以分子对分母取模\n3. $y$的范围是从$k + 1$开始，如果从$k$开始会出现模$0$的状况而退出程序（或返回任意值）\n其实这三点就是做这个简单题踩过的坑\u0026hellip;现在知道为什么蓝桥杯会输麻了\n代码 void solve(){ int k; cin \u0026gt;\u0026gt; k; ll y, cnt = 0; for(y = k + 1; y \u0026lt;= 2 * k; y++){ ll ok = (k * y) % (y - k); if (!ok) cnt++; } cout \u0026lt;\u0026lt; cnt \u0026lt;\u0026lt; endl; } 5.3 题目链接 描述 给出一个长度为$N$的数组$A$和一个数字$k$\n请问数组A中有多少个子数组，其元素和为$k$？\n$1≤N≤2×10^5 ，|A_i|≤10^9，|k|≤10^{15}$\n思路 首先看数据范围，因为有负数，所以双指针应该是不行的。\n看到区间和首先想到的就是前缀和，遍历一遍$a_i$，每次如果找到区间和为$k$的就$cnt$++\n但是如果直接硬扫的话是$O(n^2)$的，肯定不行，所以要换另一种查询的方法，可以选择set或者map（这个思想zj在某次div2B也说过）\n以map为例，满足条件的前缀和和当前前缀和必定差值为$k$，只需要$O(n)$扫一遍，用map统计前缀和的出现次数然后cnt+=mp[sum - k]即可\n还有就是记得mp[0]记得初始化为$1$\n代码 ll get_sum(vector\u0026lt;int\u0026gt;\u0026amp; nums, ll k){ ll res = 0, sum = 0; unordered_map\u0026lt;ll,int\u0026gt;mp; mp[0] = 1; for(auto num : nums){ sum += num;//用sum表示当前到当前数字的前缀和 if (mp[sum - k] \u0026gt; 0) res += mp[sum - k]; mp[sum]++; } return res; } void solve(){ int n; cin \u0026gt;\u0026gt; n; ll k; cin \u0026gt;\u0026gt; k; vector\u0026lt;int\u0026gt;a(n); for (int i = 0; i \u0026lt; n; i++) { cin \u0026gt;\u0026gt; a[i]; } cout \u0026lt;\u0026lt; get_sum(a, k) \u0026lt;\u0026lt; endl; } 5.4 题目链接 描述 对于每一个长度为 $n$ 的排列 $a$，我们都可以按照下面的两种方式将它建成一个图：\n1.对于每一个 $1≤i≤n$，找到一个最大的 $j$ 满足 $1≤j\u0026lt;i,a_j\u0026gt;a_i$，将 $i$ 和 $j$ 之间建一条无向边\n2.对于每一个 $1≤i≤n$，找到一个最小的 $j$ 满足 $i\u0026lt;j≤n,a_j\u0026gt;a_i$，将 $i$ 和 $j$ 之间建一条无向边\n注意：建立的边是在对应的下标 $i$,$j$ 之间建的边\n请问有多少种长度为 $n$ 的排列 $a$ 满足，建出来的图含环\n排列的数量可能会非常大，请输出它模上 $10^9+7$ 后的值\n$n\\leqslant 10 ^ 6$\n思路 题面比较谜语人，大概翻译过来的意思就是，要找到含环的图的情况。但这样还是有点抽象，于是就反过来想。\n去寻找不含环的边，那么在题意中，不含环的图是这样的：\n对于一个数，要么只在左边有比他大的，要么只在右边有比他大的\n而只有一类图满足这种情况\n说人话就是找以最大值为顶点的单峰的图有多少个\n把这种情况去掉的情况就是含环的情况了\n对$n$的全排列为$n!$,以最大值为顶点的单峰图有$2^{n - 1}$种情况（摆法）：对于除了最大值的$n-1$个数，按降序摆放。每次摆放的时候都有在最大值左边和最大值右边两种选择，因此为$2^{n - 1}$\n答案即为 $$n! - 2^{n - 1}$$\n更多细节见代码（主要是取模）\n代码 const int mod = 1e9 + 7; const int N = 1e6 + 1; ll f[N]; ll qmi(ll m, ll k, ll p){//求 m^k mod p，时间复杂度 O(logk) ll res = 1 % p, t = m; while (k){ if (k\u0026amp;1) res = res * t % p; t = t * t % p; k \u0026gt;\u0026gt;= 1; } return res; } void init(){//初始化处理阶乘数组 f[1] = f[0] = 1ll; for (ll i = 2; i \u0026lt;= N; i++) { f[i] = i * f[i - 1] % mod; } } void solve(){ ll n; cin \u0026gt;\u0026gt; n; ll ans = qmi(2ll, n - 1, mod); cout \u0026lt;\u0026lt; (f[n] + mod - ans) % mod \u0026lt;\u0026lt; endl; // 这个地方的 + mod 非常关键，防止负数，很多要取模的题都应注意 } int main(){ ios::sync_with_stdio(false); cin.tie(nullptr); int kase; cin \u0026gt;\u0026gt; kase; init(); while (kase--) { solve(); } return 0; } 其实不太用得到快速幂，主要是在每次阶乘或平方的时候都要取模\n不过刚好换个更好的快速幂板子了吧（\n5.5 （待补） 题目链接 描述 给定$n$个点和$n-1$条路，镇从 $1$ 到 $n$ 依次编号，每条双向道路连接两个不同的村镇。接下来请你回答 $q$ 个问题，每次给出两个整数 $c, d$，表示现在分别有一个人在村镇 $c$,一个人在村镇 $d$，现在在 $c$ 的人要用最短的时间到达村镇$d$，在村镇 d 的人要以最短的时间到达村镇 $c$，假设两人同时出发，两人的速度也是一样的，每条双向道路的长度也是一样的，请问两人相遇的时候是在某一个村镇，还是在某条双向道路上？\n$2≤n≤100000$\n$1≤q≤100000$\n对于每一个询问 $1 ≤ c_i \u0026lt; d_i ≤ n$\n思路 这题拿到手最开始想的是就是一个简单的无向图求最短路然后判断奇偶，写了个BFS过了样例，自信满满交了一发，结果在第一个点就T飞了。\n重新读了一遍题才发现询问次数$q$是$1e5$的，这样的话无论是BFS还是Dijkstra跑一趟都会超时，因为在每次询问的时候都要memset距离数组和used数组一次（后发现是自己BFS套板子套的太笨了，一样有人用BFS过了）\n后在dls的建议下用LCA，因为$n-1$条路的话是树。套了个二月底写div1每日一题的LCA板子过了，但是还是晕晕乎乎的，有时间一定补!（顺便把代码用vector重构一下）\n看了别人的代码才发现发现BFS是完全能做的，因为完全没有必要去求两点间的最短路，可以直接预处理根节点到每个节点的距离，再求距离差的奇偶性即可，这样也只需要一次memset了。\n代码 const int N = 200005; struct node{ int t, next; }edge[2*N]; int a[N], head[N], tot, sum[N], depth[N], father[N][20]; void add(int x, int y){ edge[++tot].t = y; edge[tot].next = head[x]; head[x] = tot; } void dfs(int u, int p){ sum[u] = sum[p] + a[u]; depth[u] = depth[p] + 1; father[u][0] = p; for (int j = 1; j \u0026lt; 19; j++) { father[u][j] = father[father[u][j - 1]][j - 1]; } for (int i = head[u]; i ; i = edge[i].next) { int v = edge[i].t; if (v == p) continue; else if (v != p){ father[v][0] = u; dfs(v, u); } } } int LCA(int x, int y){ if (depth[x] \u0026lt; depth[y]) swap(x,y); for (int i = 18; i \u0026gt;= 0; i--) { if (depth[father[x][i]] \u0026gt;= depth[y]) x = father[x][i]; } if (x == y) return x; for (int i = 18; i \u0026gt;= 0; i--) { if (father[x][i] != father[y][i]) { x = father[x][i]; y = father[y][i]; } } return father[x][0]; } void solve(){ int n, m; cin \u0026gt;\u0026gt; n \u0026gt;\u0026gt; m; for (int i = 1; i \u0026lt;= n; i++) { a[i] = 1; } for (int i = 1, u, v; i \u0026lt; n; i++) { cin \u0026gt;\u0026gt; u \u0026gt;\u0026gt; v; add(u,v); add(v,u); } dfs(1,0); for (int i = 1; i \u0026lt;= m; i++) { int u, v; cin \u0026gt;\u0026gt; u \u0026gt;\u0026gt; v; cout \u0026lt;\u0026lt; ( (sum[u] + sum[v] - 2 * a[LCA(u, v)] )% 2 ? \u0026#34;Road\u0026#34; : \u0026#34;Town\u0026#34;) \u0026lt;\u0026lt; endl; } } /* --------------------------------- BFS过法 ---------------------------------*/ const int N = 1e5 + 5; vector\u0026lt;int\u0026gt;e[N]; int dis[N]; void bfs(){ memset(dis, -1, sizeof(dis)); dis[1] = 0; queue\u0026lt;int\u0026gt;q; q.push(1); while (!q.empty()){ int t = q.front(); q.pop(); for(auto i : e[t]){ if(dis[i] == -1){ dis[i] = dis[t] + 1; q.push(i); } } } } void solve(){ int n, m; cin \u0026gt;\u0026gt; n \u0026gt;\u0026gt; m; for (int i = 0; i \u0026lt; n - 1; i++){ int x, y; cin \u0026gt;\u0026gt; x \u0026gt;\u0026gt; y; e[x].push_back(y); e[y].push_back(x); } bfs(); int a, b; while (m--) { cin \u0026gt;\u0026gt; a \u0026gt;\u0026gt; b; cout \u0026lt;\u0026lt; ((abs(dis[a] - dis[b]) \u0026amp; 1) ? \u0026#34;Road\u0026#34; : \u0026#34;Town\u0026#34;) \u0026lt;\u0026lt; endl; } } 5.6 （代码待补） 题目链接 描述 现在给出一个表达式，形如 $a_1/a_2/a_3/\u0026hellip;/a_n$。\n如果直接计算，就是一个个除过去，比如 $1/2/1/4=1/8$。\n然而小 A 看到一个分数感觉很不舒服，希望通过添加一些括号使其变成一个整数。一种可行的办法是 $(1/2)/(1/4)=2$。\n现在给出这个表达式，求问是否可以通过添加一些括号改变运算顺序使其成为一个整数\n$2≤n≤10000,1≤t≤100,1≤ai≤2^{31}−1$\n思路 因为$a_2$前面的除号不能变成乘号，所以贪心的想，把后面除的数越变越小，再让$a_2$去除，才能得到最优解，因此用括号将$a_2$后面的括起来，即\n$$a_1 / (a_2 / (a_3 / a_4\u0026hellip;./a_n)) = a_1 \\times a_3 \\times\u0026hellip;\\times a_n / a_2 $$\n这样的话就找每个数和$a_2$的gcd，只要有一个不是1就行\n代码（copy） void solve(){ int n; cin \u0026gt;\u0026gt; n; if (n == 1) { puts(\u0026#34;Yes\u0026#34;); return; } vector\u0026lt;int\u0026gt;a(n); for (int i = 0; i \u0026lt; n; i++) { cin \u0026gt;\u0026gt; a[i]; } int temp = gcd(a[0], a[1]); a[1] /= temp; temp = a[1]; for (int i = 2; i \u0026lt; n; i++) { if (temp \u0026gt; 1) temp /= gcd(temp, a[i]); } cout \u0026lt;\u0026lt; (temp == 1 ? \u0026#34;Yes\u0026#34; : \u0026#34;No\u0026#34;) \u0026lt;\u0026lt; endl; } 5.7 （待补） 题目链接 描述 有一棵 $n$ 个节点的以1为根的有根树。现在可以对这棵树进行若干次操作，每一次操作可以选择树上的一个点然后删掉这个点和它的儿子之间的所有边。\n现在想要知道对于每一个 $k∈[1,n]$，最少需要多少次操作才能让图中恰好存在 $k$ 个联通块。\n输入格式 第一行输入一个正整数 $n$。\n第二行输入 $n−1$ 个整数 $f_i$ 表示 $i+1$ 号点的父亲，保证 $1≤fi≤i$。\n输出格式 输出 $n$ 个整数，第 $i$ 个数表示 $k=i$ 时的答案，如果无法让图中恰好存在 $k$ 个联通块，则输出$-1$。\n思路 每减去一个节点，产生的联通块的数量就是该节点的孩子数量。 所以， 实质上是一道单重背包问题的变形。\n代码（copy） const int MAXN = 3005; int n, max_x, root[MAXN], dp[MAXN]; void DP(){ for (int i = max_x; i \u0026gt;= 1; --i) { if (root[i] != 0) { for (int j = n; j \u0026gt;= root[i]; --j) { if (dp[j - root[i]] != 0) { if (dp[j] != 0) { dp[j] = min(dp[j], dp[j - root[i]] + 1); } else { dp[j] = dp[j - root[i]] + 1; } } } } } } void solve() { int x; cin \u0026gt;\u0026gt; n; max_x = 0; for (int i = 1; i \u0026lt; n; ++i) { cin \u0026gt;\u0026gt; x; root[x]++; if (max_x \u0026lt; x) { max_x = x; } } dp[0] = 1; DP(); for (int i = 0; i \u0026lt; n; ++i) { if (dp[i]) { cout \u0026lt;\u0026lt; dp[i] - 1 \u0026lt;\u0026lt; \u0026#34; \u0026#34;; } else { cout \u0026lt;\u0026lt; -1 \u0026lt;\u0026lt; \u0026#34; \u0026#34;; } } printf(\u0026#34;\\n\u0026#34;); } 5.8 题目链接 描述 有一个长度为$n$的序列，现在我们想把它切割成三段(每一段都是连续的），使得每一段的元素总和都相同，请问有多少种不同的切割方法\n思路 前缀和处理数组，从前往后扫一遍。切割成相同且连续的三段的话必然每个方案的切点都有$\\dfrac{sum}{3}$和$\\dfrac{2\\times sum}{3}$且前者一定在右者的左边，这样一来，只需要记录三分之一处的数量，然后在每次遇见三分之二处的时候加上到目前为止的左端点的数量即可。\n注意在$n$处不能当右端点。\n代码 ll l, r, x, cnt = 0; void solve(){ int n; cin \u0026gt;\u0026gt; n; vector\u0026lt;ll\u0026gt;a(n + 1); for (int i = 1; i \u0026lt;= n; i++) { cin \u0026gt;\u0026gt; x; a[i] = a[i - 1] + x; } if (a[n] % 3){ cout \u0026lt;\u0026lt; 0 \u0026lt;\u0026lt; endl; return; } l = a[n] / 3; r = 2 * l; x = 0; for (int i = 1; i \u0026lt;= n; i++) { if (a[i] == r \u0026amp;\u0026amp; i \u0026lt; n) cnt += x; if (a[i] == l) x++; } cout \u0026lt;\u0026lt; cnt \u0026lt;\u0026lt; endl; } 5.9 题目链接 描述 给定整数 $n$，想将$1∼n$这$n$个数字分成两组，每一组至少有一个数，并且使得两组数字的和的最大公约数最大，请输出最大的最大公约数。\n$n≤10^9$\n思路 将$n$个数的和设为$sum$，每次分组，就是分为$x$和$sum-x$，题意即求$gcd(x,sum - x)$的最大值。\n再次转化问题，即求$sum$最少能分成多少份，求此时让份数最小的$x$\n代码 void solve(){ ll n; cin \u0026gt;\u0026gt; n; ll sum; sum = (n + 1) * n / 2; for (ll i = 2; i * i \u0026lt;= sum; i++) { if (sum % i == 0) { cout \u0026lt;\u0026lt; sum / i \u0026lt;\u0026lt; endl; break; } } } 5.10 题目链接 描述 给定一个长度为 $n$ 数组 $A$，执行以下操作 $m$ 次：\n​ 选择一段区间 $[l,r]$，将区间中所有的数加上整数 $x$。\n​ 操作完成后回答 $k$ 个问题：\n​ 每个问题给定一段区间 $[l,r]$，输出区间中所有数的和。\n$1≤n≤2×10^5，1≤m,k≤10^5，|x|≤10^5$\n思路 一眼差分加前缀和，不过这里注意要多用一个差分数组来记录，而不能直接在原数组上打标记，因为之后要进行前缀和操作。\n时间复杂度为$O(n)$\n代码 void solve(){ int n, m, k; cin \u0026gt;\u0026gt; n \u0026gt;\u0026gt; m \u0026gt;\u0026gt; k; vector\u0026lt;ll\u0026gt;a(n + 1); vector\u0026lt;int\u0026gt;d(n + 1); vector\u0026lt;ll\u0026gt;s(n + 1); for (int i = 1; i \u0026lt;= n; i++) { cin \u0026gt;\u0026gt; a[i]; } for (int i = 1; i \u0026lt;= n; i++) { d[i] = a[i] - a[i - 1]; } while (m--){ int l, r, x; cin \u0026gt;\u0026gt; l \u0026gt;\u0026gt; r \u0026gt;\u0026gt; x; d[l] += x; d[r + 1] -= x; } for (int i = 1; i \u0026lt;= n; i++) { a[i] = a[i - 1] + d[i]; s[i] = a[i]; s[i] += s[i - 1]; } while (k--){ int l, r; cin \u0026gt;\u0026gt; l \u0026gt;\u0026gt; r; cout \u0026lt;\u0026lt; s[r] - s[l - 1] \u0026lt;\u0026lt; endl; } } 经典忘开LL然后WA了一发\n看到个神仙做法，贴一下\nsigned main() { read(n);read(m);read(k); for(int i=1;i\u0026lt;=n;++i) read(a[i]); adjacent_difference(a+1, a+n+1, a+1); while(m){ read(l); read(r); read(x); a[l] += x; a[r+1] -= x; --m; } partial_sum(a+1, a+n+1, a+1); partial_sum(a+1, a+n+1, a+1); while(k){ read(l); read(r); printf(\u0026#34;%lld\\n\u0026#34;,a[r]-a[l-1]); --k; } return 0; } 看懂了adjacent_difference和partial_sum后写了个带注释版的\nvoid solve2(){ int n, m, k; cin \u0026gt;\u0026gt; n \u0026gt;\u0026gt; m \u0026gt;\u0026gt; k; vector\u0026lt;ll\u0026gt;a(n + 1); for (int i = 1; i \u0026lt;= n; i++) { cin \u0026gt;\u0026gt; a[i]; } adjacent_difference(a.begin() + 1, a.end(), a.begin() + 1);//将原数组变为差分数组 int l, r, x; while (m--){ cin \u0026gt;\u0026gt; l \u0026gt;\u0026gt; r \u0026gt;\u0026gt; x; a[l] += x; a[r + 1] -= x;//在差分数组里面进行区间修改 } partial_sum(a.begin() + 1, a.end(), a.begin() + 1);//将差分数组还原为原数组（后一项加前一项） partial_sum(a.begin() + 1, a.end(), a.begin() + 1);//将原数组变化为前缀和 while (k--){ cin \u0026gt;\u0026gt; l \u0026gt;\u0026gt; r; cout \u0026lt;\u0026lt; a[r] - a[l - 1] \u0026lt;\u0026lt; endl; } } 5.11 题目链接 描述 有一个 $01$ 序列，每次可以对其中的某一位取反（$0$变$1$，$1$变$0$）\n求最少翻转其中的几位可以使得该序列变为非递减序列\n思路 不能相信这个题我昨天居然没看出来。。。最开始想的是找第一个$1$后面的$0$，每两个一组，数数就完了。\n然后寄得很彻底，然后开摆了 然后甚至也没复习模电去看剧了\n正确思路是找到$0$和$1$的分界点，分界点前面有$0$必须全是$0$，后面有$1$必须全是$1$。所以要分别找前面的$1$的数量和后面的$0$的数量。\n用$a_i$记录到$i$点的前缀和，此分界点需要修改的数量为\n$$a[i] + n - i - (a[n] - a[i])$$\n扫一遍找最小值即可，复杂度是$O(n)$的\n代码 void solve() { int n; cin \u0026gt;\u0026gt; n; string s; cin \u0026gt;\u0026gt; s; vector\u0026lt;int\u0026gt;a(n + 1); for (int i = 1; i \u0026lt;= n; i++) { a[i] = a[i - 1] + s[i - 1] - \u0026#39;0\u0026#39;; } int ans = INF; for (int i = 0; i \u0026lt;= n; i++) { ans = min(ans, a[i] + n - i - a[n] + a[i]); } cout \u0026lt;\u0026lt; ans \u0026lt;\u0026lt; endl; } 感觉就是个div2A的题，已经是个废人了\u0026hellip;\n5.12 （待补） 题目链接 描述 约翰是一个农场主，他的农场有$n$块田，编号从 $1$到 $n$，这 $n$块田通过 $m$条双向道路相连（数据保证这$n$块田都是联通的），我们假设第$i$块田会产生 $2^i$$kg$ 的收益，现在约翰想把农田的工作全部交给自己的两个孩子，划分方式必须满足以下规则:\n1.每一块田都需要恰好被分给一个孩子.\n2.分给两个孩子的农田必须是联通的.就是说对于任意一个孩子在划分给自己的任意一块田，都可以不经过另外一个孩子的田，到达自己的任意一块田.\n3.划分给两个孩子的收益必须尽可能的相等，如果无法相等，年长的孩子会得到大的那一份.\n对于第 $i$块田，如果你要把它分给年长的孩子，请输出$A$,否则输出$B$.\n$2≤n≤3e5,1≤m≤3e5$\n思路 并查集\n代码（copy） class DSU{ vector\u0026lt;int\u0026gt; fa, sz; public: explicit DSU(int n ) : fa(n), sz(n){ iota(all(fa),0); fill(all(sz),1); } int find(int i){ return i == fa[i] ? i : (fa[i] = find(fa[i])); } void join(int i, int j){ int a = find(i), b = find(j); if (a == b) return; if (a \u0026gt; b) swap(a, b); fa[b] = a, sz[a] += sz[b]; } int size(int i){ return sz[i]; } }; void solve(){ int n, m; cin \u0026gt;\u0026gt; n \u0026gt;\u0026gt; m; DSU dsu(n); while (m--){ int x, y; cin \u0026gt;\u0026gt; x \u0026gt;\u0026gt; y; x--,y--; if (x != n - 1 \u0026amp;\u0026amp; y != n - 1){ dsu.join(x, y); } } string ans (n, \u0026#39;A\u0026#39;); for (int i = 0; i \u0026lt; n - 1; i++) { if (dsu.find(i) == dsu.find(n - 2)) ans[i] = \u0026#39;B\u0026#39;; } cout \u0026lt;\u0026lt; ans \u0026lt;\u0026lt; endl; } 5.13 （待补） 题目链接 原题链接 描述 B 地区在地震过后，所有村庄都造成了一定的损毁，而这场地震却没对公路造成什么影响。但是在村庄重建好之前，所有与未重建完成的村庄的公路均无法通车。换句话说，只有连接着两个重建完成的村庄的公路才能通车，只能到达重建完成的村庄。\n给出 B 地区的村庄数 $N$，村庄编号从 $0$ 到 $N-1$，和所有 $M$ 条公路的长度，公路是双向的。并给出第 ii 个村庄重建完成的时间 $t_i$，你可以认为是同时开始重建并在第 $t_i$天重建完成，并且在当天即可通车。若 $t_i$为 $0$ 则说明地震未对此地区造成损坏，一开始就可以通车。之后有 $Q$ 个询问 $(x,y,t)$，对于每个询问你要回答在第 $t$ 天，从村庄 $x$ 到村庄 $y$ 的最短路径长度为多少。如果无法找到从 $X$ 村庄到 $y$ 村庄的路径，经过若干个已重建完成的村庄，或者村庄 $x$ 或村庄 $y$ 在第 $t$ 天仍未重建完成，则需要返回 -1\n思路 Floyd\n代码（Copy） #define N 205 int n,m; int a[N]; int f[N][N];//邻接矩阵存边 inline void updata(int k){ for(int i=0;i\u0026lt;n;i++) for(int j=0;j\u0026lt;n;j++) if(f[i][j]\u0026gt;f[i][k]+f[j][k]) f[i][j]=f[j][i]=f[i][k]+f[j][k];//用这个新的更新所有前面的 return; } int main(){ cin\u0026gt;\u0026gt;n\u0026gt;\u0026gt;m; for(int i=0;i\u0026lt;n;i++) scanf(\u0026#34;%d\u0026#34;,a+i);//依次输入每一个村庄建立完成时需要的时间 for(int i=0;i\u0026lt;n;i++) for(int j=0;j\u0026lt;n;j++){ f[i][j]=1e9;//初始化为保证它不爆炸范围内的最大值 } for(int i=0;i\u0026lt;n;i++) f[i][i]=0; int s1,s2,s3; for(int i=1;i\u0026lt;=m;i++){ scanf(\u0026#34;%d%d%d\u0026#34;,\u0026amp;s1,\u0026amp;s2,\u0026amp;s3); f[s1][s2]=f[s2][s1]=s3;//初始化边长 } int q; cin\u0026gt;\u0026gt;q; int now=0; for(int i=1;i\u0026lt;=q;i++){//处理各询问 scanf(\u0026#34;%d%d%d\u0026#34;,\u0026amp;s1,\u0026amp;s2,\u0026amp;s3); while(a[now]\u0026lt;=s3\u0026amp;\u0026amp;now\u0026lt;n){ updata(now);//依次更新点，使它可以被用来更新其他的点 now++; } if(a[s1]\u0026gt;s3||a[s2]\u0026gt;s3)cout\u0026lt;\u0026lt;-1\u0026lt;\u0026lt;endl; else { if(f[s1][s2]==1e9)cout\u0026lt;\u0026lt;-1\u0026lt;\u0026lt;endl; else cout\u0026lt;\u0026lt;f[s1][s2]\u0026lt;\u0026lt;endl; } } return 0; } ","date":"2022-04-23T11:56:46Z","image":"https://s1.ax1x.com/2022/04/27/Lqf2o8.png","permalink":"https://inariindream.fun/blog/2022/04/23/namomocamp%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98div2/","title":"NamomoCamp每日一题（div2）"},{"content":"2021对我来说十分匆忙与短暂，以至于我在最后一天才有闲暇，来回望过去的这一年。\n我想了很久，今年似乎很难用一句话或一个词来概括我过去十二个月的经历了。以五月底的插班生考试为分界线，我的2021的上下半年过得截然不同。\n贯穿我上半年的两个词应该是犹豫与遗憾。年初犹豫着是否要正式进入一段感情，四月初犹豫着是否要把考插的路坚持走完，也在插班生和课内绩点之间犹豫不决。最终，这些犹豫都变成了遗憾。\n插班生考试以一道证明大题的差距结束了我九个月的旅程，绩点以0.002的差距而错失了转入CS的机会。我只能给自己冠上“惜败”的名号聊以自慰。本来对未来有无穷的憧憬与计划，但变化总会挫败计划好的道路，使人怀疑按原有的计划是否还能走到理想的目的地，也会使人踌躇，究竟是该坚持还是放弃。\n关于考插的感想我在年中的时候已经写过，如果有现在也在这条路上感到迷茫的21级同学也可以去看看 : )\n我的生活似乎没什么变化，一点小小的梦想刚发芽就死去，不算什么大事，毕竟梦想的田野上，到处都是长眠的种子。但考完插班生之后的一段时间，我似乎进入了一种浑浑噩噩的状态。再也不必六点钟起床和考研人抢自习室了，再也不用对着竞赛题抓破脑袋了，再也不用看着手机上的倒数日期而焦虑了。我报复式地玩了两星期的怪猎和Apex。考完后一个月就是期末考试，但我似乎只是为了绩点而机械地复习着。就连暑假时的数模训练和icpc训练，也只是为了让自己不感到空虚的填充物而已。\n在仲夏时节，我听闻了几个同学复读出分的消息。在十二个月的努力之后，他们都获得了十分理想的结果。也有几个人来问过我“后悔没去复读吗”。我的回答跟问我“后悔考插吗”时候的回答相同: 我不后悔。如果重来一次的话，以现在的心智和阅历，还是会做出同样的选择。\n但是噩梦仍萦绕着我，树叶与飞鸟新旧轮替，夜晚却每夜如期而至。不只几个晚上，我都在想，如果在插班生考前看过柯西不等式的证明，如果我的工图画的再好一点点拉高绩点，那么现实会不会有那么一点点的不一样？\n在几个月后，因写论文需要，我翻看了尼采的《权力意志》，才知道那段时间的我，其实陷入了类似虚无主义的漩涡之中。他说:“虚无主义意味着最高价值的自行贬值。”\n当自己的需求可以被轻易代替时，那么以前有意义的事就会变得没有意义。仅仅是个人的主观给一个事物赋予意义，我需要它就有意义，若不需要，它存在的本身对我而言就是毫无意义。\n是我梦想中的将来想成为的那个自己，那个开阔，非凡，卓越和不凡的自己，成为了把我拉出虚无的救赎。我最终还是跟上半年的我和解。\n星宇低垂，旷野寥落，暮夏时节的银河分外清朗，也无比落寞。\n九月份开学后，还是很忙，繁重的课业似乎让我明白了为什么插班生只有大一能考（？\n我还是喜欢夜跑，还是习惯在跑完后抬头仰望寰宇，它如此辽阔。暮夏时分仍能看见夏日大三角，深秋之时猎户座依然清晰可见，就跟一年前我看到的时候没有区别。就跟上亿岁月前的它们没有区别。此时跑道和球场上还有挥洒汗水的人们，图书馆二楼应该有几张桌子围坐着小声讨论的小组成员，学院楼和泰山科研楼里应该仍旧灯火通明，马路沿边也许零散的分布着牵手散步的情侣，与我擦身而过的那个人可能是个内心十分丰富多彩的人，北广应该弥漫着勾魂的夜宵香味。不过，这些似乎都与我无关。每晚这时，也许也是我最与在赤壁下泛舟时的苏文忠先生心境最相近的时候。\n我忙于各种竞赛，还参加了学生组织，尽力让自己的生活变得充实。直到发现一个人的精力是无法在所有方面都做好的。几经挣扎，我最终还是选择退掉了一个科创队。（在这里向拉我进去的金康和莫指导说声对不起)最终我的目标还是定在了算法竞赛上，虽然我起步晚了点，再努力最终可能也就是个铜牌或者什么也没有，但我仍决定前往。也许这也是一种“罗曼罗兰式的英雄主义”吧（雾\n尼采其实也不是那么悲观的人，他还写过这样的话 “某天，你会邂逅高大的自己，不是平日里的自己，而是更清澈，更高级的自己。在那一瞬间，你会如受到恩宠一般察觉到高大自我的存在。”\n“请珍视那个瞬间。”\n后记:\n今年是我第二年给自己写年终总结了。相比去年，今年我的总结似乎字数少了点，没有了去年那么多浮华的词藻。或许是因为我意识到我不需要太多夸张的词汇去表述我的心情，或许是因为我经历的事情变少了一点，又或许只是单纯的因为我的读书数量没有去年多了（\n除去上面稍微有些沉重的部分，今年我的收获还是很多的。第一次在数学竞赛得奖，第一次跑完了十公里，第一次通宵后去看日出，第一次玩恐怖密室，第一次去猫咖，第一次参加数学建模，第一次打保龄球等等。这些点滴，也让我的今年显得没那么枯燥。\n我很高兴我把在年底写总结的习惯坚持了下来，像去年这时说过的那样，我也不希望内心丰富的情感在生活公式化的磨砺中消逝，因此我选择以这样的方式来记录。\n祝大家新的一年万事顺遂\n新年快乐！\n","date":"2022-01-29T09:39:43Z","image":"https://s1.ax1x.com/2022/04/29/Lx8ogU.jpg","permalink":"https://inariindream.fun/blog/2022/01/29/2021%E5%B9%B4%E7%BB%88%E6%80%BB%E7%BB%93/","title":"2021年终总结"},{"content":"用一句话总结我所经历的2020年\n“在理想中死亡，在现实中重生。”\n今年是无比艰难的一年，以至于每个人都在年末的时候对未来有着美好的祝愿。\n像2019年的这个时候我们祝愿的那样。\n突如其来的疫情打乱了我们每一个人的既定节奏，年初一直待在家里，我在一段时间内对外面发生的事情没有什么实感。但电视里看到的疫情速报是真的，手机里浏览到的在疫情下普通人的求助是真的，看着窗外的三环路从川流不息变为空无一车也是真的。在本应是开学典礼的时间，各科老师在线上，透过摄像头向我们传来了特殊的问候。在家里上课和考试特别考验一个人的心志，尤其是毅力和自制力，两样我最缺的东西。网课的新奇感渐渐变为无聊和放纵。甚至后来把部分课和晚自习当成我的自习课，连上课网站都懒得打开签到。\n开学再见面时，我或多或少有些彷若隔世的感觉。\n高考前的时间，在紧凑的课程和成堆的卷子面前显得弥足珍贵，同时也快得让我几乎感受不到时间的飞逝。我曾经觉得我是一个十分在意他人评价的人，并且常常因为褒扬沾沾自喜。但在我成绩真真实实的上升之后，在我听到同学戏谑地称我“黑”马的时候，在我听到室友说我扮猪吃老虎的时候，在听到金老在班会点名表扬我的时候，我的内心却没有多少喜悦的感觉。也许是因为我自知，我那远大的理想相对于我的努力而言仍然只是一个天边遥不可及的幻梦罢了。\n在倒计时十五天的时候，我翘掉了那天下午的数学考试，敲开了金老办公室的门。我想在剩下的时间回家自习，即使他在之前的班会明确地表示过禁止，我仍想要一试，因为我觉得这可能是我达成理想的最后机会了。我以为我的口才和出奇好的三诊成绩足以说服他，可当他以一种不容置疑的口气说出“不行。”的时候，我却发现 我除了流泪什么也做不到。他让我去找副校长请假，犹豫再三，我最终叩响了校长办公室的门\u0026hellip;\n事情最后有了个折中的解决，金老最后松了口，但仍需要找副校长商量，因为作为班主任没有权限放学生离校那么长的时间。而我，在学校继续待了五天后，在家里度过了高考前的最后十天，幻想着这十天能让我的成绩再来次质的飞跃。\n可惜生活是不会按着个人主观意愿的剧本来进行的。在亲眼看到结果之后，我感到头晕目眩。堆积如山的书和资料在高考后就被我卖掉，我自己断了复读这条路。我感到一股深深的愧疚，我觉得我对不起金老和其他各科老师对我的信任，我觉得我对不起和朋友夜谈时所谈及的远大梦想，我觉得我对不起爷爷，没能做到去年夏天给病榻上的他发去的视频里对他的承诺。我没能见到理想中的人，没能去到理想的学校，没能选到理想的专业，没能成为理想中的自己\u0026hellip;\n一段时间之后我才明白，这是一场再公平不过的考试，我不能简单地归因于紧张或是失利，它检验的是整个高中三年的学习。我的成绩既包含了最后一学期的努力，也有前两年的放纵。而我看到那些持之以恒努力的人，熬过一个又一个的黑夜，在日出之后，他们都得到了他们想要的梦想和成绩。\n高考后的暑假我总是会对大学有各种各样的畅想。更大的平台，更多的自由，更广的见识，更多的机会，这些都是我对大学生活的憧憬。进学校的第一天我被新鲜感淹没，在第一天晚上，我躺在床上，多少有点睡不着。我仍在畅想着即将可能到来的丰富的社团，紧张的竞赛，珍贵的感情。\n虽然实际的大学生活没有想象中的那般精彩，但我在几个月的时间里仍然收获了很多。最大的感受是十分真切的感受到: 越是看的越多，学的越多，越能感受到自己的浅陋无知，傲慢自大。我了解到有个学长以前在毛坦厂一年从大专水平努力到了我们学校的分数线；我在夜跑团里看到有人每天都坚持至少五公里，风雨无阻；我那最自信的英语，在我听到同班的有个人词汇量1w2时，在我看到有考插班生的人在十二月就已背完考研词汇的时，我那可怜的自尊与优越感被实实在在地击碎了。我想起暑假与朋友共勉的“总不能让高三成为人生的巅峰吧”，深知我还有很长的一条路要走。没能考到理想的分数不影响我喜欢现在的学校，哪怕它没有那么优秀，但它是我的平台，有它我才能有努力的机会。\n下半年我听到最多的一个词是“内卷”，它是四川高考的现状，是图书馆七点就爆满的深层原因，是灯火通明的通宵自习室里考研人的焦虑。我不知道我的未来是否会更加艰难。在谈及梦想的时候，我对我未来的五年都有精细的规划和打算，但我却不知道如何迈出第一步。我到了小时候羡慕的年龄，却没有成为小时候想成为的人。我没有迷茫，我只有恐慌。\n学校离海边很近，因此我有幸欣赏了一次海上日出和海上日落。临港离市区很远，没有光污染，晴朗的时候，即使在冬天 每天也能看到十颗以上的星星，我喜欢在夜跑之后就呆呆地望着天上的星星，从初秋时仍然可见的夏季大三角，到天气转凉时每天可见的火星，再到严冬时节的猎户座和闪耀的天狼星。每当我望着这些瑰丽而美好的景色的时候，我的思绪在操场边走马观花。唯独在这些时候，我不会因临近deadline而没做完作业而紧张，不会因还没达成梦想而彷徨失落，不会因对爱情抱有憧憬而神色迷离。临港的风很大，我拥抱着咸湿的海风，似乎这样就能将我所有的焦虑抛在风里，任它刮走远去。\n“无穷的远方，无数的人们，都和我有关。”\n后记\n今年是我写年终总结的第一年，初心可能是小时候看到南方周末新年祝福的感动，又或许只是需要将一些情感用文字抒写出来，以将我乱糟糟的生活给稍微理顺一点，就像游戏中一个又一个的checkpoint，是一种记录，也是一种反思。\n从知道到做到，有着一道鸿沟。“我们明白很多道理，却仍过不好这一生。”的原因大概如此。\n路波折坎坷，这又长又短的一年也算是到了头，可有些事并不为人力所控。\n努力了也会失败。\n祈祷了也会落空。\n逃避了也会遭重。\n谋事在人，成事在天，不外如是。\n即使如此，也不妨碍我们向前看。总得去努力才能知道结果，总得去尝试才能知成败，可别在开始前就露了怯。\n在最后，我由衷的希望来年有好事发生，由衷的希望各位来年能心想事成。\n愿各位平安喜乐\n新年快乐！ ","date":"2021-01-01T09:36:43Z","image":"https://s1.ax1x.com/2022/04/27/LqhKmt.jpg","permalink":"https://inariindream.fun/blog/2021/01/01/2020%E5%B9%B4%E7%BB%88%E6%80%BB%E7%BB%93/","title":"2020年终总结"}]